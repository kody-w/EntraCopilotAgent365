<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <!-- Cycle 26: Removed zoom restrictions for accessibility -->
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="description" content="Enhanced Multi-User Chat Application with Voice Support" />
  <meta name="theme-color" content="#742774" />
  <title>Chat Application</title>

  <!-- Cycle 26: Resource hints for CDN performance -->
  <link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin />
  <link rel="dns-prefetch" href="https://cdnjs.cloudflare.com" />

  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" rel="stylesheet" />
  <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/styles/github-dark.min.css" rel="stylesheet" />

  <style>
    :root {
      --primary: #742774;
      --primary-light: #9168b6;
      --primary-dark: #4f1c4f;
      --primary-rgb: 116, 39, 116;
      --secondary: #00bcd4;
      --secondary-light: #4dd0e1;
      --accent: #ff4081;
      --success: #4caf50;
      --error: #f44336;
      --warning: #ff9800;
      --info: #2196f3;

      /* Light mode grays - Contrast-optimized for WCAG AA compliance */
      --gray-10: #faf9f8;  /* Background */
      --gray-20: #f3f2f1;  /* Surface */
      --gray-30: #e8e6e4;  /* Borders, dividers */
      --gray-40: #d4d2d0;  /* Subtle borders */
      --gray-50: #8a8886;  /* UI elements, placeholders */
      --gray-60: #6e6d6b;  /* Secondary text, labels */
      --gray-70: #5c5b59;  /* Mid-emphasis text */
      --gray-80: #4a4948;  /* Higher emphasis muted text */
      --gray-100: #323130; /* Primary text */
      --gray-130: #1a1918; /* Darkest text */

      --space-xs: 4px;
      --space-s: 8px;
      --space-m: 16px;
      --space-l: 24px;
      --space-xl: 32px;
      --space-xxl: 48px;

      --radius: 8px;
      --radius-small: 4px;
      --radius-large: 16px;
      --radius-full: 9999px;

      --shadow-small: 0 2px 8px rgba(0, 0, 0, 0.08);
      --shadow-medium: 0 4px 16px rgba(0, 0, 0, 0.12);
      --shadow-large: 0 8px 32px rgba(0, 0, 0, 0.16);

      --header-height: 56px;
      --input-container-height: 80px;
      --safe-area-top: env(safe-area-inset-top);
      --safe-area-bottom: env(safe-area-inset-bottom);

      --transition: all 0.2s ease;

      /* Cycle 27: Unified transition timing system */
      --duration-fast: 0.15s;
      --duration-normal: 0.3s;
      --duration-slow: 0.5s;
      --ease-out: cubic-bezier(0.16, 1, 0.3, 1);
      --ease-spring: cubic-bezier(0.34, 1.56, 0.64, 1);
      --ease-smooth: cubic-bezier(0.4, 0, 0.2, 1);
    }

    /* Dark mode variables - Contrast-optimized for WCAG AA compliance */
    body.dark {
      --gray-10: #1a1a1a;
      --gray-20: #242424;
      --gray-30: #2d2d2d;
      --gray-40: #3d3d3d;
      --gray-50: #6b6b6b; /* UI elements, placeholders, subtle text */
      --gray-60: #9e9e9e; /* Secondary text, labels, muted content */
      --gray-70: #a8a8a8; /* Mid-emphasis text */
      --gray-80: #b8b8b8; /* Higher emphasis muted text */
      --gray-100: #f0f0f0; /* Primary text - AAA contrast 7:1+ */
      --gray-130: #f5f5f5;
      --primary-light: #a47cc9;
      --shadow-small: 0 2px 8px rgba(0, 0, 0, 0.3);
      --shadow-medium: 0 4px 16px rgba(0, 0, 0, 0.4);
      --shadow-large: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
      -webkit-tap-highlight-color: transparent;
    }

    /* Cycle 28: Prevent long-press context menu on touch devices */
    button,
    .input-button,
    .fab,
    .message-action-btn,
    .code-copy-btn,
    .sidebar-tab {
      touch-action: manipulation;
      -webkit-touch-callout: none;
    }

    /* Allow text selection globally */
    body,
    div,
    span,
    p,
    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    code,
    pre {
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }

    /* Only disable selection for interactive elements */
    button,
    .button,
    .fab,
    label,
    .clickable {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }

    /* Cycle 22: Text selection highlighting */
    ::selection {
      background: rgba(var(--primary-rgb), 0.3);
      color: inherit;
    }

    ::-moz-selection {
      background: rgba(var(--primary-rgb), 0.3);
      color: inherit;
    }

    body.dark ::selection {
      background: var(--primary-light);
      color: var(--gray-10);
    }

    body.dark ::-moz-selection {
      background: var(--primary-light);
      color: var(--gray-10);
    }

    html,
    body {
      height: 100%;
      overflow: hidden;
      position: fixed;
      width: 100%;
      /* Overscroll Prevention - Cycle 5 Feature */
      overscroll-behavior: none;
      -webkit-overflow-scrolling: touch;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
        sans-serif;
      background: var(--gray-10);
      color: var(--gray-100);
      line-height: 1.6;
      -webkit-font-smoothing: antialiased;
    }

    /* Mention Autocomplete Dropdown */
    .mention-dropdown {
      position: absolute;
      bottom: 100%;
      left: 0;
      right: 0;
      background: white;
      border: 2px solid var(--gray-30);
      border-radius: var(--radius);
      margin-bottom: var(--space-s);
      max-height: 200px;
      overflow-y: auto;
      display: none;
      box-shadow: var(--shadow-medium);
      z-index: 100;
    }

    body.dark .mention-dropdown {
      background: var(--gray-30);
    }

    .mention-dropdown.active {
      display: block;
      animation: slideUp 0.2s ease-out;
    }

    .mention-item {
      padding: var(--space-m);
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      gap: var(--space-m);
      border-bottom: 1px solid var(--gray-20);
    }

    body.dark .mention-item {
      border-bottom-color: var(--gray-40);
    }

    .mention-item:last-child {
      border-bottom: none;
    }

    .mention-item:hover,
    .mention-item.selected {
      background: rgba(var(--primary-rgb), 0.08);
    }

    .mention-item-icon {
      width: 32px;
      height: 32px;
      border-radius: var(--radius-full);
      background: var(--primary);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 600;
    }

    .mention-item-info {
      flex: 1;
    }

    .mention-item-name {
      font-weight: 600;
      color: var(--gray-100);
      font-size: 14px;
    }

    .mention-item-url {
      font-size: 12px;
      color: var(--gray-60);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Mention Tag in Messages */
    .mention-tag {
      background: rgba(var(--primary-rgb), 0.15);
      color: var(--primary);
      padding: 2px 8px;
      border-radius: var(--radius-small);
      font-weight: 600;
      display: inline-block;
      margin: 0 2px;
    }

    body.dark .mention-tag {
      background: rgba(var(--primary-rgb), 0.25);
      color: var(--primary-light);
    }

    /* Endpoint Badge - Simplified, less prominent (Strategies 1,4,8) */
    .endpoint-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 3px 8px;
      background: rgba(var(--primary-rgb), 0.08);
      border-radius: var(--radius);
      font-size: 10px;
      font-weight: 500;
      color: var(--gray-60);
      margin-left: var(--space-xs);
      border: none;
      transition: all 0.15s ease;
    }

    .endpoint-badge:hover {
      background: rgba(var(--primary-rgb), 0.12);
      color: var(--primary);
    }

    .endpoint-badge i {
      font-size: 9px;
      opacity: 0.6;
    }

    body.dark .endpoint-badge {
      background: rgba(255, 255, 255, 0.08);
      color: var(--gray-50);
    }

    body.dark .endpoint-badge:hover {
      background: rgba(var(--primary-rgb), 0.15);
      color: var(--primary-light);
    }

    /* Agent Output Styles - Clean Card Design */
    .agent-output-wrapper {
      margin: var(--space-m) 0;
      background: linear-gradient(135deg, #f8f9fc 0%, #f0f2f8 100%);
      border: 1px solid #e2e6f0;
      border-radius: 12px;
      overflow: hidden;
      transition: var(--transition);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
    }

    body.dark .agent-output-wrapper {
      background: linear-gradient(135deg, #2a2d3a 0%, #1e2028 100%);
      border-color: #3d4156;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
    }

    .agent-output-header {
      padding: var(--space-m) var(--space-l);
      display: flex;
      align-items: center;
      cursor: pointer;
      user-select: none;
      transition: var(--transition);
      gap: var(--space-m);
    }

    .agent-output-header:hover {
      background: rgba(0, 0, 0, 0.03);
    }

    body.dark .agent-output-header:hover {
      background: rgba(255, 255, 255, 0.03);
    }

    .agent-output-icon {
      width: 36px;
      height: 36px;
      border-radius: 10px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 16px;
      flex-shrink: 0;
      box-shadow: 0 2px 6px rgba(var(--primary-rgb), 0.3);
    }

    .agent-output-info {
      flex: 1;
      min-width: 0;
    }

    .agent-output-title {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
      font-size: 14px;
      font-weight: 600;
      color: #2d3748;
      margin-bottom: 2px;
    }

    body.dark .agent-output-title {
      color: #e8eaf0;
    }

    .agent-output-title .agent-name {
      color: var(--primary);
      font-weight: 700;
    }

    body.dark .agent-output-title .agent-name {
      color: var(--primary-light);
    }

    /* Preview snippet below title */
    .agent-output-preview {
      font-size: 12px;
      color: #718096;
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 100%;
      line-height: 1.4;
    }

    body.dark .agent-output-preview {
      color: #a0aec0;
    }

    .agent-output-toggle {
      background: #edf2f7;
      border: none;
      color: #4a5568;
      cursor: pointer;
      transition: var(--transition);
      padding: 8px;
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    body.dark .agent-output-toggle {
      background: #3d4156;
      color: #a0aec0;
    }

    .agent-output-toggle:hover {
      background: var(--primary);
      color: white;
      transform: scale(1.05);
    }

    .agent-output-toggle i {
      transition: transform 0.3s ease;
    }

    .agent-output-wrapper.expanded .agent-output-toggle i {
      transform: rotate(180deg);
    }

    .agent-output-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
      border-top: 1px solid transparent;
    }

    .agent-output-content.expanded {
      max-height: 500px;
      overflow-y: auto;
      border-top-color: #e2e6f0;
    }

    body.dark .agent-output-content.expanded {
      border-top-color: #3d4156;
    }

    .agent-output-text {
      padding: var(--space-m) var(--space-l);
      font-family: 'SF Mono', Monaco, 'Cascadia Code', monospace;
      font-size: 12px;
      color: #4a5568;
      white-space: pre-wrap;
      word-wrap: break-word;
      line-height: 1.6;
      background: rgba(0, 0, 0, 0.02);
    }

    body.dark .agent-output-text {
      color: #cbd5e0;
      background: rgba(0, 0, 0, 0.15);
    }

    @media (max-width: 480px) {
      .agent-output-preview {
        display: none;
      }
      .agent-output-header {
        padding: var(--space-s) var(--space-m);
      }
      .agent-output-icon {
        width: 32px;
        height: 32px;
        font-size: 14px;
      }
    }

    /* Simple Link Styles */
    .link-wrapper {
      display: inline;
      margin: 0 2px;
    }

    .link-wrapper a {
      color: var(--primary);
      text-decoration: none;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .link-wrapper a:hover {
      text-decoration: underline;
      color: var(--primary-light);
    }

    .link-wrapper i {
      font-size: 12px;
    }

    /* Endpoint Management Styles */
    .endpoint-search-container {
      position: relative;
      margin-bottom: var(--space-m);
    }

    .endpoint-search {
      width: 100%;
      padding: 10px 12px 10px 36px;
      border: 1px solid var(--gray-30);
      border-radius: var(--radius);
      background: var(--gray-10);
      color: var(--gray-100);
      font-size: 14px;
      transition: var(--transition);
    }

    body.dark .endpoint-search {
      background: var(--gray-20);
      border-color: var(--gray-40);
    }

    .endpoint-search:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.1);
    }

    .endpoint-search-icon {
      position: absolute;
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
      color: var(--gray-60);
      font-size: 14px;
    }

    .endpoint-list {
      margin-top: var(--space-m);
      max-height: 400px;
      overflow-y: auto;
    }

    .endpoint-list::-webkit-scrollbar {
      width: 6px;
    }

    .endpoint-list::-webkit-scrollbar-track {
      background: transparent;
    }

    .endpoint-list::-webkit-scrollbar-thumb {
      background: var(--gray-40);
      border-radius: 3px;
    }

    .endpoint-item {
      padding: var(--space-m);
      background: var(--gray-20);
      border-radius: var(--radius);
      margin-bottom: var(--space-s);
      display: flex;
      align-items: center;
      gap: var(--space-m);
      transition: var(--transition);
      cursor: grab;
      border: 2px solid transparent;
      position: relative;
    }

    body.dark .endpoint-item {
      background: var(--gray-30);
    }

    .endpoint-item:hover {
      background: var(--gray-30);
    }

    body.dark .endpoint-item:hover {
      background: var(--gray-40);
    }

    .endpoint-item.active {
      border-color: var(--success);
      background: rgba(var(--success-rgb, 76, 175, 80), 0.08);
    }

    body.dark .endpoint-item.active {
      background: rgba(var(--success-rgb, 76, 175, 80), 0.12);
    }

    .endpoint-item.dragging {
      opacity: 0.5;
      cursor: grabbing;
    }

    .endpoint-item.drag-over {
      border-color: var(--primary);
      background: rgba(var(--primary-rgb), 0.08);
    }

    .endpoint-drag-handle {
      color: var(--gray-50);
      cursor: grab;
      padding: 4px;
      margin-left: -4px;
      opacity: 0;
      transition: var(--transition);
    }

    .endpoint-item:hover .endpoint-drag-handle {
      opacity: 1;
    }

    .endpoint-item-icon {
      width: 44px;
      height: 44px;
      border-radius: var(--radius-full);
      background: var(--primary);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: 600;
      flex-shrink: 0;
      position: relative;
    }

    .endpoint-item-icon.local {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    .endpoint-item-icon.production {
      background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
    }

    .endpoint-item-icon.staging {
      background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
    }

    .endpoint-item-icon.development {
      background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
    }

    .endpoint-status-indicator {
      position: absolute;
      bottom: 0;
      right: 0;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid var(--gray-20);
      background: var(--gray-50);
    }

    body.dark .endpoint-status-indicator {
      border-color: var(--gray-30);
    }

    .endpoint-status-indicator.online {
      background: var(--success);
      animation: pulse-status 2s infinite;
    }

    .endpoint-status-indicator.offline {
      background: var(--error);
    }

    .endpoint-status-indicator.testing {
      background: var(--warning);
      animation: pulse-status 0.5s infinite;
    }

    @keyframes pulse-status {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }

    .endpoint-item-info {
      flex: 1;
      min-width: 0;
    }

    .endpoint-item-header {
      display: flex;
      align-items: center;
      gap: var(--space-s);
      margin-bottom: 4px;
    }

    .endpoint-item-name {
      font-weight: 600;
      color: var(--gray-100);
    }

    .endpoint-env-tag {
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      padding: 2px 6px;
      border-radius: 4px;
      letter-spacing: 0.5px;
    }

    .endpoint-env-tag.local {
      background: rgba(102, 126, 234, 0.15);
      color: #667eea;
    }

    .endpoint-env-tag.production {
      background: rgba(56, 239, 125, 0.15);
      color: #11998e;
    }

    .endpoint-env-tag.staging {
      background: rgba(245, 87, 108, 0.15);
      color: #f5576c;
    }

    .endpoint-env-tag.development {
      background: rgba(79, 172, 254, 0.15);
      color: #4facfe;
    }

    .endpoint-item-url {
      font-size: 12px;
      color: var(--gray-60);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      margin-bottom: 4px;
    }

    .endpoint-item-meta {
      display: flex;
      align-items: center;
      gap: var(--space-m);
      font-size: 11px;
      color: var(--gray-50);
    }

    .endpoint-item-meta span {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .endpoint-item-meta i {
      font-size: 10px;
    }

    .endpoint-item-actions {
      display: flex;
      gap: var(--space-xs);
      opacity: 0;
      transition: var(--transition);
    }

    .endpoint-item:hover .endpoint-item-actions {
      opacity: 1;
    }

    .endpoint-item-action {
      background: var(--gray-30);
      border: none;
      color: var(--gray-80);
      width: 32px;
      height: 32px;
      border-radius: var(--radius-small);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: var(--transition);
      position: relative;
    }

    body.dark .endpoint-item-action {
      background: var(--gray-40);
    }

    .endpoint-item-action:hover {
      background: var(--primary);
      color: white;
    }

    .endpoint-item-action.active {
      background: var(--success);
      color: white;
      opacity: 1;
    }

    .endpoint-item-action.test-btn:hover {
      background: var(--info, #2196f3);
    }

    .endpoint-item-action.duplicate-btn:hover {
      background: var(--warning);
    }

    .endpoint-item-action.delete-btn:hover {
      background: var(--error);
    }

    .endpoint-item-action[data-tooltip]:hover::after {
      content: attr(data-tooltip);
      position: absolute;
      bottom: 100%;
      left: 50%;
      transform: translateX(-50%);
      padding: 4px 8px;
      background: var(--gray-90);
      color: white;
      font-size: 11px;
      border-radius: 4px;
      white-space: nowrap;
      margin-bottom: 4px;
      z-index: 10;
    }

    .endpoint-empty-state {
      text-align: center;
      padding: 40px 20px;
      color: var(--gray-60);
    }

    .endpoint-empty-state i {
      font-size: 48px;
      margin-bottom: var(--space-m);
      opacity: 0.5;
    }

    .endpoint-empty-state p {
      margin: 0;
    }

    .endpoint-add-btn {
      width: 100%;
      margin-top: var(--space-m);
      padding: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-s);
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark, #7c4dff) 100%);
      border: none;
      border-radius: var(--radius);
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
    }

    .endpoint-add-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 4px 12px rgba(var(--primary-rgb), 0.3);
    }

    .endpoint-quick-actions {
      display: flex;
      gap: var(--space-s);
      margin-top: var(--space-s);
    }

    .endpoint-quick-action {
      flex: 1;
      padding: 8px 12px;
      font-size: 12px;
      border-radius: var(--radius-small);
      border: 1px dashed var(--gray-40);
      background: transparent;
      color: var(--gray-70);
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .endpoint-quick-action:hover {
      border-color: var(--primary);
      color: var(--primary);
      background: rgba(var(--primary-rgb), 0.05);
    }

    /* Settings Import/Export Buttons */
    .settings-import-export {
      display: flex;
      gap: var(--space-m);
      margin-bottom: var(--space-xl);
      padding-bottom: var(--space-xl);
      border-bottom: 1px solid var(--gray-30);
    }

    .settings-import-export button {
      flex: 1;
    }

    /* Animations */
    @keyframes fadeIn {
      from {
        opacity: 0;
      }

      to {
        opacity: 1;
      }
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    @keyframes scaleIn {
      from {
        opacity: 0;
        transform: scale(0.9);
      }

      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }

      to {
        transform: translateX(0);
        opacity: 1;
      }
    }

    @keyframes slideOut {
      from {
        transform: translateX(0);
        opacity: 1;
      }

      to {
        transform: translateX(100%);
        opacity: 0;
      }
    }

    @keyframes spin {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 0.9;
      }

      50% {
        opacity: 0.6;
      }
    }

    /* Staggered Page Load Animation - Cycle 13 */
    @keyframes staggerFadeIn {
      from {
        opacity: 0;
        transform: translateY(-10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .header {
      animation: staggerFadeIn 0.4s ease-out forwards;
    }

    .chat-container {
      animation: staggerFadeIn 0.4s ease-out 0.1s forwards;
      opacity: 0;
    }

    .welcome-content {
      animation: staggerFadeIn 0.4s ease-out 0.2s forwards;
      opacity: 0;
    }

    .input-container {
      animation: staggerFadeIn 0.4s ease-out 0.15s forwards;
      opacity: 0;
    }

    /* Login Page */
    .login-container {
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      padding: var(--space-l);
      animation: fadeIn 0.5s ease-out;
      position: relative;
      overflow: hidden;
    }

    .login-container::before {
      content: "";
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 60%);
      animation: loginBgPulse 15s ease-in-out infinite;
    }

    @keyframes loginBgPulse {
      0%, 100% { transform: translate(0, 0); }
      50% { transform: translate(10%, 10%); }
    }

    .login-box {
      background: rgba(255, 255, 255, 0.98);
      backdrop-filter: blur(20px);
      padding: var(--space-xl);
      border-radius: 20px;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
      width: 100%;
      max-width: 440px;
      animation: scaleIn 0.5s ease-out;
      position: relative;
      z-index: 1;
    }

    body.dark .login-box {
      background: rgba(36, 36, 36, 0.98);
    }

    .login-header {
      text-align: center;
      margin-bottom: var(--space-xl);
    }

    .login-logo {
      width: 72px;
      height: 72px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      border-radius: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin: 0 auto var(--space-l);
      box-shadow: 0 10px 30px rgba(var(--primary-rgb), 0.3);
      animation: logoFloat 3s ease-in-out infinite;
    }

    @keyframes logoFloat {
      0%, 100% { transform: translateY(0); }
      50% { transform: translateY(-5px); }
    }

    .login-logo i {
      font-size: 32px;
      color: white;
    }

    .login-header h1 {
      color: var(--primary);
      font-size: 28px;
      font-weight: 700;
      margin-bottom: var(--space-xs);
      letter-spacing: -0.5px;
    }

    .login-header p {
      color: var(--gray-60);
      font-size: 14px;
    }

    .form-group {
      margin-bottom: var(--space-m);
    }

    .form-group label {
      display: block;
      font-size: 13px;
      font-weight: 600;
      color: var(--gray-70);
      margin-bottom: var(--space-xs);
    }

    .form-group input,
    .form-group select {
      width: 100%;
      padding: 12px 16px;
      border: 2px solid var(--gray-30);
      border-radius: var(--radius);
      font-size: 15px;
      transition: var(--transition);
      background: var(--gray-10);
      color: var(--gray-100);
      cursor: text;
    }

    .form-group select {
      cursor: pointer;
      appearance: none;
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23666' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
      background-repeat: no-repeat;
      background-position: right 12px center;
      padding-right: 36px;
    }

    .form-group input:focus,
    .form-group select:focus {
      outline: none;
      border-color: var(--primary);
      background: white;
      box-shadow: 0 0 0 4px rgba(var(--primary-rgb), 0.1);
    }

    body.dark .form-group input,
    body.dark .form-group select {
      background: var(--gray-30);
      border-color: var(--gray-40);
      color: var(--gray-100);
    }

    body.dark .form-group select {
      background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23999' d='M6 8L1 3h10z'/%3E%3C/svg%3E");
    }

    body.dark .form-group input:focus,
    body.dark .form-group select:focus {
      background: var(--gray-40);
    }

    .login-button {
      width: 100%;
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: white;
      border: none;
      padding: 14px 28px;
      border-radius: var(--radius);
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      margin-top: var(--space-s);
      box-shadow: 0 4px 15px rgba(var(--primary-rgb), 0.3);
    }

    .login-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(var(--primary-rgb), 0.4);
    }

    .login-button:active {
      transform: translateY(0);
    }

    .login-divider {
      display: flex;
      align-items: center;
      margin: var(--space-l) 0;
      gap: var(--space-m);
    }

    .login-divider::before,
    .login-divider::after {
      content: "";
      flex: 1;
      height: 1px;
      background: var(--gray-30);
    }

    .login-divider span {
      font-size: 12px;
      color: var(--gray-50);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .login-actions {
      display: flex;
      gap: var(--space-s);
      margin-bottom: var(--space-l);
    }

    .login-action-btn {
      flex: 1;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-xs);
      padding: 10px 16px;
      border: 1px dashed var(--gray-40);
      border-radius: var(--radius);
      background: transparent;
      color: var(--gray-70);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
    }

    .login-action-btn:hover {
      border-color: var(--primary);
      color: var(--primary);
      background: rgba(var(--primary-rgb), 0.05);
    }

    .login-action-btn i {
      font-size: 14px;
    }

    .user-list {
      margin-top: 0;
    }

    .user-list-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--space-m);
    }

    .user-list-header h3 {
      font-size: 13px;
      color: var(--gray-60);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin: 0;
    }

    .user-list-header span {
      font-size: 12px;
      color: var(--gray-50);
    }

    .user-list h3 {
      font-size: 13px;
      color: var(--gray-60);
      margin-bottom: var(--space-m);
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    .user-item {
      display: flex;
      align-items: center;
      gap: var(--space-m);
      padding: var(--space-m);
      background: var(--gray-10);
      border-radius: var(--radius);
      margin-bottom: var(--space-s);
      cursor: pointer;
      transition: var(--transition);
      border: 1px solid transparent;
      position: relative;
    }

    body.dark .user-item {
      background: var(--gray-30);
    }

    .user-item:hover {
      background: var(--gray-20);
      border-color: var(--gray-30);
      transform: translateX(4px);
    }

    body.dark .user-item:hover {
      background: var(--gray-40);
    }

    .user-item-avatar {
      width: 44px;
      height: 44px;
      border-radius: 12px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 16px;
      flex-shrink: 0;
    }

    .user-item-info {
      flex: 1;
      min-width: 0;
    }

    .user-item-name {
      font-weight: 600;
      color: var(--gray-100);
      font-size: 14px;
      margin-bottom: 2px;
    }

    .user-item-meta {
      display: flex;
      align-items: center;
      gap: var(--space-m);
      font-size: 12px;
      color: var(--gray-50);
    }

    .user-item-meta span {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .user-item-meta i {
      font-size: 10px;
    }

    .user-item-actions {
      display: flex;
      gap: var(--space-xs);
      opacity: 0;
      transition: var(--transition);
    }

    .user-item:hover .user-item-actions {
      opacity: 1;
    }

    .user-item-action {
      width: 32px;
      height: 32px;
      border: none;
      border-radius: var(--radius-small);
      background: var(--gray-30);
      color: var(--gray-70);
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    body.dark .user-item-action {
      background: var(--gray-50);
    }

    .user-item-action:hover {
      background: var(--primary);
      color: white;
    }

    .user-item-action.delete:hover {
      background: var(--error);
    }

    .user-item-arrow {
      color: var(--gray-40);
      transition: var(--transition);
    }

    .user-item:hover .user-item-arrow {
      color: var(--primary);
      transform: translateX(3px);
    }

    .login-empty-state {
      text-align: center;
      padding: var(--space-l);
      color: var(--gray-50);
    }

    .login-empty-state i {
      font-size: 32px;
      margin-bottom: var(--space-s);
      opacity: 0.5;
    }

    .login-empty-state p {
      font-size: 13px;
      margin: 0;
    }

    .login-footer {
      text-align: center;
      margin-top: var(--space-l);
      padding-top: var(--space-m);
      border-top: 1px solid var(--gray-20);
    }

    .login-footer p {
      font-size: 12px;
      color: var(--gray-50);
      margin: 0;
    }

    .login-footer a {
      color: var(--primary);
      text-decoration: none;
    }

    .login-footer a:hover {
      text-decoration: underline;
    }

    /* RAPPID Preview Modal */
    .rappid-preview-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(4px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
      padding: var(--space-m);
    }

    .rappid-preview-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .rappid-preview-modal {
      background: white;
      border-radius: 16px;
      width: 100%;
      max-width: 520px;
      max-height: 85vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.4);
      transform: scale(0.95) translateY(10px);
      transition: transform 0.3s ease;
    }

    .rappid-preview-overlay.active .rappid-preview-modal {
      transform: scale(1) translateY(0);
    }

    body.dark .rappid-preview-modal {
      background: var(--gray-20);
    }

    .rappid-preview-header {
      padding: var(--space-l);
      border-bottom: 1px solid var(--gray-20);
      display: flex;
      align-items: center;
      gap: var(--space-m);
    }

    body.dark .rappid-preview-header {
      border-color: var(--gray-40);
    }

    .rappid-preview-icon {
      width: 48px;
      height: 48px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      border-radius: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 20px;
    }

    .rappid-preview-title h2 {
      font-size: 18px;
      font-weight: 600;
      color: var(--gray-100);
      margin: 0 0 4px 0;
    }

    .rappid-preview-title p {
      font-size: 13px;
      color: var(--gray-60);
      margin: 0;
    }

    .rappid-preview-body {
      flex: 1;
      overflow-y: auto;
      padding: var(--space-l);
    }

    .rappid-preview-section {
      margin-bottom: var(--space-l);
    }

    .rappid-preview-section:last-child {
      margin-bottom: 0;
    }

    .rappid-preview-section-header {
      display: flex;
      align-items: center;
      gap: var(--space-s);
      margin-bottom: var(--space-m);
    }

    .rappid-preview-section-header i {
      width: 28px;
      height: 28px;
      background: var(--gray-10);
      border-radius: 8px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: var(--primary);
      font-size: 12px;
    }

    body.dark .rappid-preview-section-header i {
      background: var(--gray-40);
    }

    .rappid-preview-section-header h3 {
      font-size: 14px;
      font-weight: 600;
      color: var(--gray-80);
      margin: 0;
    }

    .rappid-preview-section-header span {
      margin-left: auto;
      font-size: 12px;
      color: var(--gray-50);
      background: var(--gray-20);
      padding: 2px 8px;
      border-radius: 10px;
    }

    body.dark .rappid-preview-section-header span {
      background: var(--gray-40);
    }

    .rappid-endpoint-item {
      display: flex;
      align-items: center;
      gap: var(--space-m);
      padding: var(--space-m);
      background: var(--gray-10);
      border-radius: var(--radius);
      margin-bottom: var(--space-s);
      border: 1px solid transparent;
    }

    body.dark .rappid-endpoint-item {
      background: var(--gray-30);
    }

    .rappid-endpoint-item.active {
      border-color: var(--success);
      background: rgba(76, 175, 80, 0.08);
    }

    .rappid-endpoint-avatar {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-weight: 600;
      font-size: 14px;
      flex-shrink: 0;
    }

    .rappid-endpoint-avatar.local {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    }

    .rappid-endpoint-avatar.production {
      background: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
    }

    .rappid-endpoint-info {
      flex: 1;
      min-width: 0;
    }

    .rappid-endpoint-name {
      display: flex;
      align-items: center;
      gap: var(--space-s);
      font-weight: 600;
      font-size: 14px;
      color: var(--gray-100);
      margin-bottom: 2px;
    }

    .rappid-endpoint-name .active-badge {
      font-size: 10px;
      font-weight: 600;
      color: var(--success);
      background: rgba(76, 175, 80, 0.15);
      padding: 2px 6px;
      border-radius: 4px;
      text-transform: uppercase;
    }

    .rappid-endpoint-url {
      font-size: 12px;
      color: var(--gray-50);
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .rappid-setting-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-s) var(--space-m);
      background: var(--gray-10);
      border-radius: var(--radius-small);
      margin-bottom: var(--space-xs);
    }

    body.dark .rappid-setting-item {
      background: var(--gray-30);
    }

    .rappid-setting-item label {
      font-size: 13px;
      color: var(--gray-70);
    }

    .rappid-setting-item span {
      font-size: 13px;
      color: var(--gray-100);
      font-weight: 500;
    }

    .rappid-setting-item .masked {
      font-family: monospace;
      color: var(--gray-50);
    }

    .rappid-preview-footer {
      padding: var(--space-l);
      border-top: 1px solid var(--gray-20);
      display: flex;
      gap: var(--space-m);
    }

    body.dark .rappid-preview-footer {
      border-color: var(--gray-40);
    }

    .rappid-preview-footer button {
      flex: 1;
      padding: 12px 20px;
      border-radius: var(--radius);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-s);
    }

    .rappid-preview-cancel {
      background: var(--gray-20);
      border: none;
      color: var(--gray-80);
    }

    body.dark .rappid-preview-cancel {
      background: var(--gray-40);
    }

    .rappid-preview-cancel:hover {
      background: var(--gray-30);
    }

    .rappid-preview-import {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      border: none;
      color: white;
      box-shadow: 0 4px 12px rgba(var(--primary-rgb), 0.3);
    }

    .rappid-preview-import:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 16px rgba(var(--primary-rgb), 0.4);
    }

    .rappid-preview-meta {
      font-size: 11px;
      color: var(--gray-50);
      text-align: center;
      margin-top: var(--space-s);
    }

    /* Main App Container */
    .app-container {
      display: flex;
      flex-direction: column;
      height: 100vh;
      background: var(--gray-10);
      overflow: hidden;
    }

    /* Header - Flattened, reduced visual weight (Strategies 1,4,8) */
    .header {
      background: var(--primary);
      color: white;
      padding: 0 var(--space-l);
      padding-top: var(--safe-area-top);
      height: calc(var(--header-height) + var(--safe-area-top));
      display: flex;
      align-items: center;
      justify-content: space-between;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 4px 12px rgba(0, 0, 0, 0.08);
      z-index: 100;
      flex-shrink: 0;
      position: relative;
    }

    .header::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: rgba(255,255,255,0.1);
    }

    body.dark .header {
      background: var(--gray-20);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3), 0 4px 12px rgba(0, 0, 0, 0.2);
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: var(--space-m);
    }

    .header-title {
      font-size: 18px;
      font-weight: 600;
      display: flex;
      align-items: center;
      letter-spacing: -0.2px;
    }

    .header-actions {
      display: flex;
      align-items: center;
      gap: var(--space-xs);
    }

    /* Header buttons - 48px touch targets (Cycle 15 Mobile Enhancement) */
    .header-button {
      background: rgba(255, 255, 255, 0.12);
      border: none;
      color: white;
      width: 48px;
      height: 48px;
      border-radius: var(--radius);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
      font-size: 16px;
      -webkit-tap-highlight-color: transparent;
    }

    .header-button:hover {
      background: rgba(255, 255, 255, 0.2);
    }

    .header-button:active {
      transform: scale(0.95);
      background: rgba(255, 255, 255, 0.25);
    }

    body.dark .header-button {
      background: rgba(255, 255, 255, 0.1);
      /* Cycle 23: Enhanced icon contrast in dark mode */
      color: var(--gray-100);
    }

    body.dark .header-button:hover {
      background: rgba(255, 255, 255, 0.2);
      color: var(--primary-light);
    }

    body.dark .header-button i {
      color: inherit;
    }

    #menu-toggle-header {
      background: rgba(255, 255, 255, 0.1);
      color: white;
    }

    .header-button:hover {
      background: var(--gray-20);
      color: var(--primary);
    }

    /* Voice indicator in header */
    .voice-indicator {
      display: none;
      align-items: center;
      gap: var(--space-s);
      padding: 6px 12px;
      background: var(--primary);
      color: white;
      border-radius: var(--radius-full);
      font-size: 13px;
      font-weight: 500;
      animation: fadeIn 0.3s ease-out;
    }

    .voice-indicator.active {
      display: flex;
    }

    .voice-indicator i {
      font-size: 14px;
      animation: pulse 1.5s infinite;
    }

    /* Sidebar */
    .sidebar {
      position: fixed;
      left: 0;
      top: 0;
      bottom: 0;
      width: 85%;
      max-width: 340px;
      background: white;
      box-shadow: var(--shadow-large);
      transform: translateX(-100%);
      transition: transform 0.3s ease;
      z-index: 200;
      overflow-y: auto;
    }

    body.dark .sidebar {
      background: var(--gray-20);
    }

    .sidebar.open {
      transform: translateX(0);
    }

    .sidebar-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.5);
      opacity: 0;
      visibility: hidden;
      transition: var(--transition);
      z-index: 190;
    }

    .sidebar-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .sidebar-header {
      padding: var(--space-l);
      padding-top: calc(var(--space-l) + var(--safe-area-top));
      border-bottom: 1px solid var(--gray-30);
      display: flex;
      align-items: center;
      justify-content: space-between;
      background: var(--primary);
      color: white;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    .sidebar-header h2 {
      font-size: 20px;
      font-weight: 600;
    }

    .sidebar-tabs {
      display: flex;
      background: var(--gray-10);
      position: sticky;
      top: calc(80px + var(--safe-area-top));
      z-index: 9;
    }

    body.dark .sidebar-tabs {
      background: var(--gray-30);
    }

    .sidebar-tab {
      flex: 1;
      padding: var(--space-m);
      background: none;
      border: none;
      color: var(--gray-60);
      cursor: pointer;
      transition: var(--transition);
      border-bottom: 3px solid transparent;
      font-size: 15px;
      font-weight: 500;
    }

    .sidebar-tab:hover {
      color: var(--gray-100);
    }

    .sidebar-tab.active {
      color: var(--primary);
      border-bottom-color: var(--primary);
    }

    .chat-list {
      padding: var(--space-m);
      min-height: 300px;
    }

    .chat-list-empty {
      padding: var(--space-xl);
      text-align: center;
      color: var(--gray-60);
    }

    .chat-item {
      padding: var(--space-m);
      border-radius: var(--radius);
      margin-bottom: var(--space-s);
      cursor: pointer;
      transition: var(--transition);
      position: relative;
      background: var(--gray-10);
    }

    body.dark .chat-item {
      background: var(--gray-30);
    }

    .chat-item:hover {
      background: var(--gray-20);
      transform: translateX(4px);
    }

    body.dark .chat-item:hover {
      background: var(--gray-40);
    }

    .chat-item.active {
      background: rgba(var(--primary-rgb), 0.08);
      border-left: 3px solid var(--primary);
      transform: scale(1.02);
      box-shadow: 0 2px 8px rgba(var(--primary-rgb), 0.15);
    }

    .chat-item-title {
      font-weight: 600;
      color: var(--gray-100);
      margin-bottom: var(--space-xs);
      padding-right: 60px;
    }

    .chat-item-preview {
      font-size: 14px;
      color: var(--gray-60);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .chat-item-date {
      font-size: 12px;
      color: var(--gray-60);
      margin-top: var(--space-xs);
    }

    .chat-item-actions {
      position: absolute;
      top: var(--space-m);
      right: var(--space-m);
      display: flex;
      gap: var(--space-xs);
      opacity: 0;
      transition: var(--transition);
    }

    .chat-item:hover .chat-item-actions {
      opacity: 1;
    }

    .chat-item-action {
      background: var(--gray-30);
      border: none;
      color: var(--gray-80);
      width: 32px;
      height: 32px;
      border-radius: var(--radius-small);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: var(--transition);
    }

    .chat-item-action:hover {
      background: var(--primary);
      color: white;
    }

    /* Chat Container - Clean, neutral background (Strategy 8) */
    .chat-container {
      flex: 1;
      display: flex;
      flex-direction: column;
      overflow: hidden;
      background: var(--gray-10);
      position: relative;
    }

    body.dark .chat-container {
      background: var(--gray-10);
    }

    .chat-messages-wrapper {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      position: relative;
      z-index: 1;
    }

    .chat-messages {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      /* Increased horizontal padding - right side accounts for FAB buttons (48px + 12px + buffer) */
      padding: var(--space-xl) 80px var(--space-xl) var(--space-xl);
      padding-bottom: calc(var(--input-container-height) + var(--safe-area-bottom) + var(--space-l));
      scroll-behavior: smooth;
      /* Center conversation content */
      display: flex;
      flex-direction: column;
      /* Cycle 17: GPU acceleration hints */
      will-change: scroll-position;
      contain: layout style;
      /* Cycle 19: Scroll-snap for native-like positioning */
      scroll-snap-type: y proximity;
    }

    /* Larger screens get more breathing room */
    @media (min-width: 768px) {
      .chat-messages {
        padding-left: var(--space-xxl);
        padding-right: 88px; /* FAB width + gap + extra buffer */
      }
    }

    /* Centered conversation container for better readability */
    .chat-messages > * {
      width: 100%;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
    }

    /* Welcome Empty State */
    .welcome-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100%;
      padding: var(--space-xxl) var(--space-xl);
      text-align: center;
      animation: welcomeFadeIn 0.6s cubic-bezier(0.16, 1, 0.3, 1);
    }

    @keyframes welcomeFadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .welcome-logo {
      width: 88px;
      height: 88px;
      border-radius: var(--radius-full);
      background: linear-gradient(135deg, var(--primary), var(--primary-dark));
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: var(--space-l);
      box-shadow: 0 8px 32px rgba(var(--primary-rgb), 0.4);
      position: relative;
    }

    .welcome-logo::before {
      content: '';
      position: absolute;
      inset: -4px;
      border-radius: var(--radius-full);
      background: linear-gradient(135deg, var(--primary-light), var(--primary), var(--primary-dark));
      z-index: -1;
      opacity: 0.5;
      filter: blur(8px);
    }

    .welcome-logo i {
      font-size: 38px;
      color: white;
      text-shadow: 0 2px 4px rgba(0,0,0,0.2);
    }

    .welcome-title {
      font-size: 32px;
      font-weight: 800;
      color: var(--gray-100);
      margin-bottom: var(--space-s);
      letter-spacing: -0.5px;
    }

    .welcome-subtitle {
      font-size: 16px;
      color: var(--gray-60);
      margin-bottom: var(--space-xxl);
      max-width: 420px;
      line-height: 1.6;
    }

    .welcome-prompts-title {
      font-size: 12px;
      font-weight: 700;
      color: var(--primary);
      margin-bottom: var(--space-l);
      text-transform: uppercase;
      letter-spacing: 1px;
      display: flex;
      align-items: center;
      gap: var(--space-m);
    }

    .welcome-prompts-title::before,
    .welcome-prompts-title::after {
      content: '';
      height: 1px;
      width: 40px;
      background: linear-gradient(90deg, transparent, var(--gray-40));
    }

    .welcome-prompts-title::after {
      background: linear-gradient(90deg, var(--gray-40), transparent);
    }

    .welcome-prompts {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: var(--space-m);
      width: 100%;
      max-width: 900px;
    }

    .welcome-prompt {
      background: var(--gray-20);
      border: 1px solid var(--gray-30);
      border-radius: var(--radius);
      padding: var(--space-m);
      cursor: pointer;
      transition: var(--transition);
      text-align: left;
      display: flex;
      align-items: flex-start;
      gap: var(--space-m);
      /* Cycle 3: Staggered entry animation */
      animation: promptStaggerIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) both;
      animation-delay: calc(var(--prompt-index, 0) * 0.06s);
    }

    @keyframes promptStaggerIn {
      from {
        opacity: 0;
        transform: translateY(16px) scale(0.95);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .welcome-prompt:hover {
      background: rgba(var(--primary-rgb), 0.08);
      border-color: var(--primary);
      transform: translateY(-2px);
      box-shadow: var(--shadow-medium);
    }

    .welcome-prompt-icon {
      width: 36px;
      height: 36px;
      border-radius: var(--radius);
      background: rgba(var(--primary-rgb), 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .welcome-prompt-icon i {
      font-size: 16px;
      color: var(--primary);
    }

    .welcome-prompt-content {
      flex: 1;
      min-width: 0;
    }

    .welcome-prompt-label {
      font-size: 12px;
      font-weight: 600;
      color: var(--primary);
      margin-bottom: 4px;
      text-transform: uppercase;
      letter-spacing: 0.3px;
    }

    .welcome-prompt-text {
      font-size: 14px;
      color: var(--gray-100);
      line-height: 1.4;
    }

    body.dark .welcome-prompt {
      background: var(--gray-30);
      border-color: var(--gray-40);
    }

    body.dark .welcome-prompt:hover {
      background: rgba(var(--primary-rgb), 0.15);
    }

    @media (max-width: 600px) {
      .welcome-prompts {
        grid-template-columns: 1fr;
      }

      .welcome-title {
        font-size: 24px;
      }

      .welcome-logo {
        width: 64px;
        height: 64px;
      }

      .welcome-logo i {
        font-size: 28px;
      }
    }

    /* ========================================
       PROMPT LIBRARY - Power Prompts Modal
       ======================================== */
    .prompt-library-btn {
      position: fixed;
      bottom: calc(var(--input-container-height) + var(--safe-area-bottom) + 160px);
      right: 20px;
      width: 52px;
      height: 52px;
      border-radius: var(--radius-full);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border: none;
      color: white;
      font-size: 18px;
      cursor: pointer;
      box-shadow: 0 4px 20px rgba(102, 126, 234, 0.4);
      transition: all 0.3s ease;
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .prompt-library-btn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 8px 30px rgba(102, 126, 234, 0.5);
    }

    .prompt-library-btn::before {
      content: '';
      position: absolute;
      inset: -3px;
      border-radius: var(--radius-full);
      background: linear-gradient(135deg, #667eea, #764ba2, #f093fb, #667eea);
      background-size: 300% 300%;
      animation: shimmer 3s ease infinite;
      z-index: -1;
      opacity: 0;
      transition: opacity 0.3s;
    }

    .prompt-library-btn:hover::before {
      opacity: 1;
    }

    @keyframes shimmer {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .prompt-library-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      z-index: 1000;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .prompt-library-modal.active {
      opacity: 1;
      visibility: visible;
    }

    .prompt-library-container {
      width: 95%;
      max-width: 1200px;
      max-height: 90vh;
      background: var(--gray-10);
      border-radius: var(--radius-large);
      box-shadow: var(--shadow-large);
      display: flex;
      flex-direction: column;
      transform: scale(0.9) translateY(20px);
      transition: transform 0.3s ease;
      overflow: hidden;
    }

    .prompt-library-modal.active .prompt-library-container {
      transform: scale(1) translateY(0);
    }

    .prompt-library-header {
      padding: var(--space-l) var(--space-xl);
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .prompt-library-title {
      display: flex;
      align-items: center;
      gap: var(--space-m);
    }

    .prompt-library-title h2 {
      font-size: 24px;
      font-weight: 700;
      margin: 0;
    }

    .prompt-library-title i {
      font-size: 28px;
    }

    .prompt-library-subtitle {
      opacity: 0.9;
      font-size: 14px;
      margin-top: 4px;
    }

    .prompt-library-close {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      width: 40px;
      height: 40px;
      border-radius: var(--radius-full);
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }

    .prompt-library-close:hover {
      background: rgba(255, 255, 255, 0.3);
      transform: rotate(90deg);
    }

    .prompt-library-filters {
      padding: var(--space-m) var(--space-xl);
      background: var(--gray-20);
      border-bottom: 1px solid var(--gray-30);
      display: flex;
      gap: var(--space-s);
      flex-wrap: wrap;
    }

    .prompt-filter-btn {
      padding: 8px 16px;
      border-radius: var(--radius-full);
      border: 1px solid var(--gray-40);
      background: var(--gray-10);
      color: var(--gray-80);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: var(--transition);
    }

    .prompt-filter-btn:hover {
      border-color: var(--primary);
      color: var(--primary);
    }

    .prompt-filter-btn.active {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    .prompt-library-content {
      flex: 1;
      overflow-y: auto;
      padding: var(--space-xl);
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
      gap: var(--space-l);
    }

    .prompt-card {
      background: var(--gray-20);
      border: 2px solid var(--gray-30);
      border-radius: var(--radius);
      padding: var(--space-l);
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .prompt-card::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: linear-gradient(90deg, var(--card-gradient-start, #667eea), var(--card-gradient-end, #764ba2));
      transform: scaleX(0);
      transform-origin: left;
      transition: transform 0.3s ease;
    }

    .prompt-card:hover {
      border-color: var(--primary);
      transform: translateY(-4px);
      box-shadow: var(--shadow-large);
    }

    .prompt-card:hover::before {
      transform: scaleX(1);
    }

    .prompt-card-header {
      display: flex;
      align-items: flex-start;
      gap: var(--space-m);
      margin-bottom: var(--space-m);
    }

    .prompt-card-icon {
      width: 48px;
      height: 48px;
      border-radius: var(--radius);
      background: linear-gradient(135deg, var(--card-gradient-start, #667eea), var(--card-gradient-end, #764ba2));
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
    }

    .prompt-card-icon i {
      font-size: 20px;
      color: white;
    }

    .prompt-card-title {
      font-size: 16px;
      font-weight: 700;
      color: var(--gray-100);
      margin-bottom: 4px;
    }

    .prompt-card-category {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: var(--primary);
      opacity: 0.8;
    }

    .prompt-card-text {
      font-size: 14px;
      color: var(--gray-80);
      line-height: 1.5;
      margin-bottom: var(--space-m);
      display: -webkit-box;
      -webkit-line-clamp: 3;
      -webkit-box-orient: vertical;
      overflow: hidden;
    }

    .prompt-card-tags {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .prompt-tag {
      padding: 4px 10px;
      background: rgba(var(--primary-rgb), 0.1);
      border-radius: var(--radius-full);
      font-size: 11px;
      font-weight: 500;
      color: var(--primary);
    }

    .prompt-card-action {
      position: absolute;
      bottom: var(--space-m);
      right: var(--space-m);
      width: 36px;
      height: 36px;
      border-radius: var(--radius-full);
      background: var(--primary);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transform: scale(0.8);
      transition: all 0.3s ease;
    }

    .prompt-card:hover .prompt-card-action {
      opacity: 1;
      transform: scale(1);
    }

    /* ========================================
       GENERATIVE UI TEMPLATES
       ======================================== */
    .gen-ui-container {
      margin-top: var(--space-m);
      animation: fadeIn 0.5s ease;
    }

    /* Email List Template */
    .gen-ui-email-list {
      background: var(--gray-20);
      border-radius: var(--radius);
      overflow: hidden;
    }

    .gen-ui-email-header {
      padding: var(--space-m);
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      display: flex;
      align-items: center;
      gap: var(--space-s);
      font-weight: 600;
    }

    .gen-ui-email-item {
      padding: var(--space-m);
      border-bottom: 1px solid var(--gray-30);
      display: flex;
      align-items: center;
      gap: var(--space-m);
      transition: var(--transition);
    }

    .gen-ui-email-item:hover {
      background: var(--gray-30);
    }

    .gen-ui-email-avatar {
      width: 40px;
      height: 40px;
      border-radius: var(--radius-full);
      background: var(--primary);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      flex-shrink: 0;
    }

    .gen-ui-email-content {
      flex: 1;
      min-width: 0;
    }

    .gen-ui-email-subject {
      font-weight: 600;
      color: var(--gray-100);
      margin-bottom: 2px;
    }

    .gen-ui-email-preview {
      font-size: 13px;
      color: var(--gray-60);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .gen-ui-email-priority {
      padding: 4px 10px;
      border-radius: var(--radius-full);
      font-size: 11px;
      font-weight: 600;
    }

    .gen-ui-email-priority.high { background: #fee2e2; color: #dc2626; }
    .gen-ui-email-priority.medium { background: #fef3c7; color: #d97706; }
    .gen-ui-email-priority.low { background: #d1fae5; color: #059669; }

    /* Cycle 25: Dark mode status badges */
    body.dark .gen-ui-email-priority.high { background: rgba(220, 38, 38, 0.2); color: #fca5a5; }
    body.dark .gen-ui-email-priority.medium { background: rgba(217, 119, 6, 0.2); color: #fcd34d; }
    body.dark .gen-ui-email-priority.low { background: rgba(5, 150, 105, 0.2); color: #6ee7b7; }

    /* Relationship Graph Template */
    .gen-ui-relationship-graph {
      background: var(--gray-20);
      border-radius: var(--radius);
      padding: var(--space-l);
    }

    .gen-ui-graph-header {
      display: flex;
      align-items: center;
      gap: var(--space-s);
      margin-bottom: var(--space-l);
      font-weight: 600;
      color: var(--gray-100);
    }

    .gen-ui-graph-header i {
      color: var(--primary);
    }

    .gen-ui-relationship-grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
      gap: var(--space-m);
    }

    .gen-ui-relationship-node {
      background: var(--gray-10);
      border: 2px solid var(--gray-30);
      border-radius: var(--radius);
      padding: var(--space-m);
      text-align: center;
      transition: var(--transition);
    }

    .gen-ui-relationship-node.thriving { border-color: #10b981; }
    .gen-ui-relationship-node.cooling { border-color: #f59e0b; }
    .gen-ui-relationship-node.at-risk { border-color: #ef4444; }

    .gen-ui-node-avatar {
      width: 56px;
      height: 56px;
      border-radius: var(--radius-full);
      background: var(--primary);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      font-weight: 600;
      margin: 0 auto var(--space-s);
    }

    .gen-ui-node-name {
      font-weight: 600;
      color: var(--gray-100);
      margin-bottom: 4px;
    }

    .gen-ui-node-role {
      font-size: 12px;
      color: var(--gray-60);
      margin-bottom: var(--space-s);
    }

    .gen-ui-node-status {
      display: inline-block;
      padding: 4px 12px;
      border-radius: var(--radius-full);
      font-size: 11px;
      font-weight: 600;
    }

    .gen-ui-node-status.thriving { background: #d1fae5; color: #059669; }
    .gen-ui-node-status.cooling { background: #fef3c7; color: #d97706; }
    .gen-ui-node-status.at-risk { background: #fee2e2; color: #dc2626; }

    /* Cycle 25: Dark mode node status badges */
    body.dark .gen-ui-node-status.thriving { background: rgba(5, 150, 105, 0.2); color: #6ee7b7; }
    body.dark .gen-ui-node-status.cooling { background: rgba(217, 119, 6, 0.2); color: #fcd34d; }
    body.dark .gen-ui-node-status.at-risk { background: rgba(220, 38, 38, 0.2); color: #fca5a5; }

    /* Dashboard Template */
    .gen-ui-dashboard {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: var(--space-m);
    }

    .gen-ui-dashboard-card {
      background: var(--gray-20);
      border-radius: var(--radius);
      padding: var(--space-l);
      border-left: 4px solid var(--primary);
    }

    .gen-ui-dashboard-label {
      font-size: 12px;
      color: var(--gray-60);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: var(--space-s);
    }

    .gen-ui-dashboard-value {
      font-size: 32px;
      font-weight: 700;
      color: var(--gray-100);
      margin-bottom: var(--space-s);
    }

    .gen-ui-dashboard-trend {
      font-size: 13px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .gen-ui-dashboard-trend.up { color: #10b981; }
    .gen-ui-dashboard-trend.down { color: #ef4444; }

    /* Timeline Template */
    .gen-ui-timeline {
      background: var(--gray-20);
      border-radius: var(--radius);
      padding: var(--space-l);
    }

    .gen-ui-timeline-header {
      display: flex;
      align-items: center;
      gap: var(--space-s);
      margin-bottom: var(--space-l);
      font-weight: 600;
      color: var(--gray-100);
    }

    .gen-ui-timeline-item {
      display: flex;
      gap: var(--space-m);
      padding-bottom: var(--space-l);
      position: relative;
    }

    .gen-ui-timeline-item::before {
      content: '';
      position: absolute;
      left: 15px;
      top: 32px;
      bottom: 0;
      width: 2px;
      background: var(--gray-40);
    }

    .gen-ui-timeline-item:last-child::before {
      display: none;
    }

    .gen-ui-timeline-dot {
      width: 32px;
      height: 32px;
      border-radius: var(--radius-full);
      background: var(--primary);
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      z-index: 1;
    }

    .gen-ui-timeline-dot i {
      color: white;
      font-size: 14px;
    }

    .gen-ui-timeline-content {
      flex: 1;
      background: var(--gray-10);
      border-radius: var(--radius);
      padding: var(--space-m);
    }

    .gen-ui-timeline-title {
      font-weight: 600;
      color: var(--gray-100);
      margin-bottom: 4px;
    }

    .gen-ui-timeline-desc {
      font-size: 13px;
      color: var(--gray-60);
    }

    .gen-ui-timeline-time {
      font-size: 11px;
      color: var(--gray-50);
      margin-top: var(--space-s);
    }

    /* Narrative Template */
    .gen-ui-narrative {
      background: linear-gradient(135deg, var(--gray-20), var(--gray-30));
      border-radius: var(--radius);
      padding: var(--space-xl);
      position: relative;
      overflow: hidden;
    }

    .gen-ui-narrative::before {
      content: '"';
      position: absolute;
      top: -20px;
      left: 20px;
      font-size: 120px;
      color: var(--primary);
      opacity: 0.1;
      font-family: Georgia, serif;
    }

    .gen-ui-narrative-text {
      font-size: 18px;
      line-height: 1.8;
      color: var(--gray-100);
      font-style: italic;
      position: relative;
      z-index: 1;
    }

    .gen-ui-narrative-author {
      margin-top: var(--space-l);
      display: flex;
      align-items: center;
      gap: var(--space-m);
    }

    .gen-ui-narrative-avatar {
      width: 48px;
      height: 48px;
      border-radius: var(--radius-full);
      background: var(--primary);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
    }

    .gen-ui-narrative-name {
      font-weight: 600;
      color: var(--gray-100);
    }

    .gen-ui-narrative-role {
      font-size: 13px;
      color: var(--gray-60);
    }

    /* Comparison Template */
    .gen-ui-comparison {
      display: grid;
      grid-template-columns: 1fr auto 1fr;
      gap: var(--space-m);
      align-items: stretch;
    }

    .gen-ui-comparison-side {
      background: var(--gray-20);
      border-radius: var(--radius);
      padding: var(--space-l);
    }

    .gen-ui-comparison-side.left {
      border-top: 4px solid #ef4444;
    }

    .gen-ui-comparison-side.right {
      border-top: 4px solid #10b981;
    }

    .gen-ui-comparison-title {
      font-weight: 600;
      margin-bottom: var(--space-m);
      display: flex;
      align-items: center;
      gap: var(--space-s);
    }

    .gen-ui-comparison-vs {
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
      color: var(--gray-60);
      font-size: 18px;
    }

    .gen-ui-comparison-item {
      padding: var(--space-s) 0;
      border-bottom: 1px solid var(--gray-30);
      font-size: 14px;
      color: var(--gray-80);
    }

    @media (max-width: 768px) {
      .prompt-library-content {
        grid-template-columns: 1fr;
        padding: var(--space-m);
      }

      .prompt-library-header {
        padding: var(--space-m);
      }

      .prompt-library-title h2 {
        font-size: 18px;
      }

      .gen-ui-comparison {
        grid-template-columns: 1fr;
      }

      .gen-ui-comparison-vs {
        padding: var(--space-s) 0;
      }
    }

    body.dark .prompt-card {
      background: var(--gray-30);
      border-color: var(--gray-40);
    }

    body.dark .gen-ui-email-list,
    body.dark .gen-ui-relationship-graph,
    body.dark .gen-ui-dashboard-card,
    body.dark .gen-ui-timeline,
    body.dark .gen-ui-narrative,
    body.dark .gen-ui-comparison-side {
      background: var(--gray-30);
    }

    /* Messages - Enhanced animations (Cycle 1 - Strategy 2) */
    .message-wrapper {
      margin: clamp(16px, 3vw, 24px) 0;
      animation: messageSlideInBounce 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
      max-width: 85%;
      /* Cycle 17: GPU acceleration + layout containment */
      contain: content;
      will-change: transform, opacity;
      /* Cycle 19: Scroll-snap alignment */
      scroll-snap-align: start;
      scroll-margin-top: 16px;
    }

    /* First message gets extra top margin for breathing room */
    .message-wrapper:first-child {
      margin-top: clamp(24px, 5vw, 48px);
    }

    @keyframes messageSlideInBounce {
      from {
        opacity: 0;
        transform: translateY(12px) scale(0.97);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    /* Cycle 17: Staggered message animation delays for cascade effect */
    .message-wrapper:nth-child(1) { animation-delay: 0ms; }
    .message-wrapper:nth-child(2) { animation-delay: 50ms; }
    .message-wrapper:nth-child(3) { animation-delay: 100ms; }
    .message-wrapper:nth-child(4) { animation-delay: 150ms; }
    .message-wrapper:nth-child(5) { animation-delay: 200ms; }
    .message-wrapper:nth-child(n+6) { animation-delay: 250ms; }

    /* Hover micro-interaction for assistant messages */
    .message-wrapper.assistant .message-content {
      transition: box-shadow 0.2s ease, transform 0.2s ease;
    }

    .message-wrapper.assistant:hover .message-content {
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
      transform: translateY(-1px);
    }

    body.dark .message-wrapper.assistant:hover .message-content {
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.25);
    }

    .message-wrapper.user {
      margin-left: auto;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      position: relative;
    }

    /* Cycle 20: Send confirmation state */
    .message-wrapper.user.sending::after {
      content: '';
      position: absolute;
      bottom: -8px;
      right: 8px;
      font-size: 8px;
      color: var(--primary-light);
      animation: sendingPulse 0.8s ease-in-out infinite;
    }

    .message-wrapper.user.sent::after {
      content: '';
      position: absolute;
      bottom: -8px;
      right: 8px;
      font-size: 10px;
      color: var(--success);
      animation: sentCheckmark 0.3s ease-out;
    }

    @keyframes sendingPulse {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 1; }
    }

    @keyframes sentCheckmark {
      from { transform: scale(0); opacity: 0; }
      to { transform: scale(1); opacity: 1; }
    }

    .message-wrapper.assistant {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
    }

    .message-label {
      font-size: 11px;
      color: var(--gray-60);
      margin-bottom: 6px;
      font-weight: 600;
      padding: 0 var(--space-xs);
      display: flex;
      align-items: center;
      gap: 6px;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }

    /* Cycle 24: Message avatars */
    .message-avatar {
      width: 28px;
      height: 28px;
      border-radius: var(--radius-full);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 700;
      flex-shrink: 0;
    }

    .message-wrapper.user .message-avatar {
      background: linear-gradient(135deg, var(--primary) 0%, #5a1f5a 100%);
      color: white;
    }

    .message-wrapper.assistant .message-avatar {
      background: linear-gradient(135deg, var(--secondary) 0%, #0097a7 100%);
      color: white;
    }

    body.dark .message-wrapper.assistant .message-avatar {
      background: linear-gradient(135deg, var(--primary-light) 0%, #9c6db8 100%);
    }

    body.dark .message-label {
      color: var(--gray-60);
    }

    .message-label .endpoint-badge {
      text-transform: none;
      letter-spacing: normal;
      font-size: 9px;
      padding: 2px 6px;
      opacity: 0.7;
    }

    /* Cycle 23: Conversation timestamp dividers */
    .timestamp-divider {
      display: flex;
      align-items: center;
      justify-content: center;
      margin: var(--space-l) 0;
      gap: var(--space-m);
      width: 100%;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
    }

    .timestamp-divider::before,
    .timestamp-divider::after {
      content: '';
      flex: 1;
      height: 1px;
      background: var(--gray-30);
    }

    .timestamp-divider span {
      font-size: 11px;
      color: var(--gray-60);
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      padding: 4px 12px;
      background: var(--gray-10);
      border-radius: var(--radius-full);
    }

    body.dark .timestamp-divider::before,
    body.dark .timestamp-divider::after {
      background: var(--gray-50);
    }

    body.dark .timestamp-divider span {
      background: var(--gray-30);
      color: var(--gray-80);
    }

    .message-content {
      padding: 12px 16px;
      border-radius: 16px;
      word-wrap: break-word;
      overflow-wrap: break-word;
      font-size: 15px;
      line-height: 1.6;
      transition: all 0.15s ease;
      position: relative;
      /* Optimal Reading Width - Cycle 6 Feature */
      max-width: 680px;
      /* Enable text selection */
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
      cursor: text;
      /* Subpixel Text Rendering - Cycle 9 Feature */
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: optimizeLegibility;
    }

    .user .message-content {
      /* Cycle 19: Subtle gradient accent */
      background: linear-gradient(135deg, var(--primary) 0%, #5a1f5a 100%);
      color: white;
      border-bottom-right-radius: 4px;
      /* Cycle 18+20: Layered depth + inset tactile shadows */
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 6px 16px rgba(var(--primary-rgb), 0.15), inset 0 1px 0 rgba(255, 255, 255, 0.15);
    }

    .assistant .message-content {
      /* Cycle 19: Subtle gradient accent */
      background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
      color: var(--gray-100);
      border-bottom-left-radius: 4px;
      /* Cycle 18+20: Layered depth + inset tactile shadows */
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05), 0 6px 20px rgba(0, 0, 0, 0.06), inset 0 1px 0 rgba(255, 255, 255, 0.8);
      border: 1px solid var(--gray-20);
      border-left: 3px solid var(--primary); /* Cycle 14 Visual Accent */
    }

    body.dark .assistant .message-content {
      /* Cycle 19: Subtle dark gradient */
      background: linear-gradient(135deg, var(--gray-30) 0%, var(--gray-40) 100%);
      border-color: var(--gray-50);
      border-left-color: var(--primary-light); /* Cycle 14 Visual Accent */
      /* Cycle 7+20: Enhanced luminosity + inset tactile shadows */
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.25), 0 0 0 1px rgba(255, 255, 255, 0.1), inset 0 1px 0 rgba(255, 255, 255, 0.05);
    }

    /* Markdown content styling - Cycle 15 Progressive Line-Height */
    .message-content h1 {
      margin-top: var(--space-m);
      margin-bottom: var(--space-s);
      font-weight: 800;
      line-height: 1.2;
      font-size: 20px;
    }

    .message-content h2 {
      margin-top: var(--space-m);
      margin-bottom: var(--space-s);
      font-weight: 700;
      line-height: 1.25;
      font-size: 18px;
    }

    .message-content h3 {
      margin-top: var(--space-m);
      margin-bottom: var(--space-s);
      font-weight: 600;
      line-height: 1.3;
      font-size: 16px;
      color: var(--primary);
      display: flex;
      align-items: center;
      gap: var(--space-s);
    }

    body.dark .message-content h3 {
      color: var(--primary-light);
    }

    .message-content p {
      margin-bottom: var(--space-s);
    }

    .message-content p:last-child {
      margin-bottom: 0;
    }

    .message-content ul, .message-content ol {
      margin: var(--space-s) 0;
      padding-left: var(--space-l);
    }

    .message-content li {
      margin-bottom: 4px;
    }

    .message-content strong {
      font-weight: 600;
      color: var(--gray-130);
    }

    body.dark .message-content strong {
      color: white;
    }

    .message-content hr {
      border: none;
      height: 1px;
      background: var(--gray-30);
      margin: var(--space-m) 0;
    }

    body.dark .message-content hr {
      background: var(--gray-50);
    }

    /* Style links in user messages (white background) */
    .user .message-content a {
      color: white !important;
      text-decoration: underline;
      text-underline-offset: 2px;
    }

    .user .message-content a:hover {
      opacity: 0.85;
    }

    .assistant .message-content a {
      color: var(--primary);
      text-decoration: none;
      font-weight: 500;
      border-bottom: 1px solid transparent;
      transition: border-color 0.2s;
    }

    .assistant .message-content a:hover {
      border-bottom-color: var(--primary);
    }

    /* Cycle 24: Dark mode link contrast enhancement */
    body.dark .assistant .message-content a {
      color: #bb86fc;
      font-weight: 600;
      border-bottom: 1px solid rgba(187, 134, 252, 0.3);
    }

    body.dark .assistant .message-content a:hover {
      color: #d4b4ff;
      border-bottom-color: #d4b4ff;
    }

    body.dark .user .message-content a {
      color: #fff;
      text-shadow: 0 0 1px rgba(255, 255, 255, 0.3);
    }

    .system-message {
      background: linear-gradient(135deg, rgba(var(--primary-rgb), 0.05), rgba(var(--primary-rgb), 0.02));
      padding: var(--space-m);
      border-radius: var(--radius);
      margin: var(--space-l) auto;
      width: 90%;
      font-family: 'SF Mono', 'Fira Code', monospace;
      font-size: 12px;
      border: 1px solid rgba(var(--primary-rgb), 0.1);
      color: var(--gray-80);
      word-wrap: break-word;
      overflow-wrap: break-word;
      white-space: pre-wrap;
      /* Enable text selection */
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
      cursor: text;
    }

    body.dark .system-message {
      background: linear-gradient(135deg, rgba(var(--primary-rgb), 0.1), rgba(var(--primary-rgb), 0.05));
      color: var(--gray-100);
    }

    /* Voice message indicator - Clean, subtle */
    .voice-message {
      display: none;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
      padding: 8px 12px;
      background: transparent;
      border-radius: var(--radius);
      font-size: 12px;
      color: var(--gray-60);
      border: none;
    }

    .voice-message.active {
      display: inline-flex;
      animation: fadeIn 0.3s ease;
    }

    .voice-message i {
      font-size: 12px;
      color: var(--primary);
      flex-shrink: 0;
    }

    .voice-message span {
      font-style: italic;
      line-height: 1.4;
    }

    body.dark .voice-message {
      background: transparent;
      color: var(--gray-60);
    }

    .voice-message .replay-btn {
      margin-left: 8px;
      padding: 4px 8px;
      background: var(--primary);
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
      opacity: 0.9;
      transition: opacity 0.2s, transform 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .voice-message .replay-btn:hover {
      opacity: 1;
      transform: scale(1.05);
    }

    .voice-message .replay-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .voice-message .replay-btn i {
      font-size: 10px;
      color: white;
      opacity: 1;
    }

    /* User voice message replay styling */
    .user-voice-message {
      display: none;
      align-items: center;
      gap: 8px;
      margin-top: 8px;
      padding: 8px 12px;
      background: transparent;
      border-radius: var(--radius);
      font-size: 12px;
      color: rgba(255, 255, 255, 0.8);
      border: none;
      justify-content: flex-end;
    }

    .user-voice-message.active {
      display: inline-flex;
      animation: fadeIn 0.3s ease;
    }

    .user-voice-message i.fa-microphone {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.9);
      flex-shrink: 0;
    }

    .user-voice-message span {
      font-style: italic;
      line-height: 1.4;
      color: rgba(255, 255, 255, 0.8);
    }

    .user-voice-message .replay-btn {
      margin-left: 8px;
      padding: 4px 8px;
      background: rgba(255, 255, 255, 0.2);
      color: white;
      border: none;
      border-radius: 4px;
      font-size: 11px;
      cursor: pointer;
      opacity: 0.9;
      transition: opacity 0.2s, transform 0.2s, background 0.2s;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .user-voice-message .replay-btn:hover {
      opacity: 1;
      transform: scale(1.05);
      background: rgba(255, 255, 255, 0.3);
    }

    .user-voice-message .replay-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .user-voice-message .replay-btn i {
      font-size: 10px;
      color: white;
      opacity: 1;
    }

    body.dark .user-voice-message {
      color: rgba(255, 255, 255, 0.7);
    }

    body.dark .user-voice-message span {
      color: rgba(255, 255, 255, 0.7);
    }

    .message-content pre {
      background: var(--gray-20);
      padding: var(--space-m);
      border-radius: var(--radius);
      overflow-x: auto;
      margin: var(--space-s) 0;
      font-size: 13px;
      position: relative;
      /* Cycle 28: Code block left border accent */
      border-left: 3px solid var(--primary);
      /* Enable text selection */
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }

    body.dark .message-content pre {
      background: var(--gray-10);
    }

    /* Code block copy button - Cycle 1 Feature */
    .code-copy-btn {
      position: absolute;
      top: 8px;
      right: 8px;
      background: white;
      border: 1px solid var(--gray-30);
      color: var(--gray-60);
      width: 32px;
      height: 32px;
      border-radius: var(--radius);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      opacity: 0;
      transition: all 0.2s ease;
      font-size: 13px;
    }

    .message-content pre:hover .code-copy-btn {
      opacity: 1;
    }

    .code-copy-btn:hover {
      background: var(--gray-10);
      color: var(--primary);
      border-color: var(--primary);
    }

    .code-copy-btn.copied {
      background: var(--success);
      border-color: var(--success);
      color: white;
      /* Cycle 27: Enhanced copy celebration */
      animation: copyBounce 0.4s var(--ease-spring, cubic-bezier(0.34, 1.56, 0.64, 1));
    }

    .code-copy-btn.copied::after {
      content: '';
      position: absolute;
      inset: -4px;
      border-radius: calc(var(--radius) + 4px);
      background: rgba(76, 175, 80, 0.3);
      animation: copyRipple 0.4s ease-out forwards;
    }

    /* Cycle 27: Copy celebration bounce */
    @keyframes copyBounce {
      0% { transform: scale(1); }
      30% { transform: scale(1.2); }
      50% { transform: scale(0.9); }
      70% { transform: scale(1.1); }
      100% { transform: scale(1); }
    }

    @keyframes copyRipple {
      from { transform: scale(0.8); opacity: 1; }
      to { transform: scale(1.2); opacity: 0; }
    }

    /* Code Language Label - Cycle 5 Feature */
    .code-language-label {
      position: absolute;
      top: 8px;
      left: 8px;
      background: rgba(var(--primary-rgb), 0.85);
      color: white;
      padding: 3px 8px;
      border-radius: 4px;
      font-size: 10px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
      z-index: 5;
      opacity: 0.9;
      transition: opacity 0.2s ease;
    }

    .message-content pre:hover .code-language-label {
      opacity: 1;
    }

    body.dark .code-language-label {
      background: rgba(var(--primary-rgb), 0.7);
    }

    body.dark .code-copy-btn {
      background: var(--gray-30);
      border-color: var(--gray-40);
      color: var(--gray-60);
    }

    body.dark .code-copy-btn:hover {
      background: var(--gray-40);
      color: var(--primary-light);
    }

    .message-content code {
      background: rgba(var(--primary-rgb), 0.1);
      padding: 2px 6px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 13px;
      /* Enable text selection */
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
    }

    .user .message-content pre,
    .user .message-content code {
      background: rgba(255, 255, 255, 0.15);
    }

    /* Cycle 18: Dark mode inline code contrast enhancement */
    body.dark .assistant .message-content code {
      background: var(--gray-50);
      color: var(--gray-130);
    }

    /* Loading Animation - Simplified, consistent styling */
    .loading {
      display: none !important;
      margin: var(--space-m) 0;
      margin-right: auto;
      max-width: 80px;
      background: white;
      padding: 12px 20px;
      border-radius: 16px;
      border-bottom-left-radius: 4px;
      border: 1px solid var(--gray-20);
    }

    body.dark .loading {
      background: var(--gray-30);
      border-color: var(--gray-40);
    }

    .loading.active {
      display: flex !important;
      align-items: center;
      justify-content: center;
      gap: 5px;
      animation: messageSlideIn 0.3s cubic-bezier(0.22, 1, 0.36, 1);
    }

    /* Cycle 19: Loading fade-through transition */
    .loading.fade-out {
      animation: loadingFadeOut 0.25s ease-out forwards;
    }

    @keyframes loadingFadeOut {
      from { opacity: 1; transform: scale(1); }
      to { opacity: 0; transform: scale(0.95); }
    }

    .loading span {
      width: 8px;
      height: 8px;
      background: var(--primary);
      border-radius: 50%;
      display: inline-block;
      animation: loadingPulse 1s ease-in-out infinite;
    }

    body.dark .loading span {
      background: var(--primary-light);
    }

    .loading span:nth-child(2) {
      animation-delay: 0.15s;
    }

    .loading span:nth-child(3) {
      animation-delay: 0.3s;
    }

    /* Color-Cycling Loading Animation - Cycle 14 Delight */
    @keyframes loadingPulse {
      0%, 100% {
        transform: scale(0.7);
        opacity: 0.4;
        background: var(--primary);
      }
      33% {
        transform: scale(1);
        opacity: 1;
        background: var(--primary-light);
      }
      66% {
        transform: scale(0.85);
        opacity: 0.8;
        background: var(--secondary);
      }
    }

    /* Ensure only one loading indicator at a time */
    .chat-messages .loading+.loading {
      display: none !important;
    }

    /* Input Container - Elevated design (Cycle 1 - Strategy 2) + Cycle 16 Border */
    .input-container {
      background: white;
      border-top: 1px solid var(--gray-20);
      padding: var(--space-m) var(--space-l);
      padding-bottom: calc(var(--space-m) + var(--safe-area-bottom));
      display: flex;
      gap: var(--space-s);
      align-items: flex-end;
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      z-index: 50;
      min-height: var(--input-container-height);
      box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.06), 0 -1px 3px rgba(0, 0, 0, 0.04);
    }

    body.dark .input-container {
      background: var(--gray-20);
      border-top-color: var(--gray-40);
      box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.3), 0 -1px 3px rgba(0, 0, 0, 0.2);
    }

    .input-wrapper {
      flex: 1;
      position: relative;
    }

    .input-field {
      width: 100%;
      padding: 12px 16px;
      border: 1px solid var(--gray-30);
      border-radius: 20px;
      font-size: 15px;
      resize: none;
      outline: none;
      transition: border-color 0.15s ease, box-shadow 0.15s ease;
      background: var(--gray-10);
      min-height: 48px;
      max-height: 120px;
      font-family: inherit;
      line-height: 1.4;
    }

    body.dark .input-field {
      background: var(--gray-30);
      color: var(--gray-100);
      border-color: var(--gray-40);
    }

    .input-field::placeholder {
      color: var(--gray-50);
    }

    /* Dark mode placeholder contrast - Cycle 8 Feature */
    /* Cycle 26: Enhanced contrast for WCAG AA compliance */
    body.dark .input-field::placeholder {
      color: var(--gray-70);
      opacity: 0.8;
    }

    .input-field:focus {
      border-color: var(--primary);
      background: white;
      box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.1);
      /* Cycle 30: Optimized from 2.5s to 1.2s for snappier feedback */
      animation: inputBreathe 1.2s ease-in-out infinite;
    }

    /* Cycle 4: Input breathing effect */
    @keyframes inputBreathe {
      0%, 100% {
        box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.1);
      }
      50% {
        box-shadow: 0 0 0 5px rgba(var(--primary-rgb), 0.18);
      }
    }

    body.dark .input-field:focus {
      background: var(--gray-40);
      box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.3);
      /* Cycle 30: Optimized from 2.5s to 1.2s */
      animation: inputBreatheDark 1.2s ease-in-out infinite;
    }

    /* Cycle 25: Enhanced dark mode focus ring visibility */
    @keyframes inputBreatheDark {
      0%, 100% {
        box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.3);
      }
      50% {
        box-shadow: 0 0 0 6px rgba(var(--primary-rgb), 0.45);
      }
    }

    /* Cycle 24: Character count warning state */
    /* Cycle 29: Unified animation timing at 0.8s */
    .input-field.char-warning {
      border-color: var(--warning) !important;
      animation: charWarningPulse 0.8s ease-in-out infinite !important;
    }

    .input-field.char-limit {
      border-color: var(--error) !important;
      animation: charLimitPulse 0.8s ease-in-out infinite !important;
    }

    @keyframes charWarningPulse {
      0%, 100% { box-shadow: 0 0 0 3px rgba(255, 152, 0, 0.15); }
      50% { box-shadow: 0 0 0 5px rgba(255, 152, 0, 0.25); }
    }

    @keyframes charLimitPulse {
      0%, 100% { box-shadow: 0 0 0 3px rgba(244, 67, 54, 0.2); }
      50% { box-shadow: 0 0 0 5px rgba(244, 67, 54, 0.35); }
    }

    /* Input buttons - 48px touch targets with micro-interactions */
    .input-button {
      background: var(--primary);
      color: white;
      border: none;
      width: 48px;
      height: 48px;
      border-radius: var(--radius-full);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1), background 0.15s ease;
      font-size: 18px;
      -webkit-tap-highlight-color: transparent;
    }

    .input-button:hover {
      transform: scale(1.05);
      background: var(--primary-dark);
    }

    .input-button:active {
      transform: scale(0.95);
    }

    /* Cycle 22: Button ripple effect */
    .input-button {
      position: relative;
      overflow: hidden;
    }

    .input-button::after {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      top: 0;
      left: 0;
      background: radial-gradient(circle, rgba(255,255,255,0.3) 0%, transparent 70%);
      transform: scale(0);
      opacity: 0;
      pointer-events: none;
    }

    .input-button:active::after {
      animation: buttonRipple 0.4s ease-out;
    }

    @keyframes buttonRipple {
      0% { transform: scale(0); opacity: 1; }
      100% { transform: scale(2.5); opacity: 0; }
    }

    .input-button:disabled {
      opacity: 0.4;
      cursor: not-allowed;
      transform: none;
    }

    /* Cycle 21: Dark mode disabled button contrast */
    body.dark .input-button:disabled {
      opacity: 0.5;
      background: var(--gray-50);
      color: var(--gray-80);
    }

    /* Processing Wait Cursor - Cycle 9 Feature */
    body.processing,
    body.processing * {
      cursor: wait !important;
    }

    body.processing button:disabled {
      cursor: not-allowed !important;
    }

    .input-button.secondary {
      background: var(--gray-20);
      color: var(--gray-70);
    }

    .input-button.secondary:hover {
      background: var(--gray-30);
    }

    body.dark .input-button.secondary {
      background: var(--gray-40);
      color: var(--gray-100);
    }

    body.dark .input-button.secondary:hover {
      background: var(--gray-50);
    }

    /* Send Button Celebration - Cycle 5 Feature */
    #send-button.celebrating {
      animation: sendCelebration 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    @keyframes sendCelebration {
      0% { transform: scale(1); }
      15% { transform: scale(0.85) rotate(-5deg); }
      35% { transform: scale(1.15) rotate(5deg); }
      50% { transform: scale(1.05) rotate(-2deg); }
      70% { transform: scale(1.08) rotate(1deg); }
      100% { transform: scale(1) rotate(0deg); }
    }

    #send-button.celebrating::after {
      content: '';
      position: absolute;
      inset: -6px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(var(--primary-rgb), 0.4) 0%, transparent 70%);
      animation: sendRipple 0.6s ease-out forwards;
      pointer-events: none;
    }

    @keyframes sendRipple {
      0% { transform: scale(0.5); opacity: 1; }
      100% { transform: scale(2); opacity: 0; }
    }

    /* Voice button */
    .voice-button {
      background: linear-gradient(135deg, var(--accent), #e91e63);
      color: white;
      box-shadow: 0 4px 12px rgba(255, 64, 129, 0.3);
    }

    .voice-button:hover {
      box-shadow: 0 6px 20px rgba(255, 64, 129, 0.4);
    }

    .voice-button:hover {
      background: var(--accent);
      transform: scale(1.1);
    }

    .voice-button.active {
      background: var(--error);
      animation: pulse 1.5s infinite;
    }

    /* Continuous Listening Mode */
    .voice-button.continuous-listening {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      box-shadow: 0 0 0 4px rgba(16, 185, 129, 0.3), 0 4px 12px rgba(16, 185, 129, 0.4);
      animation: continuousListeningPulse 2s ease-in-out infinite;
    }

    .voice-button.continuous-listening.processing {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      box-shadow: 0 0 0 4px rgba(245, 158, 11, 0.3), 0 4px 12px rgba(245, 158, 11, 0.4);
      animation: none;
    }

    .voice-button.continuous-listening.speaking {
      background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
      box-shadow: 0 0 0 4px rgba(139, 92, 246, 0.3), 0 4px 12px rgba(139, 92, 246, 0.4);
      animation: speakingPulse 0.8s ease-in-out infinite;
    }

    @keyframes continuousListeningPulse {
      0%, 100% {
        box-shadow: 0 0 0 4px rgba(16, 185, 129, 0.3), 0 4px 12px rgba(16, 185, 129, 0.4);
        transform: scale(1);
      }
      50% {
        box-shadow: 0 0 0 8px rgba(16, 185, 129, 0.15), 0 6px 20px rgba(16, 185, 129, 0.5);
        transform: scale(1.05);
      }
    }

    @keyframes speakingPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.08); }
    }

    /* Continuous listening status indicator */
    .continuous-listening-indicator {
      position: fixed;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      padding: 10px 20px;
      border-radius: 30px;
      font-size: 14px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 10px;
      box-shadow: 0 4px 20px rgba(16, 185, 129, 0.4);
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s ease;
    }

    .continuous-listening-indicator.active {
      opacity: 1;
      visibility: visible;
    }

    .continuous-listening-indicator.processing {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      box-shadow: 0 4px 20px rgba(245, 158, 11, 0.4);
    }

    .continuous-listening-indicator.speaking {
      background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%);
      box-shadow: 0 4px 20px rgba(139, 92, 246, 0.4);
    }

    .continuous-listening-indicator i {
      font-size: 16px;
    }

    .continuous-listening-indicator .listening-dots {
      display: flex;
      gap: 4px;
    }

    .continuous-listening-indicator .listening-dots span {
      width: 6px;
      height: 6px;
      background: white;
      border-radius: 50%;
      animation: listeningDot 1.4s ease-in-out infinite;
    }

    .continuous-listening-indicator .listening-dots span:nth-child(2) {
      animation-delay: 0.2s;
    }

    .continuous-listening-indicator .listening-dots span:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes listeningDot {
      0%, 80%, 100% { transform: scale(0.6); opacity: 0.5; }
      40% { transform: scale(1); opacity: 1; }
    }

    /* Image Preview */
    .image-preview-container {
      position: absolute;
      bottom: 100%;
      left: 0;
      right: 0;
      padding: var(--space-m);
      background: white;
      border: 2px solid var(--gray-30);
      border-radius: var(--radius);
      margin-bottom: var(--space-s);
      display: none;
      box-shadow: var(--shadow-medium);
    }

    body.dark .image-preview-container {
      background: var(--gray-30);
    }

    .image-preview-container.active {
      display: block;
      animation: slideUp 0.3s ease-out;
    }

    .image-preview {
      position: relative;
      width: 100px;
      height: 100px;
      border-radius: var(--radius);
      overflow: hidden;
    }

    .image-preview img {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    .image-preview-remove {
      position: absolute;
      top: 4px;
      right: 4px;
      background: rgba(0, 0, 0, 0.8);
      color: white;
      border: none;
      border-radius: var(--radius-full);
      width: 24px;
      height: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    /* Float buttons - 8-agent consensus: 56px primary, 48px secondary, 12px gap */
    .float-buttons {
      position: fixed;
      bottom: calc(var(--input-container-height) + var(--safe-area-bottom) + 12px);
      right: 12px;
      display: flex;
      flex-direction: column-reverse;
      gap: 12px;
      z-index: 80;
    }

    /* Secondary FABs - 48px (WCAG AAA compliant) */
    .fab {
      background: white;
      color: var(--gray-70);
      border: 1px solid var(--gray-20);
      width: 48px;
      height: 48px;
      border-radius: var(--radius-full);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      transition: all 0.15s ease;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.08);
      font-size: 17px;
      -webkit-tap-highlight-color: transparent;
    }

    .fab:hover {
      background: var(--gray-10);
      border-color: var(--gray-30);
      color: var(--gray-100);
      box-shadow: 0 3px 8px rgba(0, 0, 0, 0.12);
    }

    .fab:active {
      transform: scale(0.95);
    }

    body.dark .fab {
      background: var(--gray-30);
      border-color: var(--gray-40);
      color: var(--gray-80);
    }

    body.dark .fab:hover {
      background: var(--gray-40);
      color: white;
    }

    /* Delete button - de-emphasized */
    .fab.secondary {
      color: var(--gray-50);
    }

    .fab.secondary:hover {
      color: #ef4444;
      border-color: #fecaca;
      background: #fef2f2;
    }

    body.dark .fab.secondary:hover {
      color: #f87171;
      border-color: #7f1d1d;
      background: rgba(239, 68, 68, 0.15);
    }

    /* Prompt Library button */
    .fab.prompt-lib {
      color: var(--primary);
    }

    .fab.prompt-lib:hover {
      color: var(--primary-dark);
      border-color: rgba(var(--primary-rgb), 0.3);
      background: rgba(var(--primary-rgb), 0.05);
    }

    /* Menu button - PRIMARY action, 56px (Material Design standard) */
    .fab.menu {
      width: 56px;
      height: 56px;
      font-size: 20px;
      background: var(--primary);
      color: white;
      border-color: var(--primary);
      box-shadow: 0 3px 8px rgba(var(--primary-rgb), 0.3);
    }

    .fab.menu:hover {
      background: var(--primary-dark);
      border-color: var(--primary-dark);
      box-shadow: 0 4px 12px rgba(var(--primary-rgb), 0.4);
    }

    body.dark .fab.menu {
      background: var(--primary);
      border-color: var(--primary);
    }

    .fab.menu.active {
      transform: rotate(45deg);
    }

    /* Menu Items - Enhanced Design */
    .menu-items {
      position: fixed;
      bottom: calc(var(--input-container-height) + var(--safe-area-bottom) + 140px);
      right: 12px;
      background: white;
      border-radius: 16px;
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15), 0 2px 10px rgba(0, 0, 0, 0.08);
      padding: var(--space-m);
      opacity: 0;
      visibility: hidden;
      transform: translateY(10px) scale(0.95);
      transition: all 0.25s cubic-bezier(0.34, 1.56, 0.64, 1);
      z-index: 80;
      min-width: 280px;
      border: 1px solid rgba(0, 0, 0, 0.06);
    }

    body.dark .menu-items {
      background: #1e2028;
      border-color: rgba(255, 255, 255, 0.08);
      box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4), 0 2px 10px rgba(0, 0, 0, 0.2);
    }

    .menu-items.open {
      opacity: 1;
      visibility: visible;
      transform: translateY(0) scale(1);
    }

    /* Menu Section Groups */
    .menu-section {
      margin-bottom: var(--space-s);
    }

    .menu-section:last-child {
      margin-bottom: 0;
    }

    .menu-section-title {
      font-size: 11px;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      color: #a0a5b5;
      padding: var(--space-xs) var(--space-s);
      margin-bottom: var(--space-xs);
    }

    body.dark .menu-section-title {
      color: #6b7280;
    }

    .menu-divider {
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(0, 0, 0, 0.08), transparent);
      margin: var(--space-s) 0;
    }

    body.dark .menu-divider {
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.08), transparent);
    }

    .menu-item {
      display: flex;
      align-items: center;
      gap: var(--space-m);
      padding: 10px 12px;
      border-radius: 10px;
      cursor: pointer;
      transition: all 0.2s ease;
      color: #374151;
      position: relative;
      overflow: hidden;
    }

    body.dark .menu-item {
      color: #e5e7eb;
    }

    .menu-item:hover {
      background: linear-gradient(135deg, rgba(var(--primary-rgb), 0.1) 0%, rgba(var(--primary-rgb), 0.05) 100%);
      transform: translateX(4px);
    }

    .menu-item:active {
      transform: translateX(4px) scale(0.98);
    }

    .menu-item-icon {
      width: 36px;
      height: 36px;
      border-radius: 10px;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: all 0.2s ease;
    }

    .menu-item-icon i {
      font-size: 14px;
      transition: transform 0.2s ease;
    }

    .menu-item:hover .menu-item-icon i {
      transform: scale(1.1);
    }

    /* Icon color variants */
    .menu-item-icon.blue {
      background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
      color: white;
      box-shadow: 0 2px 8px rgba(59, 130, 246, 0.3);
    }

    .menu-item-icon.green {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      color: white;
      box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
    }

    .menu-item-icon.purple {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: white;
      box-shadow: 0 2px 8px rgba(var(--primary-rgb), 0.3);
    }

    .menu-item-icon.amber {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      color: white;
      box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
    }

    .menu-item-icon.slate {
      background: linear-gradient(135deg, #64748b 0%, #475569 100%);
      color: white;
      box-shadow: 0 2px 8px rgba(100, 116, 139, 0.3);
    }

    .menu-item-info {
      flex: 1;
      min-width: 0;
    }

    .menu-item-title {
      font-size: 14px;
      font-weight: 600;
      color: #1f2937;
      line-height: 1.3;
    }

    body.dark .menu-item-title {
      color: #f3f4f6;
    }

    .menu-item-desc {
      font-size: 11px;
      color: #9ca3af;
      line-height: 1.3;
      margin-top: 1px;
    }

    body.dark .menu-item-desc {
      color: #6b7280;
    }

    .menu-item-arrow {
      color: #d1d5db;
      font-size: 12px;
      transition: all 0.2s ease;
      opacity: 0;
      transform: translateX(-4px);
    }

    body.dark .menu-item-arrow {
      color: #4b5563;
    }

    .menu-item:hover .menu-item-arrow {
      opacity: 1;
      transform: translateX(0);
    }

    /* Staggered animation for menu items */
    .menu-items.open .menu-item {
      animation: menuItemSlideIn 0.3s ease forwards;
      opacity: 0;
    }

    /* Section 1: Current Chat */
    .menu-items.open .menu-section:nth-child(1) .menu-item:nth-child(2) { animation-delay: 0.02s; }
    .menu-items.open .menu-section:nth-child(1) .menu-item:nth-child(3) { animation-delay: 0.04s; }
    /* Section 2: All Data */
    .menu-items.open .menu-section:nth-child(3) .menu-item:nth-child(2) { animation-delay: 0.06s; }
    .menu-items.open .menu-section:nth-child(3) .menu-item:nth-child(3) { animation-delay: 0.08s; }
    /* Section 3: Tools */
    .menu-items.open .menu-section:nth-child(5) .menu-item:nth-child(2) { animation-delay: 0.1s; }
    .menu-items.open .menu-section:nth-child(5) .menu-item:nth-child(3) { animation-delay: 0.12s; }

    @keyframes menuItemSlideIn {
      from {
        opacity: 0;
        transform: translateX(-8px);
      }
      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    /* Icon Hover Scale - Cycle 8 Micro-interaction */
    .header-button i,
    .input-button i,
    .fab i,
    .code-copy-btn i,
    .message-action-btn i {
      display: inline-block;
      transition: transform 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .header-button:hover i,
    .input-button:hover i,
    .fab:hover i,
    .code-copy-btn:hover i,
    .message-action-btn:hover i {
      transform: scale(1.15);
    }

    /* Modal */
    .modal {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: var(--space-m);
    }

    .modal.active {
      display: flex;
      animation: fadeIn 0.2s ease-out;
    }

    /* Cycle 21: Modal close-out animation */
    .modal.closing {
      display: flex;
      animation: fadeOut 0.2s ease-out forwards;
    }

    .modal.closing .modal-content {
      animation: scaleOut 0.2s ease-out forwards;
    }

    @keyframes fadeOut {
      from { opacity: 1; }
      to { opacity: 0; }
    }

    @keyframes scaleOut {
      from { transform: scale(1); opacity: 1; }
      to { transform: scale(0.95); opacity: 0; }
    }

    .modal-content {
      background: white;
      border-radius: var(--radius-large);
      box-shadow: var(--shadow-large);
      max-width: 600px;
      width: 100%;
      max-height: 85vh;
      overflow-y: auto;
      animation: scaleIn 0.3s ease-out;
      position: relative;
    }

    body.dark .modal-content {
      background: var(--gray-20);
    }

    .modal-header {
      padding: var(--space-l);
      border-bottom: 1px solid var(--gray-30);
      display: flex;
      align-items: center;
      justify-content: space-between;
      position: sticky;
      top: 0;
      background: white;
      z-index: 10;
    }

    body.dark .modal-header {
      background: var(--gray-20);
      /* Cycle 20: Enhanced border luminosity */
      border-bottom-color: var(--gray-50);
    }

    .modal-header h2 {
      font-size: 20px;
      color: var(--gray-100);
      font-weight: 600;
    }

    .modal-close {
      background: none;
      border: none;
      font-size: 24px;
      color: var(--gray-60);
      cursor: pointer;
      transition: var(--transition);
      padding: 0;
      width: 36px;
      height: 36px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: var(--radius-full);
    }

    .modal-close:hover {
      background: var(--gray-20);
      color: var(--gray-100);
    }

    .modal-body {
      padding: var(--space-l);
    }

    .modal-footer {
      padding: var(--space-l);
      border-top: 1px solid var(--gray-30);
      display: flex;
      justify-content: flex-end;
      gap: var(--space-m);
      position: sticky;
      bottom: 0;
      background: white;
      z-index: 10;
    }

    body.dark .modal-footer {
      background: var(--gray-20);
      /* Cycle 20: Enhanced border luminosity */
      border-top-color: var(--gray-50);
    }

    /* ==================== Time Machine Enhanced Styles ==================== */
    #time-machine-modal .modal-content {
      max-width: 420px;
      overflow: hidden;
    }

    #time-machine-modal .modal-header {
      border-bottom: none;
      padding-bottom: 0;
    }

    #time-machine-modal .modal-body {
      padding-top: var(--space-s);
    }

    .time-machine-hero {
      text-align: center;
      padding: var(--space-m) 0 var(--space-l);
    }

    .time-machine-icon-wrapper {
      width: 90px;
      height: 90px;
      margin: 0 auto var(--space-m);
      position: relative;
    }

    .time-machine-icon {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, var(--primary) 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 10px 40px rgba(102, 126, 234, 0.35);
      position: relative;
      overflow: hidden;
    }

    .time-machine-icon::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.25) 0%, transparent 50%);
    }

    .time-machine-icon i {
      font-size: 36px;
      color: white;
      z-index: 1;
      animation: timePulse 2s ease-in-out infinite;
    }

    @keyframes timePulse {
      0%, 100% { transform: scale(1) rotate(0deg); }
      50% { transform: scale(1.05) rotate(-10deg); }
    }

    .time-machine-ring {
      position: absolute;
      inset: -6px;
      border: 2px dashed rgba(102, 126, 234, 0.3);
      border-radius: 50%;
      animation: orbitRing 10s linear infinite;
    }

    @keyframes orbitRing {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .time-machine-subtitle {
      font-size: 15px;
      color: #6b7280;
      line-height: 1.5;
    }

    body.dark .time-machine-subtitle {
      color: #9ca3af;
    }

    .time-machine-stats {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: var(--space-m);
      margin-bottom: var(--space-l);
    }

    .time-machine-stat {
      background: linear-gradient(135deg, #f8f9fc 0%, #f0f2f8 100%);
      border-radius: 12px;
      padding: var(--space-m);
      text-align: center;
      border: 1px solid #e5e7eb;
    }

    body.dark .time-machine-stat {
      background: linear-gradient(135deg, #2a2d3a 0%, #1e2028 100%);
      border-color: #374151;
    }

    .time-machine-stat-value {
      font-size: 26px;
      font-weight: 700;
      color: var(--primary);
      line-height: 1.2;
    }

    .time-machine-stat-label {
      font-size: 11px;
      color: #6b7280;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-top: 2px;
    }

    body.dark .time-machine-stat-label {
      color: #9ca3af;
    }

    .time-machine-speed {
      margin-bottom: var(--space-l);
    }

    .time-machine-speed-label {
      font-size: 11px;
      font-weight: 600;
      color: #9ca3af;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: var(--space-s);
      text-align: center;
    }

    .time-machine-speed-options {
      display: flex;
      gap: var(--space-s);
      justify-content: center;
    }

    .speed-option {
      padding: 8px 16px;
      border-radius: 20px;
      border: 2px solid #e5e7eb;
      background: white;
      font-size: 13px;
      font-weight: 600;
      color: #6b7280;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    body.dark .speed-option {
      background: #1e2028;
      border-color: #374151;
      color: #9ca3af;
    }

    .speed-option:hover {
      border-color: var(--primary);
      color: var(--primary);
    }

    .speed-option.active {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    .time-machine-start-btn {
      width: 100%;
      padding: 14px 24px;
      border-radius: 12px;
      border: none;
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: white;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-s);
      box-shadow: 0 4px 15px rgba(var(--primary-rgb), 0.3);
    }

    .time-machine-start-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(var(--primary-rgb), 0.4);
    }

    .time-machine-start-btn:active {
      transform: translateY(0);
    }

    .time-machine-playback {
      display: none;
    }

    .time-machine-playback.active {
      display: block;
    }

    .time-machine-progress-bar {
      height: 6px;
      background: #e5e7eb;
      border-radius: 3px;
      margin-bottom: var(--space-s);
      overflow: hidden;
    }

    body.dark .time-machine-progress-bar {
      background: #374151;
    }

    .time-machine-progress-fill {
      height: 100%;
      background: linear-gradient(90deg, var(--primary), #667eea);
      border-radius: 3px;
      transition: width 0.3s ease;
      width: 0%;
    }

    .time-machine-progress-text {
      text-align: center;
      font-size: 14px;
      color: #6b7280;
      margin-bottom: var(--space-m);
    }

    body.dark .time-machine-progress-text {
      color: #9ca3af;
    }

    .time-machine-progress-text strong {
      color: var(--primary);
      font-weight: 700;
    }

    .time-machine-controls {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-m);
      margin-bottom: var(--space-l);
    }

    .tm-control-btn {
      width: 44px;
      height: 44px;
      border-radius: 50%;
      border: none;
      background: #f3f4f6;
      color: #4b5563;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
    }

    body.dark .tm-control-btn {
      background: #374151;
      color: #d1d5db;
    }

    .tm-control-btn:hover {
      background: var(--primary);
      color: white;
      transform: scale(1.08);
    }

    .tm-control-btn.primary {
      width: 56px;
      height: 56px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: white;
      box-shadow: 0 4px 15px rgba(var(--primary-rgb), 0.3);
      font-size: 18px;
    }

    .tm-control-btn.primary:hover {
      transform: scale(1.1);
    }

    .tm-control-btn.stop {
      background: #fee2e2;
      color: #dc2626;
    }

    body.dark .tm-control-btn.stop {
      background: rgba(220, 38, 38, 0.2);
      color: #f87171;
    }

    .tm-control-btn.stop:hover {
      background: #dc2626;
      color: white;
    }

    .time-machine-branch-btn {
      width: 100%;
      padding: 12px 20px;
      border-radius: 10px;
      border: 2px solid var(--primary);
      background: transparent;
      color: var(--primary);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-s);
    }

    .time-machine-branch-btn:hover {
      background: var(--primary);
      color: white;
    }

    .button {
      padding: 10px 20px;
      border-radius: var(--radius);
      border: none;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: var(--transition);
      display: inline-flex;
      align-items: center;
      gap: var(--space-s);
    }

    .button-primary {
      background: var(--primary);
      color: white;
    }

    .button-primary:hover {
      background: var(--primary-dark);
    }

    .button-secondary {
      background: var(--gray-20);
      color: var(--gray-100);
    }

    body.dark .button-secondary {
      background: var(--gray-40);
    }

    .button-success {
      background: var(--success);
      color: white;
    }

    .button-success:hover {
      background: #45a049;
    }

    /* Button press feedback - Cycle 7 Feature */
    .button:active {
      transform: scale(0.96);
    }

    .button:disabled:active {
      transform: none;
    }

    /* Settings Tabs */
    .settings-tabs {
      display: flex;
      gap: 4px;
      padding: 4px;
      background: var(--gray-20);
      border-radius: var(--radius);
      margin-bottom: var(--space-l);
    }

    body.dark .settings-tabs {
      background: var(--gray-30);
    }

    .settings-tab {
      flex: 1;
      padding: 10px 12px;
      border: none;
      background: transparent;
      color: var(--gray-70);
      font-size: 13px;
      font-weight: 500;
      border-radius: calc(var(--radius) - 2px);
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .settings-tab:hover {
      color: var(--gray-90);
      background: rgba(255, 255, 255, 0.5);
    }

    body.dark .settings-tab:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .settings-tab.active {
      background: white;
      color: var(--gray-100);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    body.dark .settings-tab.active {
      background: var(--gray-50);
      color: white;
    }

    .settings-tab i {
      font-size: 14px;
    }

    .settings-tab-content {
      display: none;
      min-height: 280px;
    }

    .settings-tab-content.active {
      display: block;
      animation: fadeIn 0.2s ease;
    }

    /* Settings */
    .settings-section {
      margin-bottom: var(--space-l);
    }

    .settings-section:last-child {
      margin-bottom: 0;
    }

    .settings-section h3 {
      font-size: 16px;
      margin-bottom: var(--space-m);
      color: var(--gray-100);
      font-weight: 600;
    }

    .settings-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-s) 0;
      gap: var(--space-m);
    }

    .settings-item label {
      font-size: 14px;
      color: var(--gray-80);
      font-weight: 500;
      flex: 1;
    }

    .toggle-switch {
      position: relative;
      width: 48px;
      min-width: 48px;
      height: 28px;
      background: var(--gray-30);
      border-radius: var(--radius-full);
      cursor: pointer;
      transition: var(--transition);
      flex-shrink: 0;
      z-index: 1;
    }

    .toggle-switch.active {
      background: var(--success);
    }

    .toggle-switch::after {
      content: "";
      position: absolute;
      top: 3px;
      left: 3px;
      width: 22px;
      height: 22px;
      background: white;
      border-radius: var(--radius-full);
      transition: var(--transition);
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
      pointer-events: none;
    }

    .toggle-switch.active::after {
      transform: translateX(20px);
    }

    /* Cycle 29: Toggle switch dark mode inactive state */
    body.dark .toggle-switch {
      background: var(--gray-50);
    }

    body.dark .toggle-switch::after {
      background: var(--gray-80);
    }

    body.dark .toggle-switch.active::after {
      background: white;
    }

    /* Cycle 29: Toggle switch focus indicators */
    .toggle-switch:focus-visible {
      outline: none;
      box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.3);
    }

    body.dark .toggle-switch:focus-visible {
      box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.4);
    }

    /* ==================== Voice Preview Overlay ==================== */
    .voice-preview-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.6);
      backdrop-filter: blur(8px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      padding: var(--space-l);
    }

    .voice-preview-overlay.active {
      display: flex;
      animation: fadeIn 0.2s ease-out;
    }

    .voice-preview-container {
      background: white;
      border-radius: 20px;
      width: 100%;
      max-width: 500px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
      overflow: hidden;
      animation: slideUp 0.3s ease-out;
    }

    body.dark .voice-preview-container {
      background: #1e2028;
    }

    @keyframes slideUp {
      from {
        opacity: 0;
        transform: translateY(20px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .voice-preview-header {
      padding: var(--space-l);
      text-align: center;
      border-bottom: 1px solid #e5e7eb;
    }

    body.dark .voice-preview-header {
      border-bottom-color: #374151;
    }

    .voice-preview-status {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-s);
      margin-bottom: var(--space-s);
    }

    .voice-preview-icon {
      width: 48px;
      height: 48px;
      border-radius: 50%;
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 20px;
      animation: pulse 1.5s ease-in-out infinite;
    }

    .voice-preview-icon.listening {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
    }

    .voice-preview-icon.processing {
      background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
      animation: spin 1s linear infinite;
    }

    .voice-preview-icon.ready {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      animation: none;
    }

    @keyframes pulse {
      0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
      50% { transform: scale(1.05); box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); }
    }

    @keyframes spin {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }

    .voice-preview-title {
      font-size: 16px;
      font-weight: 600;
      color: #1f2937;
    }

    body.dark .voice-preview-title {
      color: #f3f4f6;
    }

    .voice-preview-subtitle {
      font-size: 13px;
      color: #6b7280;
      margin-top: 2px;
    }

    body.dark .voice-preview-subtitle {
      color: #9ca3af;
    }

    .voice-preview-body {
      padding: var(--space-l);
      min-height: 120px;
    }

    .voice-preview-text {
      width: 100%;
      min-height: 100px;
      padding: var(--space-m);
      border: 2px solid #e5e7eb;
      border-radius: 12px;
      font-size: 16px;
      line-height: 1.6;
      color: #1f2937;
      background: #f9fafb;
      resize: none;
      font-family: inherit;
      transition: all 0.2s ease;
    }

    body.dark .voice-preview-text {
      background: #111827;
      border-color: #374151;
      color: #f3f4f6;
    }

    .voice-preview-text:focus {
      outline: none;
      border-color: var(--primary);
      box-shadow: 0 0 0 3px rgba(var(--primary-rgb), 0.1);
    }

    .voice-preview-text.listening {
      border-color: #ef4444;
      background: #fef2f2;
    }

    body.dark .voice-preview-text.listening {
      background: rgba(239, 68, 68, 0.1);
      border-color: #ef4444;
    }

    .voice-preview-text::placeholder {
      color: #9ca3af;
      font-style: italic;
    }

    .voice-preview-hint {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-xs);
      margin-top: var(--space-s);
      font-size: 12px;
      color: #9ca3af;
    }

    .voice-preview-hint i {
      font-size: 14px;
    }

    .voice-preview-waveform {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 3px;
      height: 30px;
      margin-top: var(--space-m);
    }

    .voice-preview-waveform.hidden {
      display: none;
    }

    .waveform-bar {
      width: 4px;
      height: 100%;
      background: var(--primary);
      border-radius: 2px;
      animation: waveform 0.5s ease-in-out infinite;
    }

    .waveform-bar:nth-child(1) { animation-delay: 0s; height: 40%; }
    .waveform-bar:nth-child(2) { animation-delay: 0.1s; height: 70%; }
    .waveform-bar:nth-child(3) { animation-delay: 0.2s; height: 100%; }
    .waveform-bar:nth-child(4) { animation-delay: 0.3s; height: 60%; }
    .waveform-bar:nth-child(5) { animation-delay: 0.4s; height: 80%; }
    .waveform-bar:nth-child(6) { animation-delay: 0.3s; height: 50%; }
    .waveform-bar:nth-child(7) { animation-delay: 0.2s; height: 90%; }

    @keyframes waveform {
      0%, 100% { transform: scaleY(0.3); }
      50% { transform: scaleY(1); }
    }

    .voice-preview-footer {
      padding: var(--space-m) var(--space-l) var(--space-l);
      display: flex;
      gap: var(--space-m);
    }

    .voice-preview-btn {
      flex: 1;
      padding: 14px 20px;
      border-radius: 12px;
      border: none;
      font-size: 15px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--space-s);
    }

    .voice-preview-btn.cancel {
      background: #f3f4f6;
      color: #4b5563;
    }

    body.dark .voice-preview-btn.cancel {
      background: #374151;
      color: #d1d5db;
    }

    .voice-preview-btn.cancel:hover {
      background: #e5e7eb;
    }

    body.dark .voice-preview-btn.cancel:hover {
      background: #4b5563;
    }

    .voice-preview-btn.send {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: white;
      box-shadow: 0 4px 15px rgba(var(--primary-rgb), 0.3);
    }

    .voice-preview-btn.send:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(var(--primary-rgb), 0.4);
    }

    .voice-preview-btn.send:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    .voice-preview-btn.retry {
      background: #fef3c7;
      color: #92400e;
    }

    body.dark .voice-preview-btn.retry {
      background: rgba(245, 158, 11, 0.2);
      color: #fbbf24;
    }

    .voice-preview-btn.retry:hover {
      background: #fde68a;
    }

    body.dark .voice-preview-btn.retry:hover {
      background: rgba(245, 158, 11, 0.3);
    }

    /* ========================================
       PUSH-TO-TALK VOICE MODE
       ======================================== */

    .voice-mode-panel {
      position: fixed;
      bottom: calc(var(--input-container-height) + var(--safe-area-bottom) + 200px);
      right: 12px;
      width: 320px;
      background: white;
      border-radius: 20px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15), 0 2px 8px rgba(0, 0, 0, 0.1);
      z-index: 90;
      opacity: 0;
      visibility: hidden;
      transform: translateY(20px) scale(0.95);
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      overflow: hidden;
    }

    .voice-mode-panel.active {
      opacity: 1;
      visibility: visible;
      transform: translateY(0) scale(1);
    }

    body.dark .voice-mode-panel {
      background: #1e1e2e;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }

    .voice-mode-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 16px 20px;
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: white;
    }

    .voice-mode-header h3 {
      margin: 0;
      font-size: 16px;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .voice-mode-header h3 i {
      font-size: 18px;
    }

    .voice-mode-close {
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: white;
      width: 28px;
      height: 28px;
      border-radius: 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .voice-mode-close:hover {
      background: rgba(255, 255, 255, 0.3);
    }

    .voice-mode-body {
      padding: 20px;
    }

    .voice-mode-status {
      text-align: center;
      margin-bottom: 20px;
    }

    .voice-mode-status-text {
      font-size: 14px;
      color: #666;
      margin-bottom: 8px;
    }

    body.dark .voice-mode-status-text {
      color: #a0a0a0;
    }

    .voice-mode-hotkey-hint {
      font-size: 12px;
      color: #999;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
    }

    .voice-mode-hotkey-hint kbd {
      background: #f0f0f0;
      border: 1px solid #ddd;
      border-radius: 4px;
      padding: 2px 6px;
      font-family: monospace;
      font-size: 11px;
    }

    body.dark .voice-mode-hotkey-hint kbd {
      background: #2a2a3a;
      border-color: #3a3a4a;
      color: #ccc;
    }

    /* Push-to-Talk Button */
    .ptt-button-container {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }

    .ptt-button {
      width: 100px;
      height: 100px;
      border-radius: 50%;
      border: none;
      background: linear-gradient(145deg, #f0f0f0, #e0e0e0);
      box-shadow:
        8px 8px 16px rgba(0, 0, 0, 0.1),
        -8px -8px 16px rgba(255, 255, 255, 0.9),
        inset 0 0 0 4px rgba(255, 255, 255, 0.5);
      cursor: pointer;
      transition: all 0.15s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      user-select: none;
      -webkit-user-select: none;
    }

    .ptt-button i {
      font-size: 36px;
      color: #666;
      transition: all 0.15s ease;
      z-index: 2;
    }

    .ptt-button:hover {
      background: linear-gradient(145deg, #e8e8e8, #d8d8d8);
    }

    .ptt-button:active,
    .ptt-button.recording {
      background: linear-gradient(145deg, var(--primary), var(--primary-dark));
      box-shadow:
        inset 4px 4px 8px rgba(0, 0, 0, 0.2),
        inset -4px -4px 8px rgba(255, 255, 255, 0.1),
        0 0 0 4px rgba(var(--primary-rgb), 0.3);
      transform: scale(0.95);
    }

    .ptt-button:active i,
    .ptt-button.recording i {
      color: white;
      transform: scale(1.1);
    }

    body.dark .ptt-button {
      background: linear-gradient(145deg, #2a2a3a, #1a1a2a);
      box-shadow:
        8px 8px 16px rgba(0, 0, 0, 0.3),
        -8px -8px 16px rgba(60, 60, 80, 0.2),
        inset 0 0 0 4px rgba(255, 255, 255, 0.05);
    }

    body.dark .ptt-button i {
      color: #a0a0a0;
    }

    body.dark .ptt-button:hover {
      background: linear-gradient(145deg, #323242, #222232);
    }

    /* Recording pulse ring */
    .ptt-button::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: transparent;
      border: 3px solid var(--primary);
      opacity: 0;
      transform: scale(1);
      transition: all 0.3s ease;
    }

    .ptt-button.recording::before {
      animation: pttPulse 1s ease-out infinite;
    }

    @keyframes pttPulse {
      0% {
        transform: scale(1);
        opacity: 0.8;
      }
      100% {
        transform: scale(1.5);
        opacity: 0;
      }
    }

    /* Recording indicator */
    .ptt-recording-indicator {
      display: none;
      align-items: center;
      justify-content: center;
      gap: 8px;
      padding: 10px 16px;
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      border-radius: 20px;
      color: white;
      font-size: 13px;
      font-weight: 600;
      margin-bottom: 16px;
    }

    .ptt-recording-indicator.active {
      display: flex;
      animation: fadeIn 0.2s ease;
    }

    .ptt-recording-indicator i {
      animation: blink 1s ease-in-out infinite;
    }

    @keyframes blink {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    .ptt-recording-time {
      font-family: monospace;
      font-size: 14px;
    }

    /* Audio waveform visualization */
    .ptt-waveform {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 3px;
      height: 40px;
      margin-bottom: 16px;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .ptt-waveform.active {
      opacity: 1;
    }

    .ptt-waveform-bar {
      width: 4px;
      height: 8px;
      background: var(--primary);
      border-radius: 2px;
      transition: height 0.1s ease;
    }

    .ptt-waveform.active .ptt-waveform-bar {
      animation: waveformAnimate 0.5s ease-in-out infinite;
    }

    .ptt-waveform-bar:nth-child(1) { animation-delay: 0s; }
    .ptt-waveform-bar:nth-child(2) { animation-delay: 0.1s; }
    .ptt-waveform-bar:nth-child(3) { animation-delay: 0.05s; }
    .ptt-waveform-bar:nth-child(4) { animation-delay: 0.15s; }
    .ptt-waveform-bar:nth-child(5) { animation-delay: 0.02s; }
    .ptt-waveform-bar:nth-child(6) { animation-delay: 0.12s; }
    .ptt-waveform-bar:nth-child(7) { animation-delay: 0.08s; }
    .ptt-waveform-bar:nth-child(8) { animation-delay: 0.18s; }
    .ptt-waveform-bar:nth-child(9) { animation-delay: 0.03s; }
    .ptt-waveform-bar:nth-child(10) { animation-delay: 0.13s; }

    @keyframes waveformAnimate {
      0%, 100% { height: 8px; }
      50% { height: 32px; }
    }

    /* Transcript preview */
    .ptt-transcript-preview {
      background: #f8f9fc;
      border-radius: 12px;
      padding: 12px 16px;
      margin-bottom: 16px;
      min-height: 60px;
      max-height: 100px;
      overflow-y: auto;
      font-size: 14px;
      color: #333;
      line-height: 1.5;
      border: 1px solid #e2e6f0;
    }

    .ptt-transcript-preview.empty {
      color: #999;
      font-style: italic;
    }

    .ptt-transcript-preview.interim {
      color: #666;
      font-style: italic;
    }

    body.dark .ptt-transcript-preview {
      background: #252535;
      border-color: #3a3a4a;
      color: #e0e0e0;
    }

    body.dark .ptt-transcript-preview.empty,
    body.dark .ptt-transcript-preview.interim {
      color: #888;
    }

    /* Recent recordings section */
    .ptt-recordings-section {
      border-top: 1px solid #e2e6f0;
      padding-top: 16px;
    }

    body.dark .ptt-recordings-section {
      border-color: #3a3a4a;
    }

    .ptt-recordings-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 12px;
    }

    .ptt-recordings-header h4 {
      margin: 0;
      font-size: 13px;
      font-weight: 600;
      color: #666;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    body.dark .ptt-recordings-header h4 {
      color: #a0a0a0;
    }

    .ptt-clear-recordings {
      background: none;
      border: none;
      color: #999;
      font-size: 12px;
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 4px;
      transition: all 0.2s ease;
    }

    .ptt-clear-recordings:hover {
      background: #f0f0f0;
      color: #666;
    }

    body.dark .ptt-clear-recordings:hover {
      background: #2a2a3a;
      color: #ccc;
    }

    .ptt-recordings-list {
      display: flex;
      flex-direction: column;
      gap: 8px;
      max-height: 150px;
      overflow-y: auto;
    }

    .ptt-recording-item {
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 10px 12px;
      background: #f8f9fc;
      border-radius: 10px;
      border: 1px solid #e2e6f0;
      transition: all 0.2s ease;
    }

    .ptt-recording-item:hover {
      background: #f0f2f8;
      border-color: var(--primary);
    }

    body.dark .ptt-recording-item {
      background: #252535;
      border-color: #3a3a4a;
    }

    body.dark .ptt-recording-item:hover {
      background: #2a2a3a;
    }

    .ptt-recording-play {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: none;
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      flex-shrink: 0;
      transition: all 0.2s ease;
    }

    .ptt-recording-play:hover {
      transform: scale(1.1);
      box-shadow: 0 2px 8px rgba(var(--primary-rgb), 0.4);
    }

    .ptt-recording-play i {
      font-size: 12px;
      margin-left: 2px;
    }

    .ptt-recording-info {
      flex: 1;
      min-width: 0;
    }

    .ptt-recording-text {
      font-size: 13px;
      color: #333;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      margin-bottom: 2px;
    }

    body.dark .ptt-recording-text {
      color: #e0e0e0;
    }

    .ptt-recording-meta {
      font-size: 11px;
      color: #999;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .ptt-recording-delete {
      background: none;
      border: none;
      color: #ccc;
      cursor: pointer;
      padding: 4px;
      border-radius: 4px;
      transition: all 0.2s ease;
      opacity: 0;
    }

    .ptt-recording-item:hover .ptt-recording-delete {
      opacity: 1;
    }

    .ptt-recording-delete:hover {
      color: #ef4444;
      background: rgba(239, 68, 68, 0.1);
    }

    .ptt-no-recordings {
      text-align: center;
      padding: 20px;
      color: #999;
      font-size: 13px;
    }

    /* Voice mode FAB - integrated with float-buttons group */
    .fab.voice-mode {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      color: white;
      border: none;
      box-shadow: 0 3px 12px rgba(var(--primary-rgb), 0.35);
    }

    .fab.voice-mode:hover {
      background: linear-gradient(135deg, var(--primary-dark) 0%, var(--primary) 100%);
      box-shadow: 0 4px 16px rgba(var(--primary-rgb), 0.45);
      transform: scale(1.05);
    }

    .fab.voice-mode.active {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      box-shadow: 0 3px 12px rgba(239, 68, 68, 0.4);
    }

    .fab.voice-mode.recording {
      background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
      box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.3), 0 3px 12px rgba(239, 68, 68, 0.5);
      animation: fabRecordingPulse 1s ease-in-out infinite;
    }

    @keyframes fabRecordingPulse {
      0%, 100% {
        box-shadow: 0 0 0 4px rgba(239, 68, 68, 0.3), 0 3px 12px rgba(239, 68, 68, 0.5);
        transform: scale(1);
      }
      50% {
        box-shadow: 0 0 0 8px rgba(239, 68, 68, 0.15), 0 4px 16px rgba(239, 68, 68, 0.6);
        transform: scale(1.05);
      }
    }

    body.dark .fab.voice-mode {
      background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
      border: none;
    }

    body.dark .fab.voice-mode:hover {
      background: linear-gradient(135deg, var(--primary-dark) 0%, var(--primary) 100%);
    }

    /* Voice mode active indicator on main input */
    .input-area.voice-mode-active {
      border: 2px solid var(--primary);
      box-shadow: 0 0 0 4px rgba(var(--primary-rgb), 0.1);
    }

    .input-area.voice-mode-active::before {
      content: ' Voice Mode Active - Hold Space to Talk';
      position: absolute;
      top: -28px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--primary);
      color: white;
      padding: 4px 12px;
      border-radius: 12px;
      font-size: 12px;
      font-weight: 500;
      white-space: nowrap;
    }

    /* Drop Zone */
    .drop-zone {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(var(--primary-rgb), 0.95);
      backdrop-filter: blur(10px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }

    .drop-zone.active {
      display: flex;
      animation: fadeIn 0.2s ease-out;
    }

    .drop-zone-content {
      text-align: center;
      color: white;
    }

    .drop-zone-content i {
      font-size: 72px;
      margin-bottom: var(--space-l);
    }

    .drop-zone-content p {
      font-size: 24px;
      font-weight: 600;
    }

    /* Utility Classes */
    .hidden {
      display: none !important;
    }

    .text-center {
      text-align: center;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .message-wrapper {
        max-width: 90%;
      }

      .modal-content {
        margin: 20px;
      }
    }

    /* Skip Link Accessibility - Cycle 12 */
    .skip-link {
      position: absolute;
      top: -100px;
      left: 50%;
      transform: translateX(-50%);
      background: var(--primary);
      color: white;
      padding: 12px 24px;
      border-radius: 0 0 8px 8px;
      font-weight: 600;
      text-decoration: none;
      z-index: 10000;
      transition: top 0.2s ease;
    }
    .skip-link:focus {
      top: 0;
      outline: 2px solid white;
      outline-offset: 2px;
    }

    /* Reduced Motion Accessibility - Cycle 11 */
    @media (prefers-reduced-motion: reduce) {
      *, *::before, *::after {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
        scroll-behavior: auto !important;
      }
    }

    /* iOS specific fixes */
    @supports (-webkit-touch-callout: none) {
      .app-container {
        height: -webkit-fill-available;
      }
    }

    /* Scrollbar */
    /* Modern Auto-Hide Scrollbar - Cycle 8 Feature */
    ::-webkit-scrollbar {
      width: 6px;
      height: 6px;
    }

    ::-webkit-scrollbar-track {
      background: transparent;
    }

    ::-webkit-scrollbar-thumb {
      background: var(--gray-40);
      border-radius: 3px;
    }

    ::-webkit-scrollbar-thumb:hover {
      background: var(--gray-60);
    }

    /* Dark mode scrollbar - Cycle 16 Enhanced Contrast */
    body.dark ::-webkit-scrollbar-thumb {
      background: var(--gray-80);
    }

    body.dark ::-webkit-scrollbar-thumb:hover {
      background: var(--gray-100);
    }

    /* Firefox scrollbar */
    * {
      scrollbar-width: thin;
      scrollbar-color: var(--gray-40) transparent;
    }

    body.dark * {
      scrollbar-color: var(--gray-80) transparent;
    }

    /* Focus styles */
    *:focus-visible {
      outline: 2px solid var(--primary);
      outline-offset: 2px;
    }

    /* Hidden file inputs */
    input[type="file"] {
      display: none;
    }

    /* ========================================
       CYCLE 2 FEATURES
       ======================================== */

    /* Feature 1: Scroll-to-bottom button - Cycle 13 Mobile Touch Target */
    .scroll-to-bottom {
      position: fixed;
      bottom: calc(var(--input-container-height) + var(--safe-area-bottom) + 20px);
      left: 50%;
      transform: translateX(-50%) translateY(20px);
      background: white;
      border: 1px solid var(--gray-30);
      width: 44px;
      height: 44px;
      border-radius: var(--radius-full);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      opacity: 0;
      visibility: hidden;
      transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
      z-index: 75;
      font-size: 16px;
      color: var(--gray-70);
    }

    .scroll-to-bottom.visible {
      opacity: 1;
      visibility: visible;
      transform: translateX(-50%) translateY(0);
    }

    .scroll-to-bottom:hover {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
      box-shadow: 0 6px 20px rgba(var(--primary-rgb), 0.3);
    }

    .scroll-to-bottom:active {
      transform: translateX(-50%) scale(0.95);
    }

    body.dark .scroll-to-bottom {
      background: var(--gray-30);
      border-color: var(--gray-40);
      color: var(--gray-80);
    }

    body.dark .scroll-to-bottom:hover {
      background: var(--primary);
      color: white;
      border-color: var(--primary);
    }

    /* Unread indicator badge */
    .scroll-to-bottom .unread-badge {
      position: absolute;
      top: -6px;
      right: -6px;
      background: var(--accent);
      color: white;
      font-size: 10px;
      font-weight: 600;
      min-width: 18px;
      height: 18px;
      border-radius: var(--radius-full);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 4px;
      animation: badgePop 0.3s cubic-bezier(0.34, 1.56, 0.64, 1), unreadPulse 2s ease-in-out 0.3s infinite;
    }

    @keyframes badgePop {
      from {
        transform: scale(0);
      }
      to {
        transform: scale(1);
      }
    }

    /* Cycle 25: Enhanced unread badge pulse */
    @keyframes unreadPulse {
      0%, 100% {
        box-shadow: 0 0 0 0 rgba(var(--accent-rgb, 233, 30, 99), 0.4);
      }
      50% {
        box-shadow: 0 0 0 6px rgba(var(--accent-rgb, 233, 30, 99), 0);
      }
    }

    /* Feature 2: Keyboard shortcuts help modal */
    .shortcuts-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      backdrop-filter: blur(4px);
      z-index: 200;
      display: flex;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s ease;
    }

    .shortcuts-modal.active {
      opacity: 1;
      visibility: visible;
    }

    .shortcuts-container {
      background: white;
      border-radius: var(--radius-large);
      padding: var(--space-l);
      max-width: 480px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: var(--shadow-large);
      transform: scale(0.95) translateY(10px);
      transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    .shortcuts-modal.active .shortcuts-container {
      transform: scale(1) translateY(0);
    }

    body.dark .shortcuts-container {
      background: var(--gray-20);
    }

    .shortcuts-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: var(--space-l);
      padding-bottom: var(--space-m);
      border-bottom: 1px solid var(--gray-30);
    }

    .shortcuts-title {
      display: flex;
      align-items: center;
      gap: var(--space-s);
      font-size: 18px;
      font-weight: 600;
      color: var(--gray-100);
    }

    .shortcuts-title i {
      color: var(--primary);
    }

    .shortcuts-close {
      background: none;
      border: none;
      width: 32px;
      height: 32px;
      border-radius: var(--radius-full);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--gray-60);
      transition: all 0.15s ease;
    }

    .shortcuts-close:hover {
      background: var(--gray-20);
      color: var(--gray-100);
    }

    .shortcuts-grid {
      display: grid;
      gap: var(--space-m);
    }

    .shortcut-item {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: var(--space-s) 0;
    }

    .shortcut-label {
      color: var(--gray-80);
      font-size: 14px;
    }

    .shortcut-keys {
      display: flex;
      gap: 4px;
    }

    .shortcut-key {
      background: var(--gray-20);
      border: 1px solid var(--gray-30);
      border-radius: var(--radius-small);
      padding: 4px 8px;
      font-size: 12px;
      font-weight: 500;
      font-family: -apple-system, BlinkMacSystemFont, "SF Mono", Monaco, monospace;
      color: var(--gray-100);
      min-width: 28px;
      text-align: center;
    }

    body.dark .shortcut-key {
      background: var(--gray-30);
      border-color: var(--gray-40);
    }

    .shortcuts-section {
      margin-top: var(--space-m);
      padding-top: var(--space-m);
      border-top: 1px solid var(--gray-20);
    }

    .shortcuts-section-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--gray-60);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: var(--space-s);
    }

    /* Feature 3: Message copy button */
    .message-actions {
      position: absolute;
      top: 8px;
      right: 8px;
      display: flex;
      gap: 4px;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .message-wrapper:hover .message-actions {
      opacity: 1;
    }

    .message-action-btn {
      background: white;
      border: 1px solid var(--gray-30);
      /* Cycle 18: Touch target 44px WCAG compliance */
      width: 44px;
      height: 44px;
      border-radius: var(--radius);
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      color: var(--gray-60);
      font-size: 14px;
      transition: all 0.15s ease;
    }

    .message-action-btn:hover {
      background: var(--gray-20);
      color: var(--gray-100);
      border-color: var(--gray-40);
    }

    .message-action-btn.copied {
      background: var(--success);
      border-color: var(--success);
      color: white;
    }

    body.dark .message-action-btn {
      background: var(--gray-40);
      border-color: var(--gray-50);
      color: var(--gray-80);
    }

    body.dark .message-action-btn:hover {
      background: var(--gray-50);
      color: white;
    }

    /* Cycle 23: Message reaction buttons */
    .message-action-btn.reaction {
      font-size: 16px;
    }

    .message-action-btn.reaction.liked {
      background: rgba(76, 175, 80, 0.15);
      border-color: var(--success);
      color: var(--success);
    }

    .message-action-btn.reaction.disliked {
      background: rgba(244, 67, 54, 0.15);
      border-color: var(--error);
      color: var(--error);
    }

    .message-action-btn.reaction:active {
      animation: reactionPop 0.3s ease-out;
    }

    @keyframes reactionPop {
      0% { transform: scale(1); }
      50% { transform: scale(1.3); }
      100% { transform: scale(1); }
    }

    /* Make message-content position relative for actions */
    .message-content {
      position: relative;
    }

    /* Cycle 3 Feature 2: Error retry state */
    .error-retry-state {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: var(--space-m);
      padding: var(--space-l);
      background: rgba(244, 67, 54, 0.08);
      border: 1px solid rgba(244, 67, 54, 0.3);
      border-radius: var(--radius);
      text-align: center;
      animation: shakeError 0.4s ease-out;
    }

    @keyframes shakeError {
      0%, 100% { transform: translateX(0); }
      20% { transform: translateX(-8px); }
      40% { transform: translateX(8px); }
      60% { transform: translateX(-4px); }
      80% { transform: translateX(4px); }
    }

    .error-retry-state i {
      font-size: 32px;
      color: var(--error);
    }

    .error-retry-state p {
      margin: 0;
      color: var(--gray-100);
      font-size: 14px;
    }

    .error-retry-state strong {
      color: var(--error);
    }

    .error-retry-btn {
      padding: 10px 20px;
      background: var(--error);
      color: white;
      border: none;
      border-radius: var(--radius);
      cursor: pointer;
      font-weight: 600;
      font-size: 14px;
      display: flex;
      align-items: center;
      gap: var(--space-s);
      transition: all 0.2s ease;
    }

    .error-retry-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(244, 67, 54, 0.3);
      background: #d32f2f;
    }

    .error-retry-btn:active {
      transform: translateY(0);
    }

    body.dark .error-retry-state {
      background: rgba(244, 67, 54, 0.15);
      border-color: rgba(244, 67, 54, 0.4);
    }

    /* Cycle 3 Feature 3: Rich tooltip system */
    .rich-tooltip {
      position: fixed;
      background: var(--gray-130);
      color: white;
      padding: 8px 12px;
      border-radius: var(--radius);
      font-size: 13px;
      font-weight: 500;
      pointer-events: none;
      z-index: 10000;
      opacity: 0;
      transition: opacity 0.15s ease;
      white-space: nowrap;
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.25);
      max-width: 280px;
    }

    .rich-tooltip.visible {
      opacity: 1;
    }

    .rich-tooltip-content {
      display: flex;
      align-items: center;
      gap: var(--space-s);
    }

    .rich-tooltip-shortcut {
      background: rgba(255, 255, 255, 0.2);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 11px;
      font-family: -apple-system, BlinkMacSystemFont, "SF Mono", Monaco, monospace;
      margin-left: 8px;
    }

    body.dark .rich-tooltip {
      background: var(--gray-20);
      border: 1px solid var(--gray-40);
    }

    /* Cycle 4 Feature 2: Personality typing indicator */
    .loading-personality {
      display: flex;
      flex-direction: column;
      align-items: flex-start;
      gap: var(--space-s);
      padding: var(--space-m);
      margin: var(--space-m) 0;
      background: white;
      border: 1px solid var(--gray-20);
      border-radius: var(--radius);
      max-width: 280px;
      animation: messageSlideInBounce 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
    }

    body.dark .loading-personality {
      background: var(--gray-30);
      border-color: var(--gray-40);
    }

    .loading-personality .typing-dots {
      display: flex;
      gap: 4px;
    }

    .loading-personality .typing-dots span {
      width: 8px;
      height: 8px;
      background: var(--primary);
      border-radius: 50%;
      animation: typingDot 1.4s ease-in-out infinite;
    }

    .loading-personality .typing-dots span:nth-child(1) { animation-delay: 0s; }
    .loading-personality .typing-dots span:nth-child(2) { animation-delay: 0.2s; }
    .loading-personality .typing-dots span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes typingDot {
      0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
      30% { transform: translateY(-8px); opacity: 1; }
    }

    .loading-personality .typing-message {
      font-size: 13px;
      color: var(--gray-60);
      font-style: italic;
      transition: opacity 0.2s ease;
    }
  </style>
</head>

<body>
  <!-- Skip to Main Content Link - Cycle 12 Accessibility -->
  <a href="#user-input" class="skip-link">Skip to chat input</a>

  <!-- Continuous Listening Mode Indicator -->
  <div class="continuous-listening-indicator" id="continuous-listening-indicator">
    <i class="fas fa-microphone"></i>
    <span id="continuous-listening-text">Listening...</span>
    <div class="listening-dots">
      <span></span>
      <span></span>
      <span></span>
    </div>
  </div>

  <!-- Login Page -->
  <div id="login-page" class="login-container">
    <div class="login-box">
      <div class="login-header">
        <div class="login-logo">
          <i class="fas fa-robot"></i>
        </div>
        <h1>Welcome Back</h1>
        <p>Sign in to continue your conversations</p>
      </div>

      <form id="login-form">
        <div class="form-group">
          <label for="username">Username</label>
          <input type="text" id="username" placeholder="Enter your username" required autocomplete="username" autocapitalize="off" />
        </div>
        <button type="submit" class="login-button">
          <i class="fas fa-sign-in-alt" style="margin-right: 8px;"></i>Sign In
        </button>
      </form>

      <div class="login-divider">
        <span>or</span>
      </div>

      <div class="login-actions">
        <button class="login-action-btn" id="login-import-rappid">
          <i class="fas fa-file-import"></i>
          Import RAPPID
        </button>
        <button class="login-action-btn" id="login-export-rappid">
          <i class="fas fa-file-export"></i>
          Export RAPPID
        </button>
      </div>

      <div class="user-list">
        <div class="user-list-header">
          <h3>Recent Users</h3>
          <span id="user-count"></span>
        </div>
        <div id="recent-users"></div>
      </div>

      <div class="login-footer">
        <p>Powered by <a href="#">Copilot Agent 365</a></p>
      </div>
    </div>
  </div>
  
  <!-- Hidden RAPPID file input for login page -->
  <input type="file" id="login-rappid-input" accept=".json" style="display: none;" />

  <!-- RAPPID Preview Modal -->
  <div class="rappid-preview-overlay" id="rappid-preview-overlay">
    <div class="rappid-preview-modal">
      <div class="rappid-preview-header">
        <div class="rappid-preview-icon">
          <i class="fas fa-file-import"></i>
        </div>
        <div class="rappid-preview-title">
          <h2>Import RAPPID Backup</h2>
          <p id="rappid-preview-filename">Preview your settings before importing</p>
        </div>
      </div>
      <div class="rappid-preview-body" id="rappid-preview-body">
        <!-- Dynamic content -->
      </div>
      <div class="rappid-preview-footer">
        <button class="rappid-preview-cancel" id="rappid-preview-cancel">
          <i class="fas fa-times"></i>
          Cancel
        </button>
        <button class="rappid-preview-import" id="rappid-preview-confirm">
          <i class="fas fa-check"></i>
          Import All
        </button>
      </div>
    </div>
  </div>

  <!-- Main App -->
  <div id="app" class="app-container hidden">
    <!-- Header -->
    <header class="header">
      <div class="header-left">
        <button class="header-button" id="sidebar-toggle" aria-label="Toggle chat history sidebar">
          <i class="fas fa-bars" aria-hidden="true"></i>
        </button>
        <h1 class="header-title">
          <span id="current-username">Chat</span>
        </h1>
        <div class="voice-indicator" id="voice-indicator">
          <i class="fas fa-volume-up"></i>
          <span>Speaking...</span>
        </div>
      </div>
      <div class="header-actions">
        <button class="header-button" id="archive-chat" aria-label="Archive current chat">
          <i class="fas fa-archive" aria-hidden="true"></i>
        </button>
        <button class="header-button" id="theme-toggle" aria-label="Toggle dark mode">
          <i class="fas fa-moon" aria-hidden="true"></i>
        </button>
        <button class="header-button" id="logout" aria-label="Logout">
          <i class="fas fa-sign-out-alt" aria-hidden="true"></i>
        </button>
      </div>
    </header>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
      <div class="sidebar-header">
        <h2>Chat Library</h2>
        <button class="input-button" id="new-chat" aria-label="Create new chat">
          <i class="fas fa-plus" aria-hidden="true"></i>
        </button>
      </div>
      <div class="sidebar-tabs">
        <button class="sidebar-tab active" data-tab="active">Active</button>
        <button class="sidebar-tab" data-tab="archived">Archived</button>
      </div>
      <div class="chat-list" id="chat-list-active"></div>
      <div class="chat-list hidden" id="chat-list-archived"></div>
    </aside>
    <div class="sidebar-overlay" id="sidebar-overlay"></div>

    <!-- Chat Container -->
    <main class="chat-container" role="main" aria-label="Chat interface">
      <div class="chat-messages-wrapper">
        <div class="chat-messages" id="chat-messages" role="log" aria-live="polite" aria-label="Chat conversation">
          <!-- Loading Indicator will be appended here dynamically -->
        </div>
      </div>
    </main>

    <!-- Input Container -->
    <div class="input-container" id="input-container" role="form" aria-label="Message input">
      <button class="input-button secondary" id="upload-image" aria-label="Upload image">
        <i class="fas fa-image" aria-hidden="true"></i>
      </button>
      <button class="input-button voice-button" id="voice-toggle" aria-label="Start voice input">
        <i class="fas fa-microphone" aria-hidden="true"></i>
      </button>
      <div class="input-wrapper">
        <div class="mention-dropdown" id="mention-dropdown" role="listbox" aria-label="Endpoint suggestions" aria-live="polite" aria-atomic="true"></div>
        <div class="image-preview-container" id="image-preview-container"></div>
        <textarea class="input-field" id="user-input" placeholder="Type a message... (Enter to send, Shift+Enter for new line)" rows="1" aria-label="Message input field" inputmode="text" autocomplete="off" autocorrect="off" spellcheck="false"></textarea>
      </div>
      <button class="input-button" id="send-button" aria-label="Send message">
        <i class="fas fa-paper-plane" aria-hidden="true"></i>
      </button>
    </div>

    <!-- Float Buttons - Order: bottom to top (menu, prompt library, voice mode, delete) -->
    <div class="float-buttons" role="group" aria-label="Quick actions">
      <button class="fab menu" id="menu-toggle" aria-label="Open quick actions menu" aria-expanded="false">
        <i class="fas fa-plus" aria-hidden="true"></i>
      </button>
      <button class="fab prompt-lib" id="prompt-library-btn-fab" aria-label="Open power prompts library">
        <i class="fas fa-bolt" aria-hidden="true"></i>
      </button>
      <button class="fab voice-mode" id="voice-mode-fab" aria-label="Toggle voice mode (V)" title="Voice Mode (V)">
        <i class="fas fa-headset" aria-hidden="true"></i>
      </button>
      <button class="fab secondary" id="clear-chat" aria-label="Clear current chat">
        <i class="fas fa-trash" aria-hidden="true"></i>
      </button>
    </div>

    <!-- Scroll to Bottom Button (Cycle 2 Feature 1) -->
    <button class="scroll-to-bottom" id="scroll-to-bottom" aria-label="Scroll to bottom of chat">
      <i class="fas fa-chevron-down" aria-hidden="true"></i>
    </button>

    <!-- Keyboard Shortcuts Modal (Cycle 2 Feature 2) -->
    <div class="shortcuts-modal" id="shortcuts-modal">
      <div class="shortcuts-container">
        <div class="shortcuts-header">
          <div class="shortcuts-title">
            <i class="fas fa-keyboard"></i>
            <span>Keyboard Shortcuts</span>
          </div>
          <!-- Cycle 30: Added aria-label for accessibility -->
          <button class="shortcuts-close" id="shortcuts-close" aria-label="Close keyboard shortcuts">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="shortcuts-grid">
          <div class="shortcut-item">
            <span class="shortcut-label">Focus input</span>
            <div class="shortcut-keys">
              <span class="shortcut-key"></span>
              <span class="shortcut-key">K</span>
            </div>
          </div>
          <div class="shortcut-item">
            <span class="shortcut-label">New chat</span>
            <div class="shortcut-keys">
              <span class="shortcut-key"></span>
              <span class="shortcut-key">N</span>
            </div>
          </div>
          <div class="shortcut-item">
            <span class="shortcut-label">Prompt library</span>
            <div class="shortcut-keys">
              <span class="shortcut-key"></span>
              <span class="shortcut-key">P</span>
            </div>
          </div>
          <div class="shortcut-item">
            <span class="shortcut-label">Toggle sidebar</span>
            <div class="shortcut-keys">
              <span class="shortcut-key"></span>
              <span class="shortcut-key">B</span>
            </div>
          </div>
          <div class="shortcut-item">
            <span class="shortcut-label">Toggle dark mode</span>
            <div class="shortcut-keys">
              <span class="shortcut-key"></span>
              <span class="shortcut-key">D</span>
            </div>
          </div>
          <div class="shortcut-item">
            <span class="shortcut-label">Settings</span>
            <div class="shortcut-keys">
              <span class="shortcut-key"></span>
              <span class="shortcut-key">,</span>
            </div>
          </div>

          <div class="shortcuts-section">
            <div class="shortcuts-section-title">Quick Actions</div>
            <div class="shortcut-item">
              <span class="shortcut-label">Focus input</span>
              <div class="shortcut-keys">
                <span class="shortcut-key">/</span>
              </div>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-label">Show shortcuts</span>
              <div class="shortcut-keys">
                <span class="shortcut-key">?</span>
              </div>
            </div>
            <div class="shortcut-item">
              <span class="shortcut-label">Close everything</span>
              <div class="shortcut-keys">
                <span class="shortcut-key">Esc</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Menu Items - Enhanced Design -->
    <div class="menu-items" id="menu-items" role="menu" aria-label="Quick actions menu">
      <!-- Chat Section -->
      <div class="menu-section">
        <div class="menu-section-title">Current Chat</div>
        <div class="menu-item" id="export-chat" role="menuitem" tabindex="-1">
          <div class="menu-item-icon blue">
            <i class="fas fa-download" aria-hidden="true"></i>
          </div>
          <div class="menu-item-info">
            <div class="menu-item-title">Export Chat</div>
            <div class="menu-item-desc">Save this conversation as JSON</div>
          </div>
          <i class="fas fa-chevron-right menu-item-arrow"></i>
        </div>
        <div class="menu-item" id="import-chat" role="menuitem" tabindex="-1">
          <div class="menu-item-icon green">
            <i class="fas fa-upload" aria-hidden="true"></i>
          </div>
          <div class="menu-item-info">
            <div class="menu-item-title">Import Chat</div>
            <div class="menu-item-desc">Load a conversation from file</div>
          </div>
          <i class="fas fa-chevron-right menu-item-arrow"></i>
        </div>
      </div>

      <div class="menu-divider"></div>

      <!-- Data Section -->
      <div class="menu-section">
        <div class="menu-section-title">All Data</div>
        <div class="menu-item" id="export-all" role="menuitem" tabindex="-1">
          <div class="menu-item-icon purple">
            <i class="fas fa-database" aria-hidden="true"></i>
          </div>
          <div class="menu-item-info">
            <div class="menu-item-title">Export All Data</div>
            <div class="menu-item-desc">Backup chats, settings & preferences</div>
          </div>
          <i class="fas fa-chevron-right menu-item-arrow"></i>
        </div>
        <div class="menu-item" id="import-all" role="menuitem" tabindex="-1">
          <div class="menu-item-icon amber">
            <i class="fas fa-file-import" aria-hidden="true"></i>
          </div>
          <div class="menu-item-info">
            <div class="menu-item-title">Import Data</div>
            <div class="menu-item-desc">Restore from a backup file</div>
          </div>
          <i class="fas fa-chevron-right menu-item-arrow"></i>
        </div>
      </div>

      <div class="menu-divider"></div>

      <!-- Tools Section -->
      <div class="menu-section">
        <div class="menu-section-title">Tools</div>
        <div class="menu-item" id="time-machine" role="menuitem" tabindex="-1">
          <div class="menu-item-icon purple">
            <i class="fas fa-history" aria-hidden="true"></i>
          </div>
          <div class="menu-item-info">
            <div class="menu-item-title">Time Machine</div>
            <div class="menu-item-desc">Replay conversations step by step</div>
          </div>
          <i class="fas fa-chevron-right menu-item-arrow"></i>
        </div>
        <div class="menu-item" id="settings" role="menuitem" tabindex="-1">
          <div class="menu-item-icon slate">
            <i class="fas fa-cog" aria-hidden="true"></i>
          </div>
          <div class="menu-item-info">
            <div class="menu-item-title">Settings</div>
            <div class="menu-item-desc">Customize your experience</div>
          </div>
          <i class="fas fa-chevron-right menu-item-arrow"></i>
        </div>
      </div>
    </div>

    <!-- Prompt Library Modal -->
    <div class="prompt-library-modal" id="prompt-library-modal">
      <div class="prompt-library-container">
        <div class="prompt-library-header">
          <div class="prompt-library-title">
            <i class="fas fa-bolt"></i>
            <div>
              <h2>Power Prompts Library</h2>
              <div class="prompt-library-subtitle">Mind-blowing prompts for simulated M365 integration</div>
            </div>
          </div>
          <button class="prompt-library-close" id="prompt-library-close" aria-label="Close prompt library">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="prompt-library-filters">
          <button class="prompt-filter-btn active" data-filter="all">All Prompts</button>
          <button class="prompt-filter-btn" data-filter="email">Email Intelligence</button>
          <button class="prompt-filter-btn" data-filter="relationships">Relationships</button>
          <button class="prompt-filter-btn" data-filter="calendar">Calendar & Time</button>
          <button class="prompt-filter-btn" data-filter="analytics">Analytics</button>
          <button class="prompt-filter-btn" data-filter="self">Self-Awareness</button>
        </div>
        <div class="prompt-library-content" id="prompt-library-content">
          <!-- Prompt cards will be dynamically inserted here -->
        </div>
      </div>
    </div>

    <!-- Drop Zone -->
    <div class="drop-zone" id="drop-zone">
      <div class="drop-zone-content">
        <i class="fas fa-cloud-upload-alt"></i>
        <p>Drop files here to import</p>
      </div>
    </div>

    <!-- Voice Preview Overlay -->
    <div class="voice-preview-overlay" id="voice-preview-overlay">
      <div class="voice-preview-container">
        <div class="voice-preview-header">
          <div class="voice-preview-status">
            <div class="voice-preview-status-icon listening" id="voice-preview-status-icon">
              <i class="fas fa-microphone"></i>
            </div>
            <div class="voice-preview-status-text">
              <span class="voice-preview-title" id="voice-preview-title">Listening...</span>
              <span class="voice-preview-subtitle" id="voice-preview-subtitle">Speak now</span>
            </div>
          </div>
          <button class="voice-preview-close" id="voice-preview-close">
            <i class="fas fa-times"></i>
          </button>
        </div>
        <div class="voice-preview-body">
          <textarea
            class="voice-preview-text"
            id="voice-preview-text"
            placeholder="Your speech will appear here..."
            rows="4"
          ></textarea>
          <div class="voice-preview-waveform" id="voice-preview-waveform">
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
            <div class="waveform-bar"></div>
          </div>
          <div class="voice-preview-hint">
            <i class="fas fa-edit"></i>
            <span>Click text to edit before sending</span>
          </div>
        </div>
        <div class="voice-preview-footer">
          <button class="voice-preview-btn cancel" id="voice-preview-cancel">
            <i class="fas fa-times"></i>
            <span>Cancel</span>
          </button>
          <button class="voice-preview-btn retry" id="voice-preview-retry">
            <i class="fas fa-redo"></i>
            <span>Retry</span>
          </button>
          <button class="voice-preview-btn send" id="voice-preview-send">
            <i class="fas fa-paper-plane"></i>
            <span>Send</span>
          </button>
        </div>
      </div>
    </div>

    <!-- Push-to-Talk Voice Mode Panel -->
    <div class="voice-mode-panel" id="voice-mode-panel">
      <div class="voice-mode-header">
        <h3><i class="fas fa-headset"></i> Voice Mode</h3>
        <button class="voice-mode-close" id="voice-mode-close">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="voice-mode-body">
        <div class="voice-mode-status">
          <div class="voice-mode-status-text" id="voice-mode-status-text">Hold button or press Space to talk</div>
          <div class="voice-mode-hotkey-hint">
            <kbd>Space</kbd> or <kbd>V</kbd> to toggle panel
          </div>
        </div>

        <!-- Recording Indicator -->
        <div class="ptt-recording-indicator" id="ptt-recording-indicator">
          <i class="fas fa-circle"></i>
          <span>Recording</span>
          <span class="ptt-recording-time" id="ptt-recording-time">0:00</span>
        </div>

        <!-- Waveform Visualization -->
        <div class="ptt-waveform" id="ptt-waveform">
          <div class="ptt-waveform-bar"></div>
          <div class="ptt-waveform-bar"></div>
          <div class="ptt-waveform-bar"></div>
          <div class="ptt-waveform-bar"></div>
          <div class="ptt-waveform-bar"></div>
          <div class="ptt-waveform-bar"></div>
          <div class="ptt-waveform-bar"></div>
          <div class="ptt-waveform-bar"></div>
          <div class="ptt-waveform-bar"></div>
          <div class="ptt-waveform-bar"></div>
        </div>

        <!-- Push-to-Talk Button -->
        <div class="ptt-button-container">
          <button class="ptt-button" id="ptt-button" title="Hold to record">
            <i class="fas fa-microphone"></i>
          </button>
        </div>

        <!-- Live Transcript Preview -->
        <div class="ptt-transcript-preview empty" id="ptt-transcript-preview">
          Your speech will appear here...
        </div>

        <!-- Recent Recordings Section -->
        <div class="ptt-recordings-section">
          <div class="ptt-recordings-header">
            <h4><i class="fas fa-history"></i> Recent Recordings</h4>
            <button class="ptt-clear-recordings" id="ptt-clear-recordings">Clear All</button>
          </div>
          <div class="ptt-recordings-list" id="ptt-recordings-list">
            <div class="ptt-no-recordings">No recordings yet</div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Settings Modal -->
  <div class="modal" id="settings-modal">
    <div class="modal-content" style="max-width: 580px;">
      <div class="modal-header">
        <h2>Settings</h2>
        <button class="modal-close" id="settings-close" aria-label="Close settings">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="modal-body">
        <!-- Settings Tabs -->
        <div class="settings-tabs">
          <button class="settings-tab active" data-tab="general"><i class="fas fa-cog"></i><span>General</span></button>
          <button class="settings-tab" data-tab="voice"><i class="fas fa-microphone"></i><span>Voice</span></button>
          <button class="settings-tab" data-tab="endpoints"><i class="fas fa-server"></i><span>Endpoints</span></button>
          <button class="settings-tab" data-tab="data"><i class="fas fa-database"></i><span>Data</span></button>
        </div>

        <!-- General Tab -->
        <div class="settings-tab-content active" id="settings-tab-general">
          <div class="settings-section">
            <h3>Appearance</h3>
            <div class="settings-item">
              <label for="dark-mode-toggle">Dark Mode</label>
              <div class="toggle-switch" id="dark-mode-toggle" role="switch" aria-checked="false" aria-label="Toggle dark mode" tabindex="0"></div>
            </div>
          </div>
          <div class="settings-section">
            <h3>Backup & Restore</h3>
            <div class="settings-import-export">
              <button class="button button-secondary" id="export-settings"><i class="fas fa-download"></i>Export</button>
              <button class="button button-secondary" id="import-settings"><i class="fas fa-upload"></i>Import</button>
            </div>
          </div>
        </div>

        <!-- Voice Tab -->
        <div class="settings-tab-content" id="settings-tab-voice">
          <div class="settings-section">
            <h3>Sound & Voice</h3>
            <div class="settings-item">
              <label for="sound-toggle">Enable Sound Effects</label>
              <div class="toggle-switch" id="sound-toggle" role="switch" aria-checked="false" aria-label="Toggle sound effects" tabindex="0"></div>
            </div>
            <div class="settings-item">
              <label for="voice-enabled-toggle">Enable Voice Response</label>
              <div class="toggle-switch" id="voice-enabled-toggle" role="switch" aria-checked="false" aria-label="Toggle voice response" tabindex="0"></div>
            </div>
            <div class="settings-item">
              <label for="auto-speak-toggle">Auto-speak Responses</label>
              <div class="toggle-switch" id="auto-speak-toggle" role="switch" aria-checked="false" aria-label="Toggle auto-speak" tabindex="0"></div>
            </div>
          </div>
          <div class="settings-section">
            <h3>Azure TTS</h3>
            <div class="form-group">
              <label for="azure-tts-key">API Key</label>
              <input type="password" id="azure-tts-key" placeholder="Enter your Azure TTS API key" />
            </div>
            <div class="form-group">
              <label for="tts-voice-select">Voice</label>
              <select id="tts-voice-select">
                <option value="en-US-JennyNeural">Jenny (Female)</option>
                <option value="en-US-GuyNeural">Guy (Male)</option>
                <option value="en-US-AriaNeural">Aria (Female)</option>
                <option value="en-US-DavisNeural">Davis (Male)</option>
                <option value="en-US-AmberNeural">Amber (Female)</option>
                <option value="en-US-JasonNeural">Jason (Male)</option>
                <option value="en-GB-SoniaNeural">Sonia (British Female)</option>
                <option value="en-GB-RyanNeural">Ryan (British Male)</option>
              </select>
            </div>
          </div>
        </div>

        <!-- Endpoints Tab -->
        <div class="settings-tab-content" id="settings-tab-endpoints">
          <div class="endpoint-search-container">
            <i class="fas fa-search endpoint-search-icon"></i>
            <input type="text" class="endpoint-search" id="endpoint-search" placeholder="Search endpoints..." />
          </div>
          <div class="endpoint-list" id="endpoint-list"></div>
          <button class="endpoint-add-btn" id="add-endpoint"><i class="fas fa-plus"></i>Add Endpoint</button>
          <div class="endpoint-quick-actions">
            <button class="endpoint-quick-action" id="test-all-endpoints"><i class="fas fa-bolt"></i>Test All</button>
            <button class="endpoint-quick-action" id="add-local-endpoint"><i class="fas fa-laptop"></i>Add Local</button>
          </div>
        </div>

        <!-- Data Tab -->
        <div class="settings-tab-content" id="settings-tab-data">
          <div class="settings-section">
            <h3>Data Management</h3>
            <p style="color: var(--gray-60); font-size: 13px; margin-bottom: var(--space-m);">Clear all stored data including chats, settings, and endpoints. This action cannot be undone.</p>
            <button class="button button-secondary" id="clear-all-data" style="background: var(--error); color: white;"><i class="fas fa-trash-alt"></i>Clear All Data</button>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button class="button button-secondary" id="cancel-settings">
          Cancel
        </button>
        <button class="button button-success" id="save-all-settings">
          <i class="fas fa-save"></i>
          Save Settings
        </button>
      </div>
    </div>
  </div>

  <!-- Endpoint Modal -->
  <div class="modal" id="endpoint-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2 id="endpoint-modal-title">Add Endpoint</h2>
        <button class="modal-close" id="endpoint-modal-close" aria-label="Close endpoint modal">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="modal-body">
        <div class="form-group">
          <label for="endpoint-name">Endpoint Name</label>
          <input type="text" id="endpoint-name" placeholder="e.g., Production Bot" />
        </div>
        <div class="form-group">
          <label for="endpoint-env">Environment</label>
          <select id="endpoint-env" style="width: 100%; padding: 8px; border: 1px solid var(--gray-40); border-radius: 4px;">
            <option value="production">Production</option>
            <option value="staging">Staging</option>
            <option value="development">Development</option>
            <option value="local">Local</option>
          </select>
        </div>
        <div class="form-group">
          <label for="endpoint-url">Azure Function URL</label>
          <input type="text" id="endpoint-url" placeholder="https://your-function.azurewebsites.net/api/..." />
        </div>
        <div class="form-group">
          <label for="endpoint-key">Function Key (Optional)</label>
          <input type="password" id="endpoint-key" placeholder="Your function key" />
          <small style="color: var(--gray-60); font-size: 11px; margin-top: 4px; display: block;">Leave empty for local development</small>
        </div>
        <div class="form-group">
          <label for="endpoint-guid">User GUID</label>
          <input type="text" id="endpoint-guid" placeholder="c0p110t0-aaaa-bbbb-cccc-123456789abc" />
        </div>
      </div>
      <div class="modal-footer">
        <button class="button button-secondary" id="cancel-endpoint">
          Cancel
        </button>
        <button class="button button-info" id="test-endpoint" style="background: var(--info, #2196f3);">
          <i class="fas fa-bolt"></i>
          Test
        </button>
        <button class="button button-success" id="save-endpoint">
          <i class="fas fa-save"></i>
          Save Endpoint
        </button>
      </div>
    </div>
  </div>

  <!-- Time Machine Modal -->
  <div class="modal" id="time-machine-modal">
    <div class="modal-content">
      <div class="modal-header">
        <h2>Time Machine</h2>
        <button class="modal-close" id="time-machine-close" aria-label="Close time machine">
          <i class="fas fa-times"></i>
        </button>
      </div>
      <div class="modal-body">
        <!-- Initial State -->
        <div id="time-machine-initial">
          <div class="time-machine-hero">
            <div class="time-machine-icon-wrapper">
              <div class="time-machine-icon">
                <i class="fas fa-history"></i>
              </div>
              <div class="time-machine-ring"></div>
            </div>
            <p class="time-machine-subtitle">Step through your conversation<br>message by message</p>
          </div>

          <div class="time-machine-stats">
            <div class="time-machine-stat">
              <div class="time-machine-stat-value" id="tm-message-count">0</div>
              <div class="time-machine-stat-label">Messages</div>
            </div>
            <div class="time-machine-stat">
              <div class="time-machine-stat-value" id="tm-duration">~0s</div>
              <div class="time-machine-stat-label">Est. Duration</div>
            </div>
          </div>

          <div class="time-machine-speed">
            <div class="time-machine-speed-label">Playback Speed</div>
            <div class="time-machine-speed-options">
              <button class="speed-option" data-speed="2000">Slow</button>
              <button class="speed-option active" data-speed="1000">Normal</button>
              <button class="speed-option" data-speed="500">Fast</button>
            </div>
          </div>

          <button class="time-machine-start-btn" id="time-machine-start">
            <i class="fas fa-play"></i>
            <span>Start Replay</span>
          </button>
        </div>

        <!-- Playback State -->
        <div class="time-machine-playback" id="time-machine-controls">
          <div class="time-machine-hero" style="padding-bottom: var(--space-m);">
            <div class="time-machine-icon-wrapper">
              <div class="time-machine-icon">
                <i class="fas fa-history"></i>
              </div>
              <div class="time-machine-ring"></div>
            </div>
          </div>

          <div class="time-machine-progress-bar">
            <div class="time-machine-progress-fill" id="tm-progress-fill"></div>
          </div>
          <div class="time-machine-progress-text">
            Message <strong id="tm-current">0</strong> of <strong id="tm-total">0</strong>
          </div>
          <span id="time-machine-progress" style="display: none;">0 / 0</span>

          <div class="time-machine-controls">
            <button class="tm-control-btn" id="time-machine-prev" title="Previous">
              <i class="fas fa-step-backward"></i>
            </button>
            <button class="tm-control-btn primary" id="time-machine-play" title="Play/Pause">
              <i class="fas fa-play"></i>
            </button>
            <button class="tm-control-btn" id="time-machine-next" title="Next">
              <i class="fas fa-step-forward"></i>
            </button>
            <button class="tm-control-btn stop" id="time-machine-stop" title="Stop">
              <i class="fas fa-stop"></i>
            </button>
          </div>

          <button class="time-machine-branch-btn" id="time-machine-branch">
            <i class="fas fa-code-branch"></i>
            <span>Continue from Here</span>
          </button>
        </div>
      </div>
    </div>
  </div>

  <!-- Hidden file inputs -->
  <input type="file" id="image-upload-input" accept="image/*" />
  <input type="file" id="chat-import-input" accept=".json" />
  <input type="file" id="data-import-input" accept=".json" />
  <input type="file" id="settings-import-input" accept=".json" />

  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.5.1/highlight.min.js"></script>

  <script>
    // Global state management
    class AppState {
      constructor() {
        this.currentUser = null;
        this.currentChatId = null;
        this.users = this.loadUsers();
        this.chats = this.loadChats();
        this.settings = this.loadSettings();
        this.endpoints = this.loadEndpoints();
        this.activeEndpointId = null;
      }

      loadUsers() {
        const users = localStorage.getItem("chatAppUsers");
        return users ? JSON.parse(users) : {};
      }

      loadChats() {
        const chats = localStorage.getItem("chatAppChats");
        return chats ? JSON.parse(chats) : {};
      }

      loadSettings() {
        const settings = localStorage.getItem("chatAppSettings");
        return settings
          ? JSON.parse(settings)
          : {
            theme: "dark",
            soundEnabled: false,
            voiceEnabled: true,
            autoSpeak: false,
            azureTTSKey: "",
            azureRegion: "eastus2",
            ttsVoiceName: "en-US-JennyNeural",
          };
      }

      loadEndpoints() {
        const endpoints = localStorage.getItem("chatAppEndpoints");
        const defaultEndpoints = {
          'default': {
            id: 'default',
            name: 'Default Bot',
            url: "https://effective-bassoon-wvrjj9qrxvcg6vr-7071.app.github.dev/api/businessinsightbot_function",
            key: "",
            guid: "c0p110t0-aaaa-bbbb-cccc-123456789abc",
            active: true
          }
        };
        return endpoints ? JSON.parse(endpoints) : defaultEndpoints;
      }

      saveUsers() {
        localStorage.setItem("chatAppUsers", JSON.stringify(this.users));
      }

      saveChats() {
        localStorage.setItem("chatAppChats", JSON.stringify(this.chats));
      }

      saveSettings() {
        localStorage.setItem(
          "chatAppSettings",
          JSON.stringify(this.settings)
        );
      }

      saveEndpoints() {
        localStorage.setItem("chatAppEndpoints", JSON.stringify(this.endpoints));
      }

      createUser(username) {
        const userId = this.generateGuid();
        const user = {
          id: userId,
          username: username,
          createdAt: new Date().toISOString(),
          lastActive: new Date().toISOString(),
          chats: [],
        };
        this.users[userId] = user;
        this.saveUsers();
        return user;
      }

      createChat(userId, title = "New Chat") {
        const chatId = this.generateGuid();
        const chat = {
          id: chatId,
          userId: userId,
          title: title,
          messages: [],
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          archived: false,
        };

        if (!this.chats[userId]) {
          this.chats[userId] = {};
        }

        this.chats[userId][chatId] = chat;
        this.users[userId].chats.push(chatId);
        this.users[userId].lastActive = new Date().toISOString();

        this.saveChats();
        this.saveUsers();

        return chat;
      }

      createBranchChat(userId, sourceChat, upToIndex) {
        const branchTitle = `${sourceChat.title} (Branch from message ${upToIndex + 1})`;
        const branchChat = this.createChat(userId, branchTitle);

        branchChat.messages = sourceChat.messages.slice(0, upToIndex + 1).map(msg => ({...msg}));
        branchChat.updatedAt = new Date().toISOString();

        this.saveChats();
        return branchChat;
      }

      updateChat(userId, chatId, updates) {
        if (this.chats[userId] && this.chats[userId][chatId]) {
          Object.assign(this.chats[userId][chatId], updates);
          this.chats[userId][chatId].updatedAt = new Date().toISOString();
          this.saveChats();
        }
      }

      getActiveChats(userId) {
        if (!this.chats[userId]) return [];
        return Object.values(this.chats[userId])
          .filter((chat) => !chat.archived)
          .sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
      }

      getArchivedChats(userId) {
        if (!this.chats[userId]) return [];
        return Object.values(this.chats[userId])
          .filter((chat) => chat.archived)
          .sort((a, b) => new Date(b.updatedAt) - new Date(a.updatedAt));
      }

      archiveChat(userId, chatId) {
        if (this.chats[userId] && this.chats[userId][chatId]) {
          this.chats[userId][chatId].archived = true;
          this.chats[userId][chatId].updatedAt = new Date().toISOString();
          this.saveChats();
        }
      }

      unarchiveChat(userId, chatId) {
        if (this.chats[userId] && this.chats[userId][chatId]) {
          this.chats[userId][chatId].archived = false;
          this.chats[userId][chatId].updatedAt = new Date().toISOString();
          this.saveChats();
        }
      }

      deleteChat(userId, chatId) {
        if (this.chats[userId] && this.chats[userId][chatId]) {
          delete this.chats[userId][chatId];
          const userChatIndex = this.users[userId].chats.indexOf(chatId);
          if (userChatIndex > -1) {
            this.users[userId].chats.splice(userChatIndex, 1);
          }
          this.saveChats();
          this.saveUsers();
        }
      }

      addEndpoint(name, url, key, guid, env = 'production') {
        const id = this.generateGuid();
        this.endpoints[id] = {
          id: id,
          name: name,
          url: url,
          key: key,
          guid: guid || "c0p110t0-aaaa-bbbb-cccc-123456789abc",
          env: env,
          active: Object.keys(this.endpoints).length === 0,
          order: Object.keys(this.endpoints).length,
          createdAt: new Date().toISOString()
        };
        this.saveEndpoints();
        return this.endpoints[id];
      }

      updateEndpoint(id, updates) {
        if (this.endpoints[id]) {
          Object.assign(this.endpoints[id], updates);
          this.saveEndpoints();
        }
      }

      deleteEndpoint(id) {
        if (this.endpoints[id]) {
          delete this.endpoints[id];
          this.saveEndpoints();
        }
      }

      setActiveEndpoint(id) {
        Object.values(this.endpoints).forEach(endpoint => {
          endpoint.active = endpoint.id === id;
        });
        this.activeEndpointId = id;
        this.saveEndpoints();
      }

      getActiveEndpoint() {
        return Object.values(this.endpoints).find(e => e.active) || Object.values(this.endpoints)[0];
      }

      getEndpointById(id) {
        return this.endpoints[id];
      }

      exportAllData() {
        return {
          users: this.users,
          chats: this.chats,
          settings: this.settings,
          endpoints: this.endpoints,
          azureTTSKey: this.settings.azureTTSKey || "",
          azureRegion: this.settings.azureRegion || "eastus2",
          ttsVoiceName: this.settings.ttsVoiceName || "en-US-JennyNeural",
          exportDate: new Date().toISOString(),
          version: "1.0",
        };
      }

      importAllData(data) {
        // Smart merge for users
        if (data.users) {
          Object.entries(data.users).forEach(([userId, user]) => {
            if (this.users[userId]) {
              // Merge user data, update lastActive
              this.users[userId] = {
                ...this.users[userId],
                ...user,
                chats: [...new Set([...(this.users[userId].chats || []), ...(user.chats || [])])]
              };
            } else {
              this.users[userId] = user;
            }
          });
        }

        // Smart merge for chats
        if (data.chats) {
          Object.entries(data.chats).forEach(([userId, userChats]) => {
            if (!this.chats[userId]) {
              this.chats[userId] = {};
            }
            Object.entries(userChats).forEach(([chatId, chat]) => {
              if (this.chats[userId][chatId]) {
                // Merge messages, dedupe by timestamp
                const existingMsgs = this.chats[userId][chatId].messages || [];
                const newMsgs = chat.messages || [];
                const msgMap = new Map();
                [...existingMsgs, ...newMsgs].forEach(msg => {
                  const key = `${msg.timestamp}-${msg.role}`;
                  if (!msgMap.has(key)) msgMap.set(key, msg);
                });
                this.chats[userId][chatId] = {
                  ...this.chats[userId][chatId],
                  ...chat,
                  messages: Array.from(msgMap.values()).sort((a, b) =>
                    new Date(a.timestamp) - new Date(b.timestamp)
                  )
                };
              } else {
                this.chats[userId][chatId] = chat;
              }
            });
          });
        }

        // Merge settings
        if (data.settings) {
          this.settings = { ...this.settings, ...data.settings };
        }

        // Smart merge for endpoints
        if (data.endpoints) {
          Object.entries(data.endpoints).forEach(([id, endpoint]) => {
            if (this.endpoints[id]) {
              this.endpoints[id] = { ...this.endpoints[id], ...endpoint };
            } else {
              this.endpoints[id] = endpoint;
            }
          });
        }

        // Handle RAPPID top-level TTS fields
        if (data.azureTTSKey !== undefined && data.azureTTSKey !== "") {
          this.settings.azureTTSKey = data.azureTTSKey;
        }
        if (data.azureRegion !== undefined && data.azureRegion !== "") {
          this.settings.azureRegion = data.azureRegion;
        }
        if (data.ttsVoiceName !== undefined && data.ttsVoiceName !== "") {
          this.settings.ttsVoiceName = data.ttsVoiceName;
        }

        this.saveUsers();
        this.saveChats();
        this.saveSettings();
        this.saveEndpoints();
      }

      exportSettings() {
        // RAPPID-compatible settings export
        return {
          rappid: true,
          backupType: "RAPPID Settings Backup",
          endpoints: this.endpoints,
          azureTTSKey: this.settings.azureTTSKey || "",
          azureRegion: this.settings.azureRegion || "eastus2",
          ttsVoiceName: this.settings.ttsVoiceName || "en-US-JennyNeural",
          exportDate: new Date().toISOString(),
          version: "1.0"
        };
      }

      importSettings(settingsData) {
        // Handle RAPPID format
        if (settingsData.azureTTSKey !== undefined) {
          this.settings.azureTTSKey = settingsData.azureTTSKey;
        }
        if (settingsData.azureRegion !== undefined) {
          this.settings.azureRegion = settingsData.azureRegion;
        }
        if (settingsData.ttsVoiceName !== undefined) {
          this.settings.ttsVoiceName = settingsData.ttsVoiceName;
        }

        // Smart merge endpoints
        if (settingsData.endpoints !== undefined) {
          Object.entries(settingsData.endpoints).forEach(([id, endpoint]) => {
            if (this.endpoints[id]) {
              // Merge individual endpoint properties
              this.endpoints[id] = { ...this.endpoints[id], ...endpoint };
            } else {
              // Add new endpoint
              this.endpoints[id] = endpoint;
            }
          });

          // Ensure only one endpoint is active (from imported data)
          const importedActive = Object.values(settingsData.endpoints).find(e => e.active);
          if (importedActive) {
            Object.keys(this.endpoints).forEach(id => {
              this.endpoints[id].active = (id === importedActive.id);
            });
          }

          this.saveEndpoints();
        }

        this.saveSettings();
      }

      clearAllData() {
        localStorage.removeItem("chatAppUsers");
        localStorage.removeItem("chatAppChats");
        localStorage.removeItem("chatAppSettings");
        localStorage.removeItem("chatAppEndpoints");
        localStorage.removeItem("lastUserId");

        this.users = {};
        this.chats = {};
        this.settings = {
          theme: "dark",
          soundEnabled: false,
          voiceEnabled: true,
          autoSpeak: false,
          azureTTSKey: "",
          azureRegion: "eastus2",
          ttsVoiceName: "en-US-JennyNeural",
        };
        this.endpoints = {
          'default': {
            id: 'default',
            name: 'Default Bot',
            url: "",
            key: "",
            guid: "c0p110t0-aaaa-bbbb-cccc-123456789abc",
            active: true
          }
        };
      }

      generateGuid() {
        return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
          /[xy]/g,
          function (c) {
            const r = (Math.random() * 16) | 0;
            const v = c === "x" ? r : (r & 0x3) | 0x8;
            return v.toString(16);
          }
        );
      }
    }

    // Audio Cache Manager - Stores TTS audio in IndexedDB for replay
    class AudioCacheManager {
      constructor() {
        this.dbName = 'ttsAudioCache';
        this.storeName = 'audioBlobs';
        this.db = null;
        this.initPromise = this.initDB();
      }

      async initDB() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, 1);

          request.onerror = () => {
            console.error('Failed to open IndexedDB for audio cache');
            reject(request.error);
          };

          request.onsuccess = () => {
            this.db = request.result;
            resolve(this.db);
          };

          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(this.storeName)) {
              const store = db.createObjectStore(this.storeName, { keyPath: 'id' });
              store.createIndex('timestamp', 'timestamp', { unique: false });
            }
          };
        });
      }

      async ensureDB() {
        if (!this.db) {
          await this.initPromise;
        }
        return this.db;
      }

      generateCacheKey(text, voiceName) {
        const str = `${text}:${voiceName}`;
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = ((hash << 5) - hash) + char;
          hash = hash & hash;
        }
        return `tts_${Math.abs(hash).toString(36)}`;
      }

      async store(cacheKey, audioBlob, metadata = {}) {
        try {
          const db = await this.ensureDB();
          return new Promise((resolve, reject) => {
            const transaction = db.transaction([this.storeName], 'readwrite');
            const store = transaction.objectStore(this.storeName);

            const record = {
              id: cacheKey,
              audioBlob: audioBlob,
              timestamp: Date.now(),
              ...metadata
            };

            const request = store.put(record);
            request.onsuccess = () => resolve(cacheKey);
            request.onerror = () => reject(request.error);
          });
        } catch (error) {
          console.error('Failed to store audio in cache:', error);
          return null;
        }
      }

      async get(cacheKey) {
        try {
          const db = await this.ensureDB();
          return new Promise((resolve, reject) => {
            const transaction = db.transaction([this.storeName], 'readonly');
            const store = transaction.objectStore(this.storeName);

            const request = store.get(cacheKey);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
          });
        } catch (error) {
          console.error('Failed to get audio from cache:', error);
          return null;
        }
      }

      async has(cacheKey) {
        const record = await this.get(cacheKey);
        return !!record;
      }

      async delete(cacheKey) {
        try {
          const db = await this.ensureDB();
          return new Promise((resolve, reject) => {
            const transaction = db.transaction([this.storeName], 'readwrite');
            const store = transaction.objectStore(this.storeName);

            const request = store.delete(cacheKey);
            request.onsuccess = () => resolve(true);
            request.onerror = () => reject(request.error);
          });
        } catch (error) {
          console.error('Failed to delete audio from cache:', error);
          return false;
        }
      }

      async cleanup(maxAge = 7 * 24 * 60 * 60 * 1000) {
        try {
          const db = await this.ensureDB();
          const cutoff = Date.now() - maxAge;

          return new Promise((resolve, reject) => {
            const transaction = db.transaction([this.storeName], 'readwrite');
            const store = transaction.objectStore(this.storeName);
            const index = store.index('timestamp');

            const range = IDBKeyRange.upperBound(cutoff);
            const request = index.openCursor(range);
            let deleted = 0;

            request.onsuccess = (event) => {
              const cursor = event.target.result;
              if (cursor) {
                store.delete(cursor.primaryKey);
                deleted++;
                cursor.continue();
              } else {
                console.log(`Audio cache cleanup: removed ${deleted} old entries`);
                resolve(deleted);
              }
            };

            request.onerror = () => reject(request.error);
          });
        } catch (error) {
          console.error('Failed to cleanup audio cache:', error);
          return 0;
        }
      }
    }

    // Sound Manager
    class SoundManager {
      constructor() {
        this.audioContext = null;
        this.enabled = false;
        this.ambientEnabled = true; // Can be toggled in settings
        // Processing hum nodes
        this.processingHumNodes = null;
        this.processingHumGain = null;
        this.processingLFO = null;
        this.isProcessingHumming = false;
        // Focus hum for listening mode (brain.fm style)
        this.focusHumNodes = null;
        this.focusHumGain = null;
        this.focusLFO = null;
        this.isHumming = false;
      }

      init() {
        if (!this.audioContext) {
          this.audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
        }
      }

      setEnabled(enabled) {
        this.enabled = enabled;
        if (enabled) this.init();
      }

      setAmbientEnabled(enabled) {
        this.ambientEnabled = enabled;
        if (!enabled) this.stopAmbientSound();
      }

      async playSound(frequency = 440, duration = 0.1, type = "sine") {
        if (!this.enabled || !this.audioContext) return;

        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();

        oscillator.connect(gainNode);
        gainNode.connect(this.audioContext.destination);

        oscillator.frequency.value = frequency;
        oscillator.type = type;

        gainNode.gain.setValueAtTime(0.3, this.audioContext.currentTime);
        gainNode.gain.exponentialRampToValueAtTime(
          0.01,
          this.audioContext.currentTime + duration
        );

        oscillator.start(this.audioContext.currentTime);
        oscillator.stop(this.audioContext.currentTime + duration);
      }

      playSendSound() {
        this.playSound(523.25, 0.1);
      }

      playReceiveSound() {
        this.playSound(659.25, 0.15);
      }

      playNotificationSound() {
        this.playSound(880, 0.2);
      }

      // Ambient "still thinking" sound - gentle chime sequence
      playAmbientChime() {
        if (!this.enabled || !this.ambientEnabled || !this.audioContext) return;

        // Gentle ascending notes that cycle through a pleasant pattern
        const patterns = [
          [392, 494, 587],      // G4, B4, D5 - G major
          [440, 554, 659],      // A4, C#5, E5 - A major
          [494, 622, 740],      // B4, D#5, F#5 - B major
          [523, 659, 784],      // C5, E5, G5 - C major
        ];

        const pattern = patterns[this.ambientStep % patterns.length];
        this.ambientStep++;

        const now = this.audioContext.currentTime;

        pattern.forEach((freq, index) => {
          const oscillator = this.audioContext.createOscillator();
          const gainNode = this.audioContext.createGain();

          oscillator.connect(gainNode);
          gainNode.connect(this.audioContext.destination);

          oscillator.frequency.value = freq;
          oscillator.type = "sine";

          // Stagger the notes slightly for an arpeggio effect
          const startTime = now + (index * 0.08);
          const duration = 0.4;

          // Very gentle volume
          gainNode.gain.setValueAtTime(0, startTime);
          gainNode.gain.linearRampToValueAtTime(0.08, startTime + 0.05);
          gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

          oscillator.start(startTime);
          oscillator.stop(startTime + duration);
        });
      }

      // Start ambient sound loop while processing
      startAmbientSound() {
        if (!this.enabled || !this.ambientEnabled) return;

        this.init();
        this.ambientStep = 0;

        // Play first chime immediately
        setTimeout(() => this.playAmbientChime(), 500);

        // Then play every 4 seconds
        this.ambientInterval = setInterval(() => {
          this.playAmbientChime();
        }, 4000);
      }

      // Stop ambient sound when processing is done
      stopAmbientSound() {
        if (this.ambientInterval) {
          clearInterval(this.ambientInterval);
          this.ambientInterval = null;
        }
        this.ambientStep = 0;
      }

      // Play a completion sound when done
      playCompletionSound() {
        if (!this.enabled || !this.audioContext) return;

        const now = this.audioContext.currentTime;
        // Pleasant resolution chord: C major with higher octave
        const frequencies = [523, 659, 784, 1047]; // C5, E5, G5, C6

        frequencies.forEach((freq, index) => {
          const oscillator = this.audioContext.createOscillator();
          const gainNode = this.audioContext.createGain();

          oscillator.connect(gainNode);
          gainNode.connect(this.audioContext.destination);

          oscillator.frequency.value = freq;
          oscillator.type = "sine";

          const startTime = now + (index * 0.03);
          gainNode.gain.setValueAtTime(0, startTime);
          gainNode.gain.linearRampToValueAtTime(0.12, startTime + 0.02);
          gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + 0.5);

          oscillator.start(startTime);
          oscillator.stop(startTime + 0.5);
        });
      }

      // Brain.fm style focus hum - continuous concentration-enhancing drone
      // Uses layered frequencies with binaural beats and subtle modulation
      startListeningSound() {
        if (!this.enabled || !this.ambientEnabled) return;
        if (this.isHumming) return;

        this.init();
        this.isHumming = true;

        const ctx = this.audioContext;
        const now = ctx.currentTime;

        // Create stereo panner for binaural effect
        const merger = ctx.createChannelMerger(2);

        // Master gain with smooth fade-in
        this.focusHumGain = ctx.createGain();
        this.focusHumGain.gain.setValueAtTime(0, now);
        this.focusHumGain.gain.linearRampToValueAtTime(0.06, now + 2); // 2 second fade in
        this.focusHumGain.connect(ctx.destination);

        // LFO for subtle "breathing" amplitude modulation
        this.focusLFO = ctx.createOscillator();
        const lfoGain = ctx.createGain();
        this.focusLFO.frequency.value = 0.1; // Very slow breathing ~6 breaths/min
        this.focusLFO.type = "sine";
        lfoGain.gain.value = 0.015; // Subtle modulation depth
        this.focusLFO.connect(lfoGain);
        lfoGain.connect(this.focusHumGain.gain);
        this.focusLFO.start(now);

        this.focusHumNodes = [];

        // Base frequency around 90Hz (deep, grounding)
        const baseFreq = 90;

        // Binaural beat at 10Hz (alpha waves - relaxed focus)
        const binauralOffset = 10;

        // Layer 1: Deep foundation drone (left slightly lower for binaural)
        const droneLeft = ctx.createOscillator();
        const droneLeftGain = ctx.createGain();
        droneLeft.frequency.value = baseFreq;
        droneLeft.type = "sine";
        droneLeftGain.gain.value = 0.5;
        droneLeft.connect(droneLeftGain);
        droneLeftGain.connect(merger, 0, 0); // Left channel
        droneLeft.start(now);
        this.focusHumNodes.push(droneLeft);

        // Layer 1: Deep foundation drone (right slightly higher for binaural)
        const droneRight = ctx.createOscillator();
        const droneRightGain = ctx.createGain();
        droneRight.frequency.value = baseFreq + binauralOffset;
        droneRight.type = "sine";
        droneRightGain.gain.value = 0.5;
        droneRight.connect(droneRightGain);
        droneRightGain.connect(merger, 0, 1); // Right channel
        droneRight.start(now);
        this.focusHumNodes.push(droneRight);

        // Layer 2: Harmonic warmth (perfect fifth above base)
        const harmonic1 = ctx.createOscillator();
        const harmonic1Gain = ctx.createGain();
        harmonic1.frequency.value = baseFreq * 1.5; // 135Hz - fifth
        harmonic1.type = "sine";
        harmonic1Gain.gain.value = 0.2;
        harmonic1.connect(harmonic1Gain);
        harmonic1Gain.connect(merger, 0, 0);
        harmonic1Gain.connect(merger, 0, 1);
        harmonic1.start(now);
        this.focusHumNodes.push(harmonic1);

        // Layer 3: Higher shimmer (octave + slight detune for richness)
        const shimmerL = ctx.createOscillator();
        const shimmerLGain = ctx.createGain();
        shimmerL.frequency.value = baseFreq * 2 - 0.5; // Slight detune left
        shimmerL.type = "sine";
        shimmerLGain.gain.value = 0.1;
        shimmerL.connect(shimmerLGain);
        shimmerLGain.connect(merger, 0, 0);
        shimmerL.start(now);
        this.focusHumNodes.push(shimmerL);

        const shimmerR = ctx.createOscillator();
        const shimmerRGain = ctx.createGain();
        shimmerR.frequency.value = baseFreq * 2 + 0.5; // Slight detune right
        shimmerR.type = "sine";
        shimmerRGain.gain.value = 0.1;
        shimmerR.connect(shimmerRGain);
        shimmerRGain.connect(merger, 0, 1);
        shimmerR.start(now);
        this.focusHumNodes.push(shimmerR);

        // Layer 4: Sub-bass presence (half frequency)
        const subBass = ctx.createOscillator();
        const subBassGain = ctx.createGain();
        subBass.frequency.value = baseFreq * 0.5; // 45Hz sub
        subBass.type = "sine";
        subBassGain.gain.value = 0.15;
        subBass.connect(subBassGain);
        subBassGain.connect(merger, 0, 0);
        subBassGain.connect(merger, 0, 1);
        subBass.start(now);
        this.focusHumNodes.push(subBass);

        // Layer 5: Gentle pink noise texture (very subtle)
        const noiseBuffer = ctx.createBuffer(2, ctx.sampleRate * 2, ctx.sampleRate);
        for (let channel = 0; channel < 2; channel++) {
          const data = noiseBuffer.getChannelData(channel);
          let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
          for (let i = 0; i < noiseBuffer.length; i++) {
            const white = Math.random() * 2 - 1;
            // Pink noise filter
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99332 * b1 + white * 0.0750759;
            b2 = 0.96900 * b2 + white * 0.1538520;
            b3 = 0.86650 * b3 + white * 0.3104856;
            b4 = 0.55000 * b4 + white * 0.5329522;
            b5 = -0.7616 * b5 - white * 0.0168980;
            data[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
            b6 = white * 0.115926;
          }
        }

        const noiseSource = ctx.createBufferSource();
        const noiseGain = ctx.createGain();
        const noiseFilter = ctx.createBiquadFilter();
        noiseSource.buffer = noiseBuffer;
        noiseSource.loop = true;
        noiseFilter.type = "lowpass";
        noiseFilter.frequency.value = 400; // Only keep low frequencies
        noiseGain.gain.value = 0.03; // Very subtle
        noiseSource.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(merger, 0, 0);
        noiseGain.connect(merger, 0, 1);
        noiseSource.start(now);
        this.focusHumNodes.push(noiseSource);

        // Connect merger to master gain
        merger.connect(this.focusHumGain);
      }

      // Stop focus hum with smooth fade-out
      stopListeningSound() {
        if (!this.isHumming || !this.focusHumGain) return;

        const ctx = this.audioContext;
        const now = ctx.currentTime;

        // Smooth 1 second fade out
        this.focusHumGain.gain.cancelScheduledValues(now);
        this.focusHumGain.gain.setValueAtTime(this.focusHumGain.gain.value, now);
        this.focusHumGain.gain.linearRampToValueAtTime(0, now + 1);

        // Stop all nodes after fade
        setTimeout(() => {
          if (this.focusHumNodes) {
            this.focusHumNodes.forEach(node => {
              try { node.stop(); } catch(e) {}
            });
            this.focusHumNodes = null;
          }
          if (this.focusLFO) {
            try { this.focusLFO.stop(); } catch(e) {}
            this.focusLFO = null;
          }
          this.focusHumGain = null;
          this.isHumming = false;
        }, 1100);
      }
    }

    // Voice Manager
    class VoiceManager {
      constructor() {
        this.synthesis = window.speechSynthesis;
        this.recognition = null; // Keep for backward compatibility
        this.speechRecognizer = null; // Azure Speech Recognizer
        this.enabled = true;
        this.autoSpeak = false;
        this.isListening = false;
        this.isSpeaking = false;
        this.azureKey = "";
        this.azureRegion = "eastus2";
        this.voiceName = "en-US-JennyNeural";
        this.recognitionLanguage = "en-US";
        this.isSdkLoaded = false;
        this.speechSynthesizer = null;
        this.maxCharacters = 5000;
        this.audioCache = null;
        this.currentAudioElement = null;
        this.recognitionCallback = null;
        this.interimCallback = null;

        // Voice preview overlay elements
        this.voicePreviewOverlay = null;
        this.voicePreviewText = null;
        this.voicePreviewStatusIcon = null;
        this.voicePreviewTitle = null;
        this.voicePreviewSubtitle = null;
        this.voicePreviewWaveform = null;
        this.pendingText = "";

        // Audio capture for voice preview (to enable replay)
        this.previewMediaRecorder = null;
        this.previewAudioChunks = [];
        this.previewAudioStream = null;
        this.lastPreviewAudioCacheKey = null;

        this.loadSpeechSdk();
        this.initVoicePreviewHandlers();
      }

      setAudioCache(audioCache) {
        this.audioCache = audioCache;
      }

      loadSpeechSdk() {
        if (window.SpeechSDK) {
          this.isSdkLoaded = true;
          console.log("Microsoft Speech SDK already loaded");
          return;
        }

        const script = document.createElement("script");
        script.src = "https://aka.ms/csspeech/jsbrowserpackageraw";
        script.async = true;
        script.onload = () => {
          console.log("Microsoft Speech SDK loaded");
          this.isSdkLoaded = true;
        };
        script.onerror = () => {
          console.error("Failed to load Microsoft Speech SDK");
        };

        document.body.appendChild(script);
      }

      initVoicePreviewHandlers() {
        setTimeout(() => {
          this.voicePreviewOverlay = document.getElementById("voice-preview-overlay");
          this.voicePreviewText = document.getElementById("voice-preview-text");
          this.voicePreviewStatusIcon = document.getElementById("voice-preview-status-icon");
          this.voicePreviewTitle = document.getElementById("voice-preview-title");
          this.voicePreviewSubtitle = document.getElementById("voice-preview-subtitle");
          this.voicePreviewWaveform = document.getElementById("voice-preview-waveform");

          // Close button
          const closeBtn = document.getElementById("voice-preview-close");
          if (closeBtn) {
            closeBtn.addEventListener("click", () => this.cancelVoicePreview());
          }

          // Cancel button
          const cancelBtn = document.getElementById("voice-preview-cancel");
          if (cancelBtn) {
            cancelBtn.addEventListener("click", () => this.cancelVoicePreview());
          }

          // Retry button
          const retryBtn = document.getElementById("voice-preview-retry");
          if (retryBtn) {
            retryBtn.addEventListener("click", () => this.retryVoiceRecognition());
          }

          // Send button
          const sendBtn = document.getElementById("voice-preview-send");
          if (sendBtn) {
            sendBtn.addEventListener("click", () => this.sendVoicePreviewText());
          }

          // Click outside to close
          if (this.voicePreviewOverlay) {
            this.voicePreviewOverlay.addEventListener("click", (e) => {
              if (e.target === this.voicePreviewOverlay) {
                this.cancelVoicePreview();
              }
            });
          }
        }, 100);
      }

      showVoicePreview() {
        if (this.voicePreviewOverlay) {
          this.voicePreviewOverlay.classList.add("active");
          this.pendingText = "";
          if (this.voicePreviewText) {
            this.voicePreviewText.value = "";
          }
          this.setVoicePreviewStatus("listening");
        }
      }

      hideVoicePreview() {
        if (this.voicePreviewOverlay) {
          this.voicePreviewOverlay.classList.remove("active");
        }
        this.pendingText = "";
      }

      setVoicePreviewStatus(status) {
        if (!this.voicePreviewStatusIcon) return;

        // Remove all status classes
        this.voicePreviewStatusIcon.classList.remove("listening", "processing", "ready");

        switch (status) {
          case "listening":
            this.voicePreviewStatusIcon.classList.add("listening");
            this.voicePreviewStatusIcon.innerHTML = '<i class="fas fa-microphone"></i>';
            if (this.voicePreviewTitle) this.voicePreviewTitle.textContent = "Listening...";
            if (this.voicePreviewSubtitle) this.voicePreviewSubtitle.textContent = "Speak now";
            if (this.voicePreviewWaveform) this.voicePreviewWaveform.style.display = "flex";
            break;
          case "processing":
            this.voicePreviewStatusIcon.classList.add("processing");
            this.voicePreviewStatusIcon.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
            if (this.voicePreviewTitle) this.voicePreviewTitle.textContent = "Processing...";
            if (this.voicePreviewSubtitle) this.voicePreviewSubtitle.textContent = "Converting speech to text";
            if (this.voicePreviewWaveform) this.voicePreviewWaveform.style.display = "none";
            break;
          case "ready":
            this.voicePreviewStatusIcon.classList.add("ready");
            this.voicePreviewStatusIcon.innerHTML = '<i class="fas fa-check"></i>';
            if (this.voicePreviewTitle) this.voicePreviewTitle.textContent = "Ready to send";
            if (this.voicePreviewSubtitle) this.voicePreviewSubtitle.textContent = "Edit text or click Send";
            if (this.voicePreviewWaveform) this.voicePreviewWaveform.style.display = "none";
            break;
          case "error":
            this.voicePreviewStatusIcon.classList.add("ready");
            this.voicePreviewStatusIcon.innerHTML = '<i class="fas fa-exclamation-triangle"></i>';
            if (this.voicePreviewTitle) this.voicePreviewTitle.textContent = "Recognition failed";
            if (this.voicePreviewSubtitle) this.voicePreviewSubtitle.textContent = "Click Retry to try again";
            if (this.voicePreviewWaveform) this.voicePreviewWaveform.style.display = "none";
            break;
        }
      }

      updateVoicePreviewText(text, isInterim = false) {
        if (this.voicePreviewText) {
          this.voicePreviewText.value = text;
          this.voicePreviewText.style.fontStyle = isInterim ? "italic" : "normal";
          this.voicePreviewText.style.opacity = isInterim ? "0.8" : "1";
        }
        this.pendingText = text;
      }

      cancelVoicePreview() {
        // Stop and discard audio capture without caching
        this.discardPreviewAudioCapture();
        this.stopListening();
        this.hideVoicePreview();
      }

      // Discard audio capture without caching (for cancel)
      discardPreviewAudioCapture() {
        if (this.previewMediaRecorder && this.previewMediaRecorder.state !== "inactive") {
          this.previewMediaRecorder.stop();
        }
        if (this.previewAudioStream) {
          this.previewAudioStream.getTracks().forEach(track => track.stop());
          this.previewAudioStream = null;
        }
        this.previewAudioChunks = [];
        this.lastPreviewAudioCacheKey = null;
      }

      retryVoiceRecognition() {
        // Discard current audio capture before retrying
        this.discardPreviewAudioCapture();
        this.stopListening();
        this.pendingText = "";
        if (this.voicePreviewText) {
          this.voicePreviewText.value = "";
        }
        this.setVoicePreviewStatus("listening");
        // Start listening again with preview mode
        this.startListeningWithPreview();
      }

      async sendVoicePreviewText() {
        const text = this.voicePreviewText ? this.voicePreviewText.value.trim() : this.pendingText.trim();

        if (text) {
          // Stop audio capture and get cache key
          const audioCacheKey = await this.stopPreviewAudioCapture(text);

          // Track that this message was from voice input, including audio cache key
          if (window.pendingVoiceInput) {
            window.pendingVoiceInput.set(text, audioCacheKey);
          }

          // Put text in input field and send
          const userInput = document.getElementById("user-input");
          if (userInput) {
            userInput.value = text;
          }

          // Trigger send
          if (typeof sendMessage === "function") {
            sendMessage();
          } else if (window.ui && typeof window.ui.sendMessage === "function") {
            window.ui.sendMessage();
          } else {
            // Fallback: click the send button
            const sendBtn = document.getElementById("send-btn");
            if (sendBtn) sendBtn.click();
          }
        } else {
          // No text - just stop audio capture without caching
          await this.stopPreviewAudioCapture(null);
        }

        this.hideVoicePreview();
        this.stopListening();
      }

      startListeningWithPreview() {
        if (this.isListening) return;

        // Check if Azure STT is available
        if (!this.isAzureSTTAvailable()) {
          console.warn("Azure Speech-to-Text not configured. Please add Azure Speech key in settings.");
          ui.showNotification("Voice input requires Azure Speech key in settings", "warning");
          return;
        }

        // Show the preview overlay
        this.showVoicePreview();

        // Start audio capture for replay functionality
        this.startPreviewAudioCapture();

        // Create new recognizer for each session
        this.speechRecognizer = this.createSpeechRecognizer();

        if (!this.speechRecognizer) {
          console.error("Failed to create speech recognizer");
          ui.showNotification("Failed to initialize voice input", "error");
          this.setVoicePreviewStatus("error");
          return;
        }

        // Set up event handlers for preview mode
        this.speechRecognizer.recognizing = (s, e) => {
          if (e.result.reason === window.SpeechSDK.ResultReason.RecognizingSpeech) {
            console.log("Recognizing:", e.result.text);
            this.updateVoicePreviewText(e.result.text, true);
          }
        };

        this.speechRecognizer.recognized = (s, e) => {
          if (e.result.reason === window.SpeechSDK.ResultReason.RecognizedSpeech) {
            console.log("Recognized:", e.result.text);
            this.updateVoicePreviewText(e.result.text, false);
            this.setVoicePreviewStatus("ready");
          } else if (e.result.reason === window.SpeechSDK.ResultReason.NoMatch) {
            console.log("No speech recognized");
            this.setVoicePreviewStatus("error");
          }
        };

        this.speechRecognizer.canceled = (s, e) => {
          console.log("Recognition canceled:", e.reason);
          if (e.reason === window.SpeechSDK.CancellationReason.Error) {
            console.error("Recognition error:", e.errorDetails);
            this.setVoicePreviewStatus("error");
          }
          this.cleanupRecognizerOnly();
        };

        this.speechRecognizer.sessionStarted = (s, e) => {
          console.log("Azure Speech recognition session started");
          this.isListening = true;
          document.getElementById("voice-toggle").classList.add("active");
        };

        this.speechRecognizer.sessionStopped = (s, e) => {
          console.log("Azure Speech recognition session stopped");
          this.cleanupRecognizerOnly();
        };

        // Start single-shot recognition
        this.speechRecognizer.recognizeOnceAsync(
          (result) => {
            console.log("Recognition completed:", result.text);
            this.cleanupRecognizerOnly();
          },
          (error) => {
            console.error("Recognition error:", error);
            this.setVoicePreviewStatus("error");
            this.cleanupRecognizerOnly();
          }
        );
      }

      cleanupRecognizerOnly() {
        this.isListening = false;
        document.getElementById("voice-toggle").classList.remove("active");

        if (this.speechRecognizer) {
          try {
            this.speechRecognizer.close();
          } catch (e) {
            console.warn("Error closing speech recognizer:", e);
          }
          this.speechRecognizer = null;
        }
      }

      // Start audio capture for voice preview (enables replay)
      async startPreviewAudioCapture() {
        try {
          this.previewAudioChunks = [];
          this.lastPreviewAudioCacheKey = null;

          this.previewAudioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
          this.previewMediaRecorder = new MediaRecorder(this.previewAudioStream, {
            mimeType: MediaRecorder.isTypeSupported("audio/webm") ? "audio/webm" : "audio/mp4"
          });

          this.previewMediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
              this.previewAudioChunks.push(e.data);
            }
          };

          this.previewMediaRecorder.start(100); // Collect data every 100ms
        } catch (error) {
          console.error("Failed to start preview audio capture:", error);
        }
      }

      // Stop audio capture and cache the recording
      async stopPreviewAudioCapture(transcript) {
        if (!this.previewMediaRecorder || this.previewMediaRecorder.state === "inactive") {
          return null;
        }

        return new Promise((resolve) => {
          this.previewMediaRecorder.onstop = async () => {
            // Stop all tracks
            if (this.previewAudioStream) {
              this.previewAudioStream.getTracks().forEach(track => track.stop());
              this.previewAudioStream = null;
            }

            if (this.previewAudioChunks.length === 0) {
              resolve(null);
              return;
            }

            const audioBlob = new Blob(this.previewAudioChunks, {
              type: this.previewMediaRecorder?.mimeType || "audio/webm"
            });

            // Generate a cache key for IndexedDB storage
            const cacheKey = `user_voice_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

            // Store in IndexedDB via audioCache for persistent replay
            try {
              if (typeof audioCache !== 'undefined') {
                await audioCache.store(cacheKey, audioBlob, {
                  type: 'user_voice',
                  transcript: transcript
                });
                this.lastPreviewAudioCacheKey = cacheKey;
              }
            } catch (error) {
              console.error('Failed to cache preview audio:', error);
            }

            this.previewAudioChunks = [];
            resolve(cacheKey);
          };

          this.previewMediaRecorder.stop();
        });
      }

      // Check if Azure STT is available
      isAzureSTTAvailable() {
        return this.azureKey && this.isSdkLoaded && window.SpeechSDK;
      }

      // Create Azure Speech Recognizer
      createSpeechRecognizer() {
        if (!this.isAzureSTTAvailable()) {
          console.warn("Azure Speech SDK not available for STT");
          return null;
        }

        try {
          const speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
            this.azureKey,
            this.azureRegion
          );
          speechConfig.speechRecognitionLanguage = this.recognitionLanguage;

          // Use browser microphone
          const audioConfig = window.SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();

          const recognizer = new window.SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);

          return recognizer;
        } catch (error) {
          console.error("Failed to create Azure Speech Recognizer:", error);
          return null;
        }
      }

      setEnabled(enabled) {
        this.enabled = enabled;
      }

      setAutoSpeak(autoSpeak) {
        this.autoSpeak = autoSpeak;
      }

      setAzureKey(key) {
        this.azureKey = key;
      }

      setVoiceName(voiceName) {
        this.voiceName = voiceName;
      }

      async speak(text) {
        if (!this.enabled || !text || this.isSpeaking) return null;

        this.stopSpeaking();

        const cleanText = this.cleanTextForSpeech(text);

        if (this.azureKey && this.isSdkLoaded && window.SpeechSDK) {
          return await this.speakWithAzure(cleanText, true);
        } else {
          await this.speakWithBrowser(cleanText);
          return null;
        }
      }

      async speakAndCache(text) {
        if (!text) return null;

        this.stopSpeaking();
        const cleanText = this.cleanTextForSpeech(text);

        if (this.azureKey && this.isSdkLoaded && window.SpeechSDK && this.audioCache) {
          const cacheKey = this.audioCache.generateCacheKey(cleanText, this.voiceName);

          // Check if already cached
          const cached = await this.audioCache.get(cacheKey);
          if (cached) {
            console.log('Playing from cache:', cacheKey);
            await this.playAudioBlob(cached.audioBlob);
            return cacheKey;
          }

          // Generate and cache new audio
          const audioData = await this.speakWithAzure(cleanText, false);
          if (audioData) {
            const audioBlob = new Blob([audioData], { type: 'audio/wav' });
            await this.audioCache.store(cacheKey, audioBlob, { text: cleanText, voiceName: this.voiceName });
            await this.playAudioBlob(audioBlob);
            return cacheKey;
          }
        } else {
          await this.speakWithBrowser(cleanText);
        }
        return null;
      }

      async playFromCache(cacheKey) {
        if (!this.audioCache || !cacheKey) return false;

        try {
          const cached = await this.audioCache.get(cacheKey);
          if (cached && cached.audioBlob) {
            await this.playAudioBlob(cached.audioBlob);
            return true;
          }
        } catch (error) {
          console.error('Error playing from cache:', error);
        }
        return false;
      }

      async playAudioBlob(audioBlob) {
        return new Promise((resolve, reject) => {
          this.stopSpeaking();

          const audioUrl = URL.createObjectURL(audioBlob);
          this.currentAudioElement = new Audio(audioUrl);

          this.currentAudioElement.onplay = () => {
            this.isSpeaking = true;
            document.getElementById("voice-indicator").classList.add("active");
          };

          this.currentAudioElement.onended = () => {
            this.isSpeaking = false;
            document.getElementById("voice-indicator").classList.remove("active");
            URL.revokeObjectURL(audioUrl);
            this.currentAudioElement = null;
            resolve();
          };

          this.currentAudioElement.onerror = (error) => {
            this.isSpeaking = false;
            document.getElementById("voice-indicator").classList.remove("active");
            URL.revokeObjectURL(audioUrl);
            this.currentAudioElement = null;
            reject(error);
          };

          this.currentAudioElement.play().catch(reject);
        });
      }

      async speakWithAzure(text, playDirectly = true) {
        try {
          const truncatedText =
            text.length > this.maxCharacters
              ? text.substring(0, this.maxCharacters) +
              "... (text truncated for speech)"
              : text;

          const speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
            this.azureKey,
            this.azureRegion
          );
          speechConfig.speechSynthesisVoiceName = this.voiceName;

          // Use speaker output for direct play, null for capturing audio data
          const audioConfig = playDirectly
            ? window.SpeechSDK.AudioConfig.fromDefaultSpeakerOutput()
            : null;
          this.speechSynthesizer = new window.SpeechSDK.SpeechSynthesizer(
            speechConfig,
            audioConfig
          );

          if (playDirectly) {
            this.isSpeaking = true;
            document.getElementById("voice-indicator").classList.add("active");
          }

          const audioData = await new Promise((resolve, reject) => {
            this.speechSynthesizer.speakTextAsync(
              truncatedText,
              (result) => {
                if (
                  result.reason ===
                  window.SpeechSDK.ResultReason.SynthesizingAudioCompleted
                ) {
                  console.log("Azure TTS synthesis completed");

                  if (playDirectly) {
                    this.isSpeaking = false;
                    document
                      .getElementById("voice-indicator")
                      .classList.remove("active");
                  }

                  if (this.speechSynthesizer) {
                    this.speechSynthesizer.close();
                    this.speechSynthesizer = null;
                  }

                  // Return audio data for caching
                  resolve(result.audioData);
                } else {
                  console.error(
                    `Speech synthesis canceled, reason: ${result.reason}`
                  );
                  let errorDetails = "";

                  if (
                    result.reason === window.SpeechSDK.ResultReason.Canceled
                  ) {
                    const cancellationDetails =
                      window.SpeechSDK.CancellationDetails.fromResult(result);
                    errorDetails = `Cancellation reason: ${cancellationDetails.reason}`;

                    if (
                      cancellationDetails.reason ===
                      window.SpeechSDK.CancellationReason.Error
                    ) {
                      errorDetails += `, Error details: ${cancellationDetails.errorDetails}`;
                    }
                  }

                  if (this.speechSynthesizer) {
                    this.speechSynthesizer.close();
                    this.speechSynthesizer = null;
                  }

                  if (playDirectly) {
                    this.isSpeaking = false;
                    document
                      .getElementById("voice-indicator")
                      .classList.remove("active");
                  }
                  reject(
                    new Error(`Speech synthesis failed. ${errorDetails}`)
                  );
                }
              },
              (error) => {
                console.error("Azure TTS error:", error);

                if (this.speechSynthesizer) {
                  this.speechSynthesizer.close();
                  this.speechSynthesizer = null;
                }

                if (playDirectly) {
                  this.isSpeaking = false;
                  document
                    .getElementById("voice-indicator")
                    .classList.remove("active");
                }
                reject(error);
              }
            );
          });

          return audioData;
        } catch (error) {
          console.error("Azure TTS error:", error);
          this.isSpeaking = false;
          document
            .getElementById("voice-indicator")
            .classList.remove("active");
          await this.speakWithBrowser(text);
        }
      }

      async speakWithBrowser(text) {
        return new Promise((resolve, reject) => {
          try {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.rate = 1.0;
            utterance.pitch = 1.0;
            utterance.volume = 1.0;

            const voices = this.synthesis.getVoices();
            const preferredVoice =
              voices.find(
                (voice) =>
                  voice.name.includes("Microsoft") ||
                  voice.name.includes("Google") ||
                  voice.name.includes("Natural")
              ) || voices[0];

            if (preferredVoice) {
              utterance.voice = preferredVoice;
            }

            utterance.onstart = () => {
              this.isSpeaking = true;
              document
                .getElementById("voice-indicator")
                .classList.add("active");
            };

            utterance.onend = () => {
              this.isSpeaking = false;
              document
                .getElementById("voice-indicator")
                .classList.remove("active");
              resolve();
            };

            utterance.onerror = (error) => {
              this.isSpeaking = false;
              document
                .getElementById("voice-indicator")
                .classList.remove("active");
              reject(error);
            };

            this.synthesis.speak(utterance);
          } catch (error) {
            this.isSpeaking = false;
            document
              .getElementById("voice-indicator")
              .classList.remove("active");
            reject(error);
          }
        });
      }

      stopSpeaking() {
        if (this.speechSynthesizer) {
          try {
            this.speechSynthesizer.close();
          } catch (e) {
            console.warn("Error closing speech synthesizer:", e);
          }
          this.speechSynthesizer = null;
        }

        if (window.speechSynthesis) {
          try {
            window.speechSynthesis.cancel();
          } catch (e) {
            console.warn("Error canceling speech synthesis:", e);
          }
        }

        if (this.currentAudioElement) {
          try {
            this.currentAudioElement.pause();
            this.currentAudioElement.currentTime = 0;
          } catch (e) {
            console.warn("Error stopping audio element:", e);
          }
          this.currentAudioElement = null;
        }

        this.isSpeaking = false;
        document.getElementById("voice-indicator").classList.remove("active");
      }

      cleanTextForSpeech(text) {
        let cleanText = text.replace(/<[^>]*>/g, " ");

        cleanText = cleanText
          .replace(/\*\*([^*]+)\*\*/g, "$1")
          .replace(/\*([^*]+)\*/g, "$1")
          .replace(/`([^`]+)`/g, "$1")
          .replace(/\[([^\]]+)\]\([^)]+\)/g, "$1")
          .replace(/#{1,6}\s+([^\n]+)/g, "$1")
          .replace(/```[\s\S]*?```/g, "")
          .replace(/\n/g, " ")
          .replace(/\s+/g, " ")
          .trim();

        return cleanText;
      }

      startListening(callback, interimCallback = null) {
        if (this.isListening) return;

        // Check if Azure STT is available
        if (!this.isAzureSTTAvailable()) {
          console.warn("Azure Speech-to-Text not configured. Please add Azure Speech key in settings.");
          ui.showNotification("Voice input requires Azure Speech key in settings", "warning");
          return;
        }

        this.recognitionCallback = callback;
        this.interimCallback = interimCallback;

        // Create new recognizer for each session
        this.speechRecognizer = this.createSpeechRecognizer();

        if (!this.speechRecognizer) {
          console.error("Failed to create speech recognizer");
          ui.showNotification("Failed to initialize voice input", "error");
          return;
        }

        // Set up event handlers
        this.speechRecognizer.recognizing = (s, e) => {
          // Interim results (while speaking)
          if (e.result.reason === window.SpeechSDK.ResultReason.RecognizingSpeech) {
            console.log("Recognizing:", e.result.text);
            if (this.interimCallback) {
              this.interimCallback(e.result.text);
            }
            // Update input field with interim text
            const userInput = document.getElementById("user-input");
            if (userInput) {
              userInput.value = e.result.text;
              userInput.style.fontStyle = "italic";
            }
          }
        };

        this.speechRecognizer.recognized = (s, e) => {
          // Final results
          if (e.result.reason === window.SpeechSDK.ResultReason.RecognizedSpeech) {
            console.log("Recognized:", e.result.text);
            const userInput = document.getElementById("user-input");
            if (userInput) {
              userInput.value = e.result.text;
              userInput.style.fontStyle = "normal";
            }
            if (this.recognitionCallback && e.result.text) {
              this.recognitionCallback(e.result.text);
            }
          } else if (e.result.reason === window.SpeechSDK.ResultReason.NoMatch) {
            console.log("No speech recognized");
          }
        };

        this.speechRecognizer.canceled = (s, e) => {
          console.log("Recognition canceled:", e.reason);
          if (e.reason === window.SpeechSDK.CancellationReason.Error) {
            console.error("Recognition error:", e.errorDetails);
            ui.showNotification("Voice recognition error: " + e.errorDetails, "error");
          }
          this.cleanupRecognizer();
        };

        this.speechRecognizer.sessionStarted = (s, e) => {
          console.log("Azure Speech recognition session started");
          this.isListening = true;
          document.getElementById("voice-toggle").classList.add("active");
          ui.showNotification("Listening... Speak now", "info");
        };

        this.speechRecognizer.sessionStopped = (s, e) => {
          console.log("Azure Speech recognition session stopped");
          this.cleanupRecognizer();
        };

        // Start single-shot recognition (stops after one phrase)
        this.speechRecognizer.recognizeOnceAsync(
          (result) => {
            console.log("Recognition completed:", result.text);
            const userInput = document.getElementById("user-input");
            if (userInput) {
              userInput.style.fontStyle = "normal";
            }
            this.cleanupRecognizer();
          },
          (error) => {
            console.error("Recognition error:", error);
            ui.showNotification("Voice recognition failed", "error");
            this.cleanupRecognizer();
          }
        );
      }

      cleanupRecognizer() {
        this.isListening = false;
        document.getElementById("voice-toggle").classList.remove("active");

        if (this.speechRecognizer) {
          try {
            this.speechRecognizer.close();
          } catch (e) {
            console.warn("Error closing speech recognizer:", e);
          }
          this.speechRecognizer = null;
        }
      }

      stopListening() {
        if (this.speechRecognizer && this.isListening) {
          try {
            this.speechRecognizer.stopContinuousRecognitionAsync(
              () => {
                console.log("Recognition stopped");
                this.cleanupRecognizer();
              },
              (error) => {
                console.error("Error stopping recognition:", error);
                this.cleanupRecognizer();
              }
            );
          } catch (e) {
            console.warn("Error stopping recognition:", e);
            this.cleanupRecognizer();
          }
        } else {
          this.cleanupRecognizer();
        }
      }

      toggleListening(callback) {
        if (this.isListening) {
          this.stopListening();
        } else {
          this.startListening(callback);
        }
      }
    }

    // ==========================================
    // PUSH-TO-TALK VOICE MODE MANAGER
    // ==========================================
    class PushToTalkManager {
      constructor(voiceManager) {
        this.voiceManager = voiceManager;
        this.isActive = false;
        this.isRecording = false;
        this.isQuickMode = false; // True when recording directly from FAB hold
        this.mediaRecorder = null;
        this.audioChunks = [];
        this.recordingStartTime = null;
        this.recordingTimer = null;
        this.currentTranscript = "";
        this.recordings = []; // Cached recordings for playback
        this.maxRecordings = 10;
        this.autoSpeakResponses = true;

        // DOM elements
        this.panel = null;
        this.fab = null;
        this.pttButton = null;
        this.recordingIndicator = null;
        this.recordingTime = null;
        this.waveform = null;
        this.transcriptPreview = null;
        this.recordingsList = null;
        this.statusText = null;

        // Speech recognition
        this.speechRecognizer = null;

        // Bind methods
        this.handleKeyDown = this.handleKeyDown.bind(this);
        this.handleKeyUp = this.handleKeyUp.bind(this);

        this.init();
      }

      init() {
        setTimeout(() => {
          this.cacheElements();
          this.setupEventListeners();
          this.loadRecordingsFromStorage();
        }, 100);
      }

      cacheElements() {
        this.panel = document.getElementById("voice-mode-panel");
        this.fab = document.getElementById("voice-mode-fab");
        this.pttButton = document.getElementById("ptt-button");
        this.recordingIndicator = document.getElementById("ptt-recording-indicator");
        this.recordingTime = document.getElementById("ptt-recording-time");
        this.waveform = document.getElementById("ptt-waveform");
        this.transcriptPreview = document.getElementById("ptt-transcript-preview");
        this.recordingsList = document.getElementById("ptt-recordings-list");
        this.statusText = document.getElementById("voice-mode-status-text");
      }

      setupEventListeners() {
        // FAB - Hold to record directly, tap to toggle panel
        if (this.fab) {
          let fabHoldTimer = null;
          let fabIsHolding = false;
          const HOLD_THRESHOLD = 200; // ms to distinguish tap from hold

          const startFabHold = (e) => {
            e.preventDefault();
            fabIsHolding = false;

            // Start timer to detect hold
            fabHoldTimer = setTimeout(() => {
              fabIsHolding = true;
              // Start recording directly from FAB (quick mode)
              this.startQuickRecording();
            }, HOLD_THRESHOLD);
          };

          const endFabHold = (e) => {
            e.preventDefault();

            // Clear the hold timer
            if (fabHoldTimer) {
              clearTimeout(fabHoldTimer);
              fabHoldTimer = null;
            }

            if (fabIsHolding && this.isRecording) {
              // Was holding and recording - stop and send
              this.stopRecordingAndSend();
            } else if (!fabIsHolding) {
              // Was a quick tap - toggle panel
              this.togglePanel();
            }

            fabIsHolding = false;
          };

          const cancelFabHold = () => {
            if (fabHoldTimer) {
              clearTimeout(fabHoldTimer);
              fabHoldTimer = null;
            }
            if (fabIsHolding && this.isRecording) {
              this.stopRecordingAndSend();
            }
            fabIsHolding = false;
          };

          // Mouse events
          this.fab.addEventListener("mousedown", startFabHold);
          this.fab.addEventListener("mouseup", endFabHold);
          this.fab.addEventListener("mouseleave", cancelFabHold);

          // Touch events for mobile
          this.fab.addEventListener("touchstart", startFabHold, { passive: false });
          this.fab.addEventListener("touchend", endFabHold, { passive: false });
          this.fab.addEventListener("touchcancel", cancelFabHold);
        }

        // Close button
        const closeBtn = document.getElementById("voice-mode-close");
        if (closeBtn) {
          closeBtn.addEventListener("click", () => this.hidePanel());
        }

        // PTT button inside panel - mouse events
        if (this.pttButton) {
          this.pttButton.addEventListener("mousedown", (e) => {
            e.preventDefault();
            this.startRecording();
          });

          this.pttButton.addEventListener("mouseup", (e) => {
            e.preventDefault();
            this.stopRecordingAndSend();
          });

          this.pttButton.addEventListener("mouseleave", () => {
            if (this.isRecording) {
              this.stopRecordingAndSend();
            }
          });

          // Touch events for mobile
          this.pttButton.addEventListener("touchstart", (e) => {
            e.preventDefault();
            this.startRecording();
          });

          this.pttButton.addEventListener("touchend", (e) => {
            e.preventDefault();
            this.stopRecordingAndSend();
          });
        }

        // Clear recordings button
        const clearBtn = document.getElementById("ptt-clear-recordings");
        if (clearBtn) {
          clearBtn.addEventListener("click", () => this.clearAllRecordings());
        }

        // Keyboard shortcuts (global)
        document.addEventListener("keydown", this.handleKeyDown);
        document.addEventListener("keyup", this.handleKeyUp);
      }

      // Quick recording mode - directly from FAB without opening panel
      async startQuickRecording() {
        if (this.isRecording) return;

        // Check Azure STT availability
        if (!this.voiceManager.isAzureSTTAvailable()) {
          if (typeof ui !== "undefined") {
            ui.showNotification("Voice mode requires Azure Speech key in settings", "warning");
          }
          return;
        }

        this.isRecording = true;
        this.isQuickMode = true;
        this.currentTranscript = "";
        this.audioChunks = [];
        this.recordingStartTime = Date.now();

        // Update FAB to show recording state
        if (this.fab) {
          this.fab.classList.add("active", "recording");
        }

        // Show quick recording notification
        if (typeof ui !== "undefined") {
          ui.showNotification(" Recording... Release to send", "info");
        }

        // Start audio capture and speech recognition
        await this.startAudioCapture();
        this.startSpeechRecognition();
      }

      handleKeyDown(e) {
        // Toggle panel with 'V' key
        if (e.key === "v" || e.key === "V") {
          if (!this.isInputFocused()) {
            e.preventDefault();
            this.togglePanel();
          }
        }

        // Push-to-talk with Space key when panel is open
        if (e.code === "Space" && this.isActive && !e.repeat) {
          if (!this.isInputFocused()) {
            e.preventDefault();
            if (!this.isRecording) {
              this.startRecording();
            }
          }
        }
      }

      handleKeyUp(e) {
        // Release Space to send
        if (e.code === "Space" && this.isActive) {
          if (!this.isInputFocused() && this.isRecording) {
            e.preventDefault();
            this.stopRecordingAndSend();
          }
        }
      }

      isInputFocused() {
        const activeElement = document.activeElement;
        const tagName = activeElement.tagName.toLowerCase();
        return tagName === "input" || tagName === "textarea" || activeElement.isContentEditable;
      }

      togglePanel() {
        if (this.isActive) {
          this.hidePanel();
        } else {
          this.showPanel();
        }
      }

      showPanel() {
        if (!this.voiceManager.isAzureSTTAvailable()) {
          if (typeof ui !== "undefined") {
            ui.showNotification("Voice mode requires Azure Speech key in settings", "warning");
          }
          return;
        }

        this.isActive = true;
        if (this.panel) this.panel.classList.add("active");
        if (this.fab) this.fab.classList.add("active");
        this.updateStatus("Hold button or press Space to talk");
      }

      hidePanel() {
        this.isActive = false;
        if (this.panel) this.panel.classList.remove("active");
        if (this.fab) this.fab.classList.remove("active");

        // Stop any ongoing recording
        if (this.isRecording) {
          this.cancelRecording();
        }
      }

      async startRecording() {
        if (this.isRecording) return;

        // Check Azure STT availability
        if (!this.voiceManager.isAzureSTTAvailable()) {
          this.updateStatus("Azure Speech not configured");
          return;
        }

        this.isRecording = true;
        this.currentTranscript = "";
        this.audioChunks = [];
        this.recordingStartTime = Date.now();

        // Update UI
        if (this.pttButton) this.pttButton.classList.add("recording");
        if (this.recordingIndicator) this.recordingIndicator.classList.add("active");
        if (this.waveform) this.waveform.classList.add("active");
        this.updateTranscriptPreview("Listening...", true);
        this.updateStatus("Recording... Release to send");

        // Start recording timer
        this.startRecordingTimer();

        // Start audio recording for caching
        await this.startAudioCapture();

        // Start Azure speech recognition
        this.startSpeechRecognition();
      }

      async startAudioCapture() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          this.mediaRecorder = new MediaRecorder(stream, {
            mimeType: MediaRecorder.isTypeSupported("audio/webm") ? "audio/webm" : "audio/mp4"
          });

          this.mediaRecorder.ondataavailable = (e) => {
            if (e.data.size > 0) {
              this.audioChunks.push(e.data);
            }
          };

          this.mediaRecorder.start(100); // Collect data every 100ms
        } catch (error) {
          console.error("Failed to start audio capture:", error);
        }
      }

      startSpeechRecognition() {
        if (!this.voiceManager.isAzureSTTAvailable()) return;

        try {
          const speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
            this.voiceManager.azureKey,
            this.voiceManager.azureRegion
          );
          speechConfig.speechRecognitionLanguage = this.voiceManager.recognitionLanguage || "en-US";

          const audioConfig = window.SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
          this.speechRecognizer = new window.SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);

          // Continuous recognition for real-time transcript
          this.speechRecognizer.recognizing = (s, e) => {
            if (e.result.reason === window.SpeechSDK.ResultReason.RecognizingSpeech) {
              this.currentTranscript = e.result.text;
              this.updateTranscriptPreview(e.result.text, true);
            }
          };

          this.speechRecognizer.recognized = (s, e) => {
            if (e.result.reason === window.SpeechSDK.ResultReason.RecognizedSpeech) {
              this.currentTranscript = e.result.text;
              this.updateTranscriptPreview(e.result.text, false);
            }
          };

          this.speechRecognizer.canceled = (s, e) => {
            console.log("Speech recognition canceled:", e.reason);
          };

          // Start continuous recognition
          this.speechRecognizer.startContinuousRecognitionAsync(
            () => console.log("Continuous recognition started"),
            (error) => console.error("Failed to start recognition:", error)
          );
        } catch (error) {
          console.error("Failed to start speech recognition:", error);
        }
      }

      startRecordingTimer() {
        this.recordingTimer = setInterval(() => {
          const elapsed = Math.floor((Date.now() - this.recordingStartTime) / 1000);
          const minutes = Math.floor(elapsed / 60);
          const seconds = elapsed % 60;
          if (this.recordingTime) {
            this.recordingTime.textContent = `${minutes}:${seconds.toString().padStart(2, "0")}`;
          }
        }, 100);
      }

      stopRecordingTimer() {
        if (this.recordingTimer) {
          clearInterval(this.recordingTimer);
          this.recordingTimer = null;
        }
      }

      updateTranscriptPreview(text, isInterim) {
        if (this.transcriptPreview) {
          this.transcriptPreview.textContent = text || "Your speech will appear here...";
          this.transcriptPreview.classList.toggle("empty", !text);
          this.transcriptPreview.classList.toggle("interim", isInterim && text);
        }
      }

      updateStatus(text) {
        if (this.statusText) {
          this.statusText.textContent = text;
        }
      }

      async stopRecordingAndSend() {
        if (!this.isRecording) return;

        const wasQuickMode = this.isQuickMode;
        this.isRecording = false;
        this.isQuickMode = false;
        this.stopRecordingTimer();

        // Update UI - handle both panel and FAB states
        if (this.pttButton) this.pttButton.classList.remove("recording");
        if (this.recordingIndicator) this.recordingIndicator.classList.remove("active");
        if (this.waveform) this.waveform.classList.remove("active");

        // Reset FAB state (for quick mode)
        if (this.fab) {
          this.fab.classList.remove("recording");
          if (wasQuickMode && !this.isActive) {
            this.fab.classList.remove("active");
          }
        }

        this.updateStatus("Processing...");

        // Stop speech recognition
        if (this.speechRecognizer) {
          try {
            await new Promise((resolve) => {
              this.speechRecognizer.stopContinuousRecognitionAsync(
                () => {
                  this.speechRecognizer.close();
                  this.speechRecognizer = null;
                  resolve();
                },
                (error) => {
                  console.error("Error stopping recognition:", error);
                  resolve();
                }
              );
            });
          } catch (e) {
            console.warn("Error closing recognizer:", e);
          }
        }

        // Stop audio recording and save
        if (this.mediaRecorder && this.mediaRecorder.state !== "inactive") {
          await new Promise((resolve) => {
            this.mediaRecorder.onstop = () => resolve();
            this.mediaRecorder.stop();
          });

          // Stop all tracks
          this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
        }

        // Get final transcript
        const transcript = this.currentTranscript.trim();

        if (transcript) {
          // Cache the recording
          await this.cacheRecording(transcript);

          // Send the message
          this.sendMessage(transcript);

          if (wasQuickMode) {
            // Quick mode - show notification instead of panel status
            if (typeof ui !== "undefined") {
              ui.showNotification("Message sent!", "success");
            }
          } else {
            this.updateStatus("Message sent! Hold to talk again");
          }
          this.updateTranscriptPreview("", false);
        } else {
          if (wasQuickMode) {
            if (typeof ui !== "undefined") {
              ui.showNotification("No speech detected", "warning");
            }
          } else {
            this.updateStatus("No speech detected. Try again");
          }
          this.updateTranscriptPreview("Your speech will appear here...", false);
        }

        // Reset recording time display
        if (this.recordingTime) {
          this.recordingTime.textContent = "0:00";
        }
      }

      cancelRecording() {
        this.isRecording = false;
        this.stopRecordingTimer();
        this.currentTranscript = "";
        this.audioChunks = [];

        // Update UI
        if (this.pttButton) this.pttButton.classList.remove("recording");
        if (this.recordingIndicator) this.recordingIndicator.classList.remove("active");
        if (this.waveform) this.waveform.classList.remove("active");
        this.updateStatus("Hold button or press Space to talk");
        this.updateTranscriptPreview("Your speech will appear here...", false);

        // Stop speech recognition
        if (this.speechRecognizer) {
          try {
            this.speechRecognizer.stopContinuousRecognitionAsync();
            this.speechRecognizer.close();
          } catch (e) {
            console.warn("Error closing recognizer:", e);
          }
          this.speechRecognizer = null;
        }

        // Stop audio recording
        if (this.mediaRecorder && this.mediaRecorder.state !== "inactive") {
          this.mediaRecorder.stop();
          this.mediaRecorder.stream.getTracks().forEach(track => track.stop());
        }

        if (this.recordingTime) {
          this.recordingTime.textContent = "0:00";
        }
      }

      async cacheRecording(transcript) {
        if (this.audioChunks.length === 0) return null;

        const audioBlob = new Blob(this.audioChunks, {
          type: this.mediaRecorder?.mimeType || "audio/webm"
        });

        // Generate a cache key for IndexedDB storage
        const cacheKey = `user_voice_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

        // Store in IndexedDB via audioCache for persistent replay
        try {
          if (typeof audioCache !== 'undefined') {
            await audioCache.store(cacheKey, audioBlob, {
              type: 'user_voice',
              transcript: transcript,
              duration: Math.floor((Date.now() - this.recordingStartTime) / 1000)
            });
          }
        } catch (error) {
          console.error('Failed to cache user voice recording:', error);
        }

        const recording = {
          id: cacheKey,
          transcript: transcript,
          audioBlob: audioBlob,
          audioUrl: URL.createObjectURL(audioBlob),
          audioCacheKey: cacheKey,
          timestamp: new Date().toISOString(),
          duration: Math.floor((Date.now() - this.recordingStartTime) / 1000)
        };

        this.recordings.unshift(recording);
        this.lastRecordingCacheKey = cacheKey;

        // Limit stored recordings
        if (this.recordings.length > this.maxRecordings) {
          const removed = this.recordings.pop();
          if (removed.audioUrl) URL.revokeObjectURL(removed.audioUrl);
        }

        this.renderRecordingsList();
        this.saveRecordingsToStorage();

        return cacheKey;
      }

      sendMessage(transcript) {
        // Track that this message was from voice input, including audio cache key
        if (window.pendingVoiceInput) {
          window.pendingVoiceInput.set(transcript, this.lastRecordingCacheKey || null);
        }

        const userInput = document.getElementById("user-input");
        if (userInput) {
          userInput.value = transcript;
        }

        // Update status to show waiting
        this.updateStatus("Waiting for response...");

        // Send the message
        if (typeof ui !== "undefined" && typeof ui.sendMessage === "function") {
          ui.sendMessage();
        } else {
          const sendBtn = document.getElementById("send-btn");
          if (sendBtn) sendBtn.click();
        }

        // Reset status after a delay (response handling will update if speaking)
        setTimeout(() => {
          if (!this.isRecording) {
            this.updateStatus("Hold button or press Space to talk");
          }
        }, 500);
      }

      renderRecordingsList() {
        if (!this.recordingsList) return;

        if (this.recordings.length === 0) {
          this.recordingsList.innerHTML = '<div class="ptt-no-recordings">No recordings yet</div>';
          return;
        }

        this.recordingsList.innerHTML = this.recordings.map(rec => `
          <div class="ptt-recording-item" data-id="${rec.id}">
            <button class="ptt-recording-play" data-id="${rec.id}" title="Play recording">
              <i class="fas fa-play"></i>
            </button>
            <div class="ptt-recording-info">
              <div class="ptt-recording-text">${this.escapeHtml(rec.transcript)}</div>
              <div class="ptt-recording-meta">
                <span>${this.formatTime(rec.timestamp)}</span>
                <span>${rec.duration}s</span>
              </div>
            </div>
            <button class="ptt-recording-delete" data-id="${rec.id}" title="Delete">
              <i class="fas fa-trash"></i>
            </button>
          </div>
        `).join("");

        // Add event listeners
        this.recordingsList.querySelectorAll(".ptt-recording-play").forEach(btn => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            this.playRecording(btn.dataset.id);
          });
        });

        this.recordingsList.querySelectorAll(".ptt-recording-delete").forEach(btn => {
          btn.addEventListener("click", (e) => {
            e.stopPropagation();
            this.deleteRecording(btn.dataset.id);
          });
        });
      }

      playRecording(id) {
        const recording = this.recordings.find(r => r.id === id);
        if (!recording || !recording.audioUrl) return;

        // Stop any current playback
        if (this.currentPlayback) {
          this.currentPlayback.pause();
          this.currentPlayback = null;
        }

        const audio = new Audio(recording.audioUrl);
        this.currentPlayback = audio;

        // Update button to show playing state
        const playBtn = this.recordingsList.querySelector(`.ptt-recording-play[data-id="${id}"]`);
        if (playBtn) {
          playBtn.innerHTML = '<i class="fas fa-stop"></i>';
          playBtn.onclick = () => {
            audio.pause();
            playBtn.innerHTML = '<i class="fas fa-play"></i>';
          };
        }

        audio.onended = () => {
          if (playBtn) {
            playBtn.innerHTML = '<i class="fas fa-play"></i>';
            playBtn.onclick = () => this.playRecording(id);
          }
          this.currentPlayback = null;
        };

        audio.play();
      }

      deleteRecording(id) {
        const index = this.recordings.findIndex(r => r.id === id);
        if (index === -1) return;

        const recording = this.recordings[index];
        if (recording.audioUrl) URL.revokeObjectURL(recording.audioUrl);

        this.recordings.splice(index, 1);
        this.renderRecordingsList();
        this.saveRecordingsToStorage();
      }

      clearAllRecordings() {
        this.recordings.forEach(rec => {
          if (rec.audioUrl) URL.revokeObjectURL(rec.audioUrl);
        });
        this.recordings = [];
        this.renderRecordingsList();
        this.saveRecordingsToStorage();
      }

      saveRecordingsToStorage() {
        // Save metadata only (not audio blobs) to localStorage
        try {
          const metadata = this.recordings.map(r => ({
            id: r.id,
            transcript: r.transcript,
            timestamp: r.timestamp,
            duration: r.duration
          }));
          localStorage.setItem("ptt_recordings_meta", JSON.stringify(metadata));
        } catch (e) {
          console.warn("Failed to save recordings metadata:", e);
        }
      }

      loadRecordingsFromStorage() {
        try {
          const stored = localStorage.getItem("ptt_recordings_meta");
          if (stored) {
            const metadata = JSON.parse(stored);
            // Only load metadata, audio blobs are session-only
            this.recordings = metadata.map(m => ({
              ...m,
              audioBlob: null,
              audioUrl: null
            }));
            this.renderRecordingsList();
          }
        } catch (e) {
          console.warn("Failed to load recordings metadata:", e);
        }
      }

      formatTime(isoString) {
        const date = new Date(isoString);
        const now = new Date();
        const diff = now - date;

        if (diff < 60000) return "Just now";
        if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
        if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
        return date.toLocaleDateString();
      }

      escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      destroy() {
        document.removeEventListener("keydown", this.handleKeyDown);
        document.removeEventListener("keyup", this.handleKeyUp);

        // Clean up recordings
        this.recordings.forEach(rec => {
          if (rec.audioUrl) URL.revokeObjectURL(rec.audioUrl);
        });
      }
    }

    // ==========================================
    // CONTINUOUS LISTENING MODE MANAGER
    // Real-time back-and-forth voice conversation
    // ==========================================
    class ContinuousListeningManager {
      constructor(voiceManager) {
        this.voiceManager = voiceManager;
        this.isEnabled = false;
        this.isListening = false;
        this.isProcessing = false;
        this.isSpeaking = false;
        this.speechRecognizer = null;
        this.currentTranscript = "";
        this.silenceTimer = null;
        this.silenceThreshold = 1500; // ms of silence before auto-send
        this.lastSpeechTime = null;

        // DOM elements
        this.voiceButton = null;
        this.indicator = null;
        this.indicatorText = null;

        // Callbacks
        this.onMessageReady = null;

        this.init();
      }

      init() {
        setTimeout(() => {
          this.voiceButton = document.getElementById("voice-toggle");
          this.indicator = document.getElementById("continuous-listening-indicator");
          this.indicatorText = document.getElementById("continuous-listening-text");
        }, 100);
      }

      toggle() {
        if (this.isEnabled) {
          this.disable();
        } else {
          this.enable();
        }
      }

      enable() {
        if (!this.voiceManager.isAzureSTTAvailable()) {
          if (typeof ui !== "undefined") {
            ui.showNotification("Continuous listening requires Azure Speech key", "warning");
          }
          return false;
        }

        this.isEnabled = true;
        this.updateUI("listening");

        if (typeof ui !== "undefined") {
          ui.showNotification(" Continuous listening enabled. Speak anytime!", "success");
        }

        this.startListening();
        return true;
      }

      disable() {
        this.isEnabled = false;
        this.stopListening();
        this.updateUI("disabled");

        if (typeof ui !== "undefined") {
          ui.showNotification("Continuous listening disabled", "info");
        }
      }

      updateUI(state) {
        if (!this.voiceButton || !this.indicator) return;

        // Reset classes
        this.voiceButton.classList.remove("continuous-listening", "processing", "speaking", "active");
        this.indicator.classList.remove("active", "processing", "speaking");

        switch (state) {
          case "listening":
            this.voiceButton.classList.add("continuous-listening");
            this.indicator.classList.add("active");
            if (this.indicatorText) this.indicatorText.textContent = "Listening...";
            if (this.indicator.querySelector("i")) {
              this.indicator.querySelector("i").className = "fas fa-microphone";
            }
            // Start listening indicator sound
            if (typeof soundManager !== 'undefined') {
              soundManager.startListeningSound();
            }
            break;

          case "processing":
            this.voiceButton.classList.add("continuous-listening", "processing");
            this.indicator.classList.add("active", "processing");
            if (this.indicatorText) this.indicatorText.textContent = "Processing...";
            if (this.indicator.querySelector("i")) {
              this.indicator.querySelector("i").className = "fas fa-spinner fa-spin";
            }
            // Stop listening sound when processing
            if (typeof soundManager !== 'undefined') {
              soundManager.stopListeningSound();
            }
            break;

          case "speaking":
            this.voiceButton.classList.add("continuous-listening", "speaking");
            this.indicator.classList.add("active", "speaking");
            if (this.indicatorText) this.indicatorText.textContent = "Speaking...";
            if (this.indicator.querySelector("i")) {
              this.indicator.querySelector("i").className = "fas fa-volume-up";
            }
            // Stop listening sound when speaking
            if (typeof soundManager !== 'undefined') {
              soundManager.stopListeningSound();
            }
            break;

          case "disabled":
            // All classes already removed
            // Stop listening sound when disabled
            if (typeof soundManager !== 'undefined') {
              soundManager.stopListeningSound();
            }
            break;
        }
      }

      startListening() {
        if (!this.isEnabled || this.isListening || this.isSpeaking) return;

        this.isListening = true;
        this.currentTranscript = "";
        this.lastSpeechTime = null;

        try {
          const speechConfig = window.SpeechSDK.SpeechConfig.fromSubscription(
            this.voiceManager.azureKey,
            this.voiceManager.azureRegion
          );
          speechConfig.speechRecognitionLanguage = this.voiceManager.recognitionLanguage || "en-US";

          const audioConfig = window.SpeechSDK.AudioConfig.fromDefaultMicrophoneInput();
          this.speechRecognizer = new window.SpeechSDK.SpeechRecognizer(speechConfig, audioConfig);

          // Handle interim results
          this.speechRecognizer.recognizing = (s, e) => {
            if (e.result.reason === window.SpeechSDK.ResultReason.RecognizingSpeech) {
              this.currentTranscript = e.result.text;
              this.lastSpeechTime = Date.now();
              this.resetSilenceTimer();

              // Update input field to show what's being heard
              const userInput = document.getElementById("user-input");
              if (userInput) {
                userInput.value = e.result.text;
                userInput.style.fontStyle = "italic";
              }
            }
          };

          // Handle final recognition
          this.speechRecognizer.recognized = (s, e) => {
            if (e.result.reason === window.SpeechSDK.ResultReason.RecognizedSpeech) {
              this.currentTranscript = e.result.text;
              this.lastSpeechTime = Date.now();

              const userInput = document.getElementById("user-input");
              if (userInput) {
                userInput.value = e.result.text;
                userInput.style.fontStyle = "normal";
              }

              // Start silence detection for auto-send
              this.startSilenceDetection();
            } else if (e.result.reason === window.SpeechSDK.ResultReason.NoMatch) {
              // No speech detected, continue listening
              this.startSilenceDetection();
            }
          };

          this.speechRecognizer.canceled = (s, e) => {
            console.log("Continuous recognition canceled:", e.reason);
            if (e.reason === window.SpeechSDK.CancellationReason.Error) {
              console.error("Recognition error:", e.errorDetails);
            }
            // Try to restart if still enabled
            if (this.isEnabled && !this.isSpeaking) {
              setTimeout(() => this.restartListening(), 1000);
            }
          };

          this.speechRecognizer.sessionStopped = (s, e) => {
            console.log("Session stopped");
            this.isListening = false;
            // Restart if still enabled
            if (this.isEnabled && !this.isSpeaking && !this.isProcessing) {
              setTimeout(() => this.startListening(), 500);
            }
          };

          // Start continuous recognition
          this.speechRecognizer.startContinuousRecognitionAsync(
            () => {
              console.log("Continuous listening started");
              this.updateUI("listening");
            },
            (error) => {
              console.error("Failed to start continuous recognition:", error);
              this.isListening = false;
            }
          );

        } catch (error) {
          console.error("Error starting continuous listening:", error);
          this.isListening = false;
        }
      }

      startSilenceDetection() {
        this.clearSilenceTimer();

        this.silenceTimer = setTimeout(() => {
          // Check if we have text and enough silence has passed
          if (this.currentTranscript.trim() && this.lastSpeechTime) {
            const silenceTime = Date.now() - this.lastSpeechTime;
            if (silenceTime >= this.silenceThreshold) {
              this.sendMessage();
            }
          }
        }, this.silenceThreshold);
      }

      resetSilenceTimer() {
        this.clearSilenceTimer();
        this.startSilenceDetection();
      }

      clearSilenceTimer() {
        if (this.silenceTimer) {
          clearTimeout(this.silenceTimer);
          this.silenceTimer = null;
        }
      }

      async sendMessage() {
        const transcript = this.currentTranscript.trim();
        if (!transcript) return;

        this.isProcessing = true;
        this.updateUI("processing");

        // Stop listening while processing
        await this.stopListening();

        // Clear input styling
        const userInput = document.getElementById("user-input");
        if (userInput) {
          userInput.value = transcript;
          userInput.style.fontStyle = "normal";
        }

        // Send the message
        if (typeof ui !== "undefined" && typeof ui.sendMessage === "function") {
          ui.sendMessage();
        } else {
          const sendBtn = document.getElementById("send-btn");
          if (sendBtn) sendBtn.click();
        }

        this.currentTranscript = "";
        this.isProcessing = false;

        // Note: resumeListening() will be called after the response is spoken
      }

      async stopListening() {
        this.isListening = false;
        this.clearSilenceTimer();

        if (this.speechRecognizer) {
          try {
            await new Promise((resolve) => {
              this.speechRecognizer.stopContinuousRecognitionAsync(
                () => {
                  this.speechRecognizer.close();
                  this.speechRecognizer = null;
                  resolve();
                },
                (error) => {
                  console.error("Error stopping continuous recognition:", error);
                  resolve();
                }
              );
            });
          } catch (e) {
            console.warn("Error stopping recognizer:", e);
            this.speechRecognizer = null;
          }
        }
      }

      restartListening() {
        this.stopListening().then(() => {
          if (this.isEnabled && !this.isSpeaking) {
            this.startListening();
          }
        });
      }

      // Called when AI starts speaking response
      onSpeakingStart() {
        this.isSpeaking = true;
        this.updateUI("speaking");
        this.stopListening();
      }

      // Called when AI finishes speaking response
      onSpeakingEnd() {
        this.isSpeaking = false;
        if (this.isEnabled) {
          this.updateUI("listening");
          // Small delay before resuming listening
          setTimeout(() => {
            if (this.isEnabled && !this.isSpeaking) {
              this.startListening();
            }
          }, 500);
        }
      }

      // Resume listening after response (called from response handler)
      resumeAfterResponse() {
        if (this.isEnabled && !this.isSpeaking) {
          this.updateUI("listening");
          this.startListening();
        }
      }
    }

    // Time Machine
    class TimeMachine {
      constructor() {
        this.messages = [];
        this.currentIndex = 0;
        this.isPlaying = false;
        this.playInterval = null;
        this.playbackSpeed = 1000;
        this.initSpeedControls();
        this.sourceChat = null;
      }

      initSpeedControls() {
        setTimeout(() => {
          document.querySelectorAll(".speed-option").forEach(btn => {
            btn.addEventListener("click", () => {
              document.querySelectorAll(".speed-option").forEach(b => b.classList.remove("active"));
              btn.classList.add("active");
              this.playbackSpeed = parseInt(btn.dataset.speed);
              this.updateStats();
            });
          });
        }, 100);
      }


      init(messages, sourceChat) {
        this.messages = messages;
        this.currentIndex = 0;
        this.isPlaying = false;
        this.sourceChat = sourceChat;
        this.updateProgress();
        this.updateStats();
        this.showInitialState();
      }

      updateStats() {
        const messageCount = this.messages.length;
        const duration = Math.ceil((messageCount * this.playbackSpeed) / 1000);
        const durationDisplay = duration >= 60 ? "~" + Math.floor(duration/60) + "m " + (duration%60) + "s" : "~" + duration + "s";
        const countEl = document.getElementById("tm-message-count");
        const durationEl = document.getElementById("tm-duration");
        if (countEl) countEl.textContent = messageCount;
        if (durationEl) durationEl.textContent = durationDisplay;
      }

      showInitialState() {
        const initial = document.getElementById("time-machine-initial");
        const controls = document.getElementById("time-machine-controls");
        if (initial) initial.style.display = "block";
        if (controls) controls.classList.remove("active");
      }

      showPlaybackState() {
        const initial = document.getElementById("time-machine-initial");
        const controls = document.getElementById("time-machine-controls");
        if (initial) initial.style.display = "none";
        if (controls) controls.classList.add("active");
      }


      play() {
        if (this.isPlaying) return;
        this.isPlaying = true;
        this.showPlaybackState();

        this.playInterval = setInterval(() => {
          if (this.currentIndex >= this.messages.length - 1) {
            this.pause();
            return;
          }
          this.next();
        }, this.playbackSpeed);

        this.updatePlayButton();
      }

      pause() {
        this.isPlaying = false;
        if (this.playInterval) {
          clearInterval(this.playInterval);
          this.playInterval = null;
        }
        this.updatePlayButton();
      }

      next() {
        if (this.currentIndex < this.messages.length - 1) {
          this.currentIndex++;
          this.displayUpToIndex();
          this.updateProgress();
        }
      }

      prev() {
        if (this.currentIndex > 0) {
          this.currentIndex--;
          this.displayUpToIndex();
          this.updateProgress();
        }
      }

      stop() {
        this.pause();
        this.currentIndex = this.messages.length - 1;
        this.displayUpToIndex();
        this.updateProgress();
        this.showInitialState();
        document
          .getElementById("time-machine-modal")
          .classList.remove("active");
      }

      branchFromCurrentPoint() {
        if (!this.sourceChat) return null;

        const branchChat = appState.createBranchChat(
          appState.currentUser.id,
          this.sourceChat,
          this.currentIndex
        );

        return branchChat;
      }

      displayUpToIndex() {
        const chatMessages = document.getElementById("chat-messages");
        chatMessages.innerHTML = "";

        for (let i = 0; i <= this.currentIndex; i++) {
          const msg = this.messages[i];
          ui.addMessageToUI(msg.role, msg.content, false);
        }

        ui.scrollToBottom();
      }

      updateProgress() {
        const progress = document.getElementById("time-machine-progress");
        if (progress) progress.textContent = `${this.currentIndex + 1} / ${this.messages.length}`;

        const current = document.getElementById("tm-current");
        const total = document.getElementById("tm-total");
        const progressFill = document.getElementById("tm-progress-fill");

        if (current) current.textContent = this.currentIndex + 1;
        if (total) total.textContent = this.messages.length;
        if (progressFill) {
          const percent = this.messages.length > 0 ? ((this.currentIndex + 1) / this.messages.length) * 100 : 0;
          progressFill.style.width = percent + "%";
        }
      }

      updatePlayButton() {
        const playButton = document.getElementById("time-machine-play");
        const icon = playButton.querySelector("i");
        if (this.isPlaying) {
          icon.className = "fas fa-pause";
        } else {
          icon.className = "fas fa-play";
        }
      }
    }

    // Initialize global instances
    const appState = new AppState();
    const soundManager = new SoundManager();
    const audioCache = new AudioCacheManager();
    const voiceManager = new VoiceManager();
    const timeMachine = new TimeMachine();
    const pttManager = new PushToTalkManager(voiceManager);
    const continuousListening = new ContinuousListeningManager(voiceManager);

    // Wire up audio cache to voice manager
    voiceManager.setAudioCache(audioCache);

    // Clean up old cached audio on startup (older than 7 days)
    audioCache.cleanup().catch(err => console.warn('Audio cache cleanup failed:', err));

    // Global replay voice function for cached audio playback
    window.replayVoice = async function(button) {
      const cacheKey = button.dataset.cacheKey;
      const voiceText = decodeURIComponent(button.dataset.voiceText);

      button.disabled = true;
      const originalHtml = button.innerHTML;
      button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Playing...';

      try {
        // Try to play from cache first
        if (cacheKey && await voiceManager.playFromCache(cacheKey)) {
          console.log('Played from cache:', cacheKey);
        } else {
          // Fall back to regenerating and caching the audio
          const newCacheKey = await voiceManager.speakAndCache(voiceText);
          if (newCacheKey && cacheKey !== newCacheKey) {
            button.dataset.cacheKey = newCacheKey;
          }
        }
      } catch (error) {
        console.error('Error replaying voice:', error);
        // Fall back to regular speak
        await voiceManager.speak(voiceText);
      } finally {
        button.disabled = false;
        button.innerHTML = originalHtml;
      }
    };

    // Global tracking for voice input messages
    window.pendingVoiceInput = {
      text: null,
      audioCacheKey: null,
      clear: function() {
        this.text = null;
        this.audioCacheKey = null;
      },
      set: function(text, audioCacheKey = null) {
        this.text = text;
        this.audioCacheKey = audioCacheKey;
      }
    };

    // Global replay function for user voice recordings (plays from cached audio blob)
    window.replayUserVoice = async function(button) {
      const cacheKey = button.dataset.cacheKey;

      if (!cacheKey) {
        console.warn('No cache key for user voice replay');
        return;
      }

      button.disabled = true;
      const originalHtml = button.innerHTML;
      button.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Playing...';

      try {
        // Get audio from cache
        const cached = await audioCache.get(cacheKey);
        if (cached && cached.audioBlob) {
          await voiceManager.playAudioBlob(cached.audioBlob);
        } else {
          console.warn('User voice recording not found in cache:', cacheKey);
          if (typeof ui !== 'undefined') {
            ui.showNotification('Recording not found in cache', 'warning');
          }
        }
      } catch (error) {
        console.error('Error replaying user voice:', error);
      } finally {
        button.disabled = false;
        button.innerHTML = originalHtml;
      }
    };

    // UI Controller
    class UIController {
      constructor() {
        this.loginPage = document.getElementById("login-page");
        this.appPage = document.getElementById("app");
        this.sidebar = document.getElementById("sidebar");
        this.sidebarOverlay = document.getElementById("sidebar-overlay");
        this.chatMessages = document.getElementById("chat-messages");
        this.userInput = document.getElementById("user-input");
        this.sendButton = document.getElementById("send-button");
        this.imagePreviewContainer = document.getElementById(
          "image-preview-container"
        );
        this.mentionDropdown = document.getElementById("mention-dropdown");
        this.pendingImage = null;
        this.mentionActive = false;
        this.mentionStartPos = -1;
        this.selectedMentionIndex = 0;
        this.currentEndpointId = null;
        this.editingEndpointId = null;

        this.initializeEventListeners();
        this.checkExistingSession();
      }

      initializeEventListeners() {
        // Login form
        document
          .getElementById("login-form")
          .addEventListener("submit", (e) => {
            e.preventDefault();
            this.handleLogin();
          });

        // Login page RAPPID import/export
        document
          .getElementById("login-import-rappid")
          .addEventListener("click", () => {
            document.getElementById("login-rappid-input").click();
          });

        document
          .getElementById("login-rappid-input")
          .addEventListener("change", (e) => {
            if (e.target.files[0]) {
              this.importRappidFromLogin(e.target.files[0]);
              e.target.value = '';
            }
          });

        document
          .getElementById("login-export-rappid")
          .addEventListener("click", () => {
            this.exportRappidFromLogin();
          });

        // RAPPID preview modal buttons
        document
          .getElementById("rappid-preview-cancel")
          .addEventListener("click", () => {
            this.hideRappidPreview();
          });

        document
          .getElementById("rappid-preview-confirm")
          .addEventListener("click", () => {
            this.confirmRappidImport();
          });

        // Close preview on overlay click
        document
          .getElementById("rappid-preview-overlay")
          .addEventListener("click", (e) => {
            if (e.target.id === "rappid-preview-overlay") {
              this.hideRappidPreview();
            }
          });

        // Header buttons
        document
          .getElementById("sidebar-toggle")
          .addEventListener("click", () => {
            this.toggleSidebar();
          });

        document
          .getElementById("archive-chat")
          .addEventListener("click", () => {
            this.archiveCurrentChat();
          });

        document
          .getElementById("theme-toggle")
          .addEventListener("click", () => {
            this.toggleTheme();
          });

        document.getElementById("logout").addEventListener("click", () => {
          this.logout();
        });

        // Clear chat button (floating)
        document
          .getElementById("clear-chat")
          .addEventListener("click", () => {
            this.clearCurrentChat();
          });

        // Voice toggle button - Continuous listening mode
        document
          .getElementById("voice-toggle")
          .addEventListener("click", () => {
            if (!voiceManager.isAzureSTTAvailable()) {
              this.showNotification(
                "Voice input requires Azure Speech key. Add it in Settings.",
                "warning"
              );
              return;
            }

            if (!appState.settings.voiceEnabled) {
              this.showNotification(
                "Voice features are disabled. Enable them in settings.",
                "info"
              );
              this.openSettings();
              return;
            }

            // Toggle continuous listening mode for real-time back-and-forth conversation
            continuousListening.toggle();
          });

        // Sidebar
        this.sidebarOverlay.addEventListener("click", () => {
          this.toggleSidebar();
        });

        // Sidebar tabs
        document.querySelectorAll(".sidebar-tab").forEach((tab) => {
          tab.addEventListener("click", (e) => {
            this.switchSidebarTab(e.target.dataset.tab);
          });
        });

        // Chat controls
        document.getElementById("new-chat").addEventListener("click", () => {
          this.createNewChat();
          this.toggleSidebar();
        });

        document
          .getElementById("send-button")
          .addEventListener("click", () => {
            this.sendMessage();
          });

        this.userInput.addEventListener("keypress", (e) => {
          if (e.key === "Enter" && !e.shiftKey) {
            e.preventDefault();
            this.sendMessage();
          }
        });

        // Mention autocomplete
        // Debounced resize for performance - Cycle 12 Feature
        let resizeRAF = null;
        const MAX_CHARS = 4000;
        const WARNING_THRESHOLD = 0.8;

        this.userInput.addEventListener("input", (e) => {
          this.handleMentionInput(e);

          // Cycle 24: Character count warning pulse
          const charCount = this.userInput.value.length;
          const charRatio = charCount / MAX_CHARS;
          this.userInput.classList.remove('char-warning', 'char-limit');
          if (charRatio >= 1) {
            this.userInput.classList.add('char-limit');
          } else if (charRatio >= WARNING_THRESHOLD) {
            this.userInput.classList.add('char-warning');
          }

          // Auto-resize textarea with rAF debounce to prevent layout thrashing
          if (resizeRAF) cancelAnimationFrame(resizeRAF);
          resizeRAF = requestAnimationFrame(() => {
            this.userInput.style.height = "auto";
            this.userInput.style.height =
              Math.min(this.userInput.scrollHeight, 120) + "px";
          });
        });

        this.userInput.addEventListener("keydown", (e) => {
          if (this.mentionActive) {
            this.handleMentionNavigation(e);
          }
        });

        // Image upload
        document
          .getElementById("upload-image")
          .addEventListener("click", () => {
            document.getElementById("image-upload-input").click();
          });

        document
          .getElementById("image-upload-input")
          .addEventListener("change", (e) => {
            if (e.target.files[0]) {
              this.handleImageUpload(e.target.files[0]);
            }
          });

        // Paste event for images
        this.userInput.addEventListener("paste", (e) => {
          const items = e.clipboardData.items;
          for (let item of items) {
            if (item.type.indexOf("image") !== -1) {
              const file = item.getAsFile();
              this.handleImageUpload(file);
              e.preventDefault();
            }
          }
        });

        // Menu
        const menuToggle = document.getElementById("menu-toggle");
        const menuItems = document.getElementById("menu-items");

        menuToggle.addEventListener("click", () => {
          const isOpen = menuToggle.classList.toggle("active");
          menuItems.classList.toggle("open");
        });

        // Close menu when clicking outside
        document.addEventListener("click", (e) => {
          if (
            !menuToggle.contains(e.target) &&
            !menuItems.contains(e.target)
          ) {
            menuToggle.classList.remove("active");
            menuItems.classList.remove("open");
          }
        });

        // Menu items
        document
          .getElementById("export-chat")
          .addEventListener("click", () => {
            this.exportCurrentChat();
            this.closeMenu();
          });

        document
          .getElementById("import-chat")
          .addEventListener("click", () => {
            document.getElementById("chat-import-input").click();
            this.closeMenu();
          });

        document
          .getElementById("export-all")
          .addEventListener("click", () => {
            this.exportAllData();
            this.closeMenu();
          });

        document
          .getElementById("import-all")
          .addEventListener("click", () => {
            document.getElementById("data-import-input").click();
            this.closeMenu();
          });

        document
          .getElementById("time-machine")
          .addEventListener("click", () => {
            this.openTimeMachine();
            this.closeMenu();
          });

        document.getElementById("settings").addEventListener("click", () => {
          this.openSettings();
          this.closeMenu();
        });

        // File inputs
        document
          .getElementById("chat-import-input")
          .addEventListener("change", (e) => {
            if (e.target.files[0]) {
              this.importChat(e.target.files[0]);
            }
          });

        document
          .getElementById("data-import-input")
          .addEventListener("change", (e) => {
            if (e.target.files[0]) {
              this.importAllData(e.target.files[0]);
            }
          });

        // Settings tab switching
        document.querySelectorAll('.settings-tab').forEach(tab => {
          tab.addEventListener('click', () => {
            const tabName = tab.dataset.tab;
            document.querySelectorAll('.settings-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            document.querySelectorAll('.settings-tab-content').forEach(c => c.classList.remove('active'));
            document.getElementById('settings-tab-' + tabName).classList.add('active');
          });
        });

        // Settings import/export
        document
          .getElementById("export-settings")
          .addEventListener("click", () => {
            this.exportSettings();
          });

        document
          .getElementById("import-settings")
          .addEventListener("click", () => {
            document.getElementById("settings-import-input").click();
          });

        document
          .getElementById("settings-import-input")
          .addEventListener("change", (e) => {
            if (e.target.files[0]) {
              this.importSettings(e.target.files[0]);
            }
          });

        // Drag and drop
        this.initializeDragAndDrop();

        // Settings modal
        document
          .getElementById("settings-close")
          .addEventListener("click", () => {
            document
              .getElementById("settings-modal")
              .classList.remove("active");
          });

        document
          .getElementById("cancel-settings")
          .addEventListener("click", () => {
            document
              .getElementById("settings-modal")
              .classList.remove("active");
          });

        document
          .getElementById("save-all-settings")
          .addEventListener("click", () => {
            this.saveAllSettings();
          });

        document
          .getElementById("dark-mode-toggle")
          .addEventListener("click", (e) => {
            e.target.classList.toggle("active");
          });

        document
          .getElementById("sound-toggle")
          .addEventListener("click", (e) => {
            e.target.classList.toggle("active");
          });

        document
          .getElementById("voice-enabled-toggle")
          .addEventListener("click", (e) => {
            e.target.classList.toggle("active");
          });

        document
          .getElementById("auto-speak-toggle")
          .addEventListener("click", (e) => {
            e.target.classList.toggle("active");
          });

        document
          .getElementById("clear-all-data")
          .addEventListener("click", () => {
            if (
              confirm(
                "Are you sure you want to clear all data? This cannot be undone."
              )
            ) {
              appState.clearAllData();
              location.reload();
            }
          });

        // Endpoint management
        document
          .getElementById("add-endpoint")
          .addEventListener("click", () => {
            this.openEndpointModal();
          });

        document
          .getElementById("endpoint-modal-close")
          .addEventListener("click", () => {
            this.closeEndpointModal();
          });

        document
          .getElementById("cancel-endpoint")
          .addEventListener("click", () => {
            this.closeEndpointModal();
          });

        document
          .getElementById("save-endpoint")
          .addEventListener("click", () => {
            this.saveEndpoint();
          });

        // Endpoint search filter
        document
          .getElementById("endpoint-search")
          .addEventListener("input", (e) => {
            this.loadEndpointList(e.target.value);
          });

        // Test all endpoints
        document
          .getElementById("test-all-endpoints")
          .addEventListener("click", () => {
            this.testAllEndpoints();
          });

        // Add local endpoint quick action
        document
          .getElementById("add-local-endpoint")
          .addEventListener("click", () => {
            this.openEndpointModal(null, true);
          });

        // Test endpoint button in modal
        document
          .getElementById("test-endpoint")
          .addEventListener("click", async () => {
            const url = document.getElementById('endpoint-url').value.trim();
            const key = document.getElementById('endpoint-key').value.trim();
            if (!url) {
              this.showNotification('Please enter a URL first', 'warning');
              return;
            }
            const testBtn = document.getElementById('test-endpoint');
            const originalHtml = testBtn.innerHTML;
            testBtn.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Testing...';
            testBtn.disabled = true;

            const result = await this.testEndpointConnection({ url, key });
            testBtn.innerHTML = originalHtml;
            testBtn.disabled = false;

            this.showNotification(
              result.success ? 'Connection successful!' : `Connection failed: ${result.error}`,
              result.success ? 'success' : 'error'
            );
          });

        // Time Machine modal
        document
          .getElementById("time-machine-close")
          .addEventListener("click", () => {
            timeMachine.stop();
          });

        document
          .getElementById("time-machine-start")
          .addEventListener("click", () => {
            const chat =
              appState.chats[appState.currentUser.id][appState.currentChatId];
            if (chat && chat.messages.length > 0) {
              timeMachine.init(chat.messages, chat);
              document
                .getElementById("time-machine-controls")
                .classList.remove("hidden");
              timeMachine.displayUpToIndex();
            }
          });

        document
          .getElementById("time-machine-prev")
          .addEventListener("click", () => {
            timeMachine.prev();
          });

        document
          .getElementById("time-machine-play")
          .addEventListener("click", () => {
            if (timeMachine.isPlaying) {
              timeMachine.pause();
            } else {
              timeMachine.play();
            }
          });

        document
          .getElementById("time-machine-next")
          .addEventListener("click", () => {
            timeMachine.next();
          });

        document
          .getElementById("time-machine-stop")
          .addEventListener("click", () => {
            timeMachine.stop();
          });

        document
          .getElementById("time-machine-branch")
          .addEventListener("click", () => {
            const branchChat = timeMachine.branchFromCurrentPoint();
            if (branchChat) {
              document
                .getElementById("time-machine-modal")
                .classList.remove("active");

              this.loadChat(branchChat.id);
              this.loadUserChats("active");

              this.showNotification(
                `Created branch from message ${timeMachine.currentIndex + 1}. You can now continue the conversation from this point.`,
                "success"
              );
            }
          });
      }

      handleMentionInput(e) {
        const value = this.userInput.value;
        const cursorPos = this.userInput.selectionStart;

        // Check for @ symbol
        const lastAtPos = value.lastIndexOf('@', cursorPos - 1);

        if (lastAtPos >= 0 && (lastAtPos === 0 || value[lastAtPos - 1] === ' ')) {
          const searchTerm = value.substring(lastAtPos + 1, cursorPos).toLowerCase();

          // Don't show dropdown if there's a space after @
          if (searchTerm.includes(' ')) {
            this.closeMentionDropdown();
            return;
          }

          this.mentionActive = true;
          this.mentionStartPos = lastAtPos;
          this.showMentionDropdown(searchTerm);
        } else {
          this.closeMentionDropdown();
        }
      }

      showMentionDropdown(searchTerm) {
        const endpoints = Object.values(appState.endpoints).filter(endpoint =>
          endpoint.name.toLowerCase().includes(searchTerm)
        );

        if (endpoints.length === 0) {
          this.closeMentionDropdown();
          return;
        }

        this.mentionDropdown.innerHTML = '';
        this.selectedMentionIndex = 0;

        endpoints.forEach((endpoint, index) => {
          const item = document.createElement('div');
          item.className = 'mention-item' + (index === 0 ? ' selected' : '');
          // Cycle 15 Accessibility: Add role and aria-selected for screen readers
          item.setAttribute('role', 'option');
          item.setAttribute('aria-selected', index === 0 ? 'true' : 'false');
          item.innerHTML = `
            <div class="mention-item-icon">${endpoint.name.charAt(0).toUpperCase()}</div>
            <div class="mention-item-info">
              <div class="mention-item-name">${endpoint.name}</div>
              <div class="mention-item-url">${endpoint.url}</div>
            </div>
          `;

          item.addEventListener('click', () => {
            this.selectMention(endpoint);
          });

          this.mentionDropdown.appendChild(item);
        });

        this.mentionDropdown.classList.add('active');
      }

      handleMentionNavigation(e) {
        const items = this.mentionDropdown.querySelectorAll('.mention-item');

        if (e.key === 'ArrowDown') {
          e.preventDefault();
          this.selectedMentionIndex = Math.min(this.selectedMentionIndex + 1, items.length - 1);
          this.updateMentionSelection();
        } else if (e.key === 'ArrowUp') {
          e.preventDefault();
          this.selectedMentionIndex = Math.max(this.selectedMentionIndex - 1, 0);
          this.updateMentionSelection();
        } else if (e.key === 'Enter' || e.key === 'Tab') {
          e.preventDefault();
          const endpoints = Object.values(appState.endpoints);
          const visibleEndpoints = Array.from(items).map(item => {
            const name = item.querySelector('.mention-item-name').textContent;
            return endpoints.find(ep => ep.name === name);
          });

          if (visibleEndpoints[this.selectedMentionIndex]) {
            this.selectMention(visibleEndpoints[this.selectedMentionIndex]);
          }
        } else if (e.key === 'Escape') {
          this.closeMentionDropdown();
        }
      }

      updateMentionSelection() {
        const items = this.mentionDropdown.querySelectorAll('.mention-item');
        items.forEach((item, index) => {
          const isSelected = index === this.selectedMentionIndex;
          item.classList.toggle('selected', isSelected);
          // Cycle 15 Accessibility: Update aria-selected state
          item.setAttribute('aria-selected', isSelected ? 'true' : 'false');
        });
      }

      selectMention(endpoint) {
        const value = this.userInput.value;
        const beforeMention = value.substring(0, this.mentionStartPos);
        const afterMention = value.substring(this.userInput.selectionStart);

        this.userInput.value = `${beforeMention}@${endpoint.name} ${afterMention}`;
        this.currentEndpointId = endpoint.id;

        const newCursorPos = beforeMention.length + endpoint.name.length + 2;
        this.userInput.setSelectionRange(newCursorPos, newCursorPos);

        this.closeMentionDropdown();
        this.userInput.focus();
      }

      closeMentionDropdown() {
        this.mentionActive = false;
        this.mentionStartPos = -1;
        this.selectedMentionIndex = 0;
        this.mentionDropdown.classList.remove('active');
        this.mentionDropdown.innerHTML = '';
      }

      openEndpointModal(endpointId = null, prefillLocal = false) {
        this.editingEndpointId = endpointId;
        const modal = document.getElementById('endpoint-modal');
        const title = document.getElementById('endpoint-modal-title');

        if (endpointId) {
          title.textContent = 'Edit Endpoint';
          const endpoint = appState.getEndpointById(endpointId);
          document.getElementById('endpoint-name').value = endpoint.name;
          document.getElementById('endpoint-env').value = endpoint.env || 'production';
          document.getElementById('endpoint-url').value = endpoint.url;
          document.getElementById('endpoint-key').value = endpoint.key;
          document.getElementById('endpoint-guid').value = endpoint.guid;
        } else {
          title.textContent = 'Add Endpoint';
          document.getElementById('endpoint-name').value = prefillLocal ? 'Local Dev' : '';
          document.getElementById('endpoint-env').value = prefillLocal ? 'local' : 'production';
          document.getElementById('endpoint-url').value = prefillLocal ? 'http://localhost:7071/api/businessinsightbot_function' : '';
          document.getElementById('endpoint-key').value = '';
          document.getElementById('endpoint-guid').value = 'c0p110t0-aaaa-bbbb-cccc-123456789abc';
        }

        modal.classList.add('active');

        // Modal Auto-Focus - Cycle 6 Feature
        setTimeout(() => document.getElementById('endpoint-name').focus(), 50);
      }

      closeEndpointModal() {
        document.getElementById('endpoint-modal').classList.remove('active');
        this.editingEndpointId = null;
      }

      saveEndpoint() {
        const name = document.getElementById('endpoint-name').value.trim();
        const env = document.getElementById('endpoint-env').value;
        const url = document.getElementById('endpoint-url').value.trim();
        const key = document.getElementById('endpoint-key').value.trim();
        const guid = document.getElementById('endpoint-guid').value.trim() || 'c0p110t0-aaaa-bbbb-cccc-123456789abc';

        if (!name || !url) {
          this.showNotification('Please fill in name and URL', 'warning');
          return;
        }

        if (this.editingEndpointId) {
          appState.updateEndpoint(this.editingEndpointId, { name, env, url, key, guid });
        } else {
          appState.addEndpoint(name, url, key, guid, env);
        }

        this.loadEndpointList();
        this.closeEndpointModal();
        this.showNotification('Endpoint saved successfully!', 'success');
      }

      async testEndpointConnection(endpoint, statusIndicator = null) {
        if (statusIndicator) {
          statusIndicator.className = 'endpoint-status-indicator testing';
        }

        try {
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 5000);

          const headers = { 'Content-Type': 'application/json' };
          if (endpoint.key) {
            headers['x-functions-key'] = endpoint.key;
          }

          const response = await fetch(endpoint.url, {
            method: 'POST',
            headers,
            body: JSON.stringify({ user_input: 'ping', conversation_history: [] }),
            signal: controller.signal
          });

          clearTimeout(timeoutId);

          if (response.ok) {
            if (statusIndicator) {
              statusIndicator.className = 'endpoint-status-indicator online';
            }
            // Update last tested time
            appState.updateEndpoint(endpoint.id, { lastTested: new Date().toISOString(), status: 'online' });
            return { success: true, status: 'online' };
          } else {
            if (statusIndicator) {
              statusIndicator.className = 'endpoint-status-indicator offline';
            }
            appState.updateEndpoint(endpoint.id, { lastTested: new Date().toISOString(), status: 'offline' });
            return { success: false, status: 'offline', error: `HTTP ${response.status}` };
          }
        } catch (error) {
          if (statusIndicator) {
            statusIndicator.className = 'endpoint-status-indicator offline';
          }
          appState.updateEndpoint(endpoint.id, { lastTested: new Date().toISOString(), status: 'offline' });
          return { success: false, status: 'offline', error: error.message };
        }
      }

      async testAllEndpoints() {
        const endpoints = Object.values(appState.endpoints);
        this.showNotification(`Testing ${endpoints.length} endpoints...`, 'info');

        let online = 0;
        let offline = 0;

        for (const endpoint of endpoints) {
          const statusIndicator = document.querySelector(`[data-endpoint-id="${endpoint.id}"] .endpoint-status-indicator`);
          const result = await this.testEndpointConnection(endpoint, statusIndicator);
          if (result.success) {
            online++;
          } else {
            offline++;
          }
        }

        this.showNotification(`Test complete: ${online} online, ${offline} offline`, online > 0 ? 'success' : 'warning');
      }

      duplicateEndpoint(endpointId) {
        const endpoint = appState.getEndpointById(endpointId);
        if (!endpoint) return;

        const newName = `${endpoint.name} (Copy)`;
        appState.addEndpoint(newName, endpoint.url, endpoint.key, endpoint.guid, endpoint.env || 'production');
        this.loadEndpointList();
        this.showNotification(`Duplicated "${endpoint.name}"`, 'success');
      }

      loadEndpointList(filterText = '') {
        const endpointList = document.getElementById('endpoint-list');
        endpointList.innerHTML = '';

        let endpoints = Object.values(appState.endpoints);

        // Apply filter if provided
        if (filterText) {
          const search = filterText.toLowerCase();
          endpoints = endpoints.filter(ep =>
            ep.name.toLowerCase().includes(search) ||
            ep.url.toLowerCase().includes(search) ||
            (ep.env || '').toLowerCase().includes(search)
          );
        }

        // Sort by order if available, otherwise by name
        endpoints.sort((a, b) => {
          if (a.order !== undefined && b.order !== undefined) {
            return a.order - b.order;
          }
          return a.name.localeCompare(b.name);
        });

        if (endpoints.length === 0) {
          endpointList.innerHTML = `
            <div class="endpoint-empty-state">
              <i class="fas fa-server"></i>
              <p>${filterText ? 'No endpoints match your search' : 'No endpoints configured yet'}</p>
            </div>
          `;
          return;
        }

        endpoints.forEach((endpoint, index) => {
          const item = document.createElement('div');
          const env = endpoint.env || this.detectEnvironment(endpoint.url);
          const statusClass = endpoint.status || '';
          const lastUsed = endpoint.lastUsed ? this.formatRelativeTime(endpoint.lastUsed) : 'Never used';

          item.className = `endpoint-item ${endpoint.active ? 'active' : ''}`;
          item.setAttribute('data-endpoint-id', endpoint.id);
          item.setAttribute('draggable', 'true');

          item.innerHTML = `
            <div class="endpoint-drag-handle">
              <i class="fas fa-grip-vertical"></i>
            </div>
            <div class="endpoint-item-icon ${env}">
              ${endpoint.name.charAt(0).toUpperCase()}
              <div class="endpoint-status-indicator ${statusClass}"></div>
            </div>
            <div class="endpoint-item-info">
              <div class="endpoint-item-header">
                <span class="endpoint-item-name">${endpoint.name}</span>
                <span class="endpoint-env-tag ${env}">${env}</span>
              </div>
              <div class="endpoint-item-url">${endpoint.url}</div>
              <div class="endpoint-item-meta">
                <span><i class="fas fa-clock"></i> ${lastUsed}</span>
                ${endpoint.active ? '<span><i class="fas fa-star"></i> Default</span>' : ''}
              </div>
            </div>
            <div class="endpoint-item-actions">
              <button class="endpoint-item-action ${endpoint.active ? 'active' : ''}" data-tooltip="${endpoint.active ? 'Default' : 'Set as default'}">
                <i class="fas fa-check"></i>
              </button>
              <button class="endpoint-item-action test-btn" data-tooltip="Test connection">
                <i class="fas fa-bolt"></i>
              </button>
              <button class="endpoint-item-action duplicate-btn" data-tooltip="Duplicate">
                <i class="fas fa-copy"></i>
              </button>
              <button class="endpoint-item-action" data-tooltip="Edit">
                <i class="fas fa-edit"></i>
              </button>
              <button class="endpoint-item-action delete-btn" data-tooltip="Delete">
                <i class="fas fa-trash"></i>
              </button>
            </div>
          `;

          // Drag and drop handlers
          item.addEventListener('dragstart', (e) => {
            item.classList.add('dragging');
            e.dataTransfer.setData('text/plain', endpoint.id);
          });

          item.addEventListener('dragend', () => {
            item.classList.remove('dragging');
            document.querySelectorAll('.endpoint-item').forEach(el => el.classList.remove('drag-over'));
          });

          item.addEventListener('dragover', (e) => {
            e.preventDefault();
            const dragging = document.querySelector('.endpoint-item.dragging');
            if (dragging && dragging !== item) {
              item.classList.add('drag-over');
            }
          });

          item.addEventListener('dragleave', () => {
            item.classList.remove('drag-over');
          });

          item.addEventListener('drop', (e) => {
            e.preventDefault();
            item.classList.remove('drag-over');
            const draggedId = e.dataTransfer.getData('text/plain');
            if (draggedId && draggedId !== endpoint.id) {
              this.reorderEndpoints(draggedId, endpoint.id);
            }
          });

          const actions = item.querySelectorAll('.endpoint-item-action');

          // Set active
          actions[0].addEventListener('click', (e) => {
            e.stopPropagation();
            appState.setActiveEndpoint(endpoint.id);
            this.loadEndpointList();
          });

          // Test connection
          actions[1].addEventListener('click', async (e) => {
            e.stopPropagation();
            const statusIndicator = item.querySelector('.endpoint-status-indicator');
            const result = await this.testEndpointConnection(endpoint, statusIndicator);
            this.showNotification(
              result.success ? `${endpoint.name} is online!` : `${endpoint.name} is offline: ${result.error}`,
              result.success ? 'success' : 'error'
            );
          });

          // Duplicate
          actions[2].addEventListener('click', (e) => {
            e.stopPropagation();
            this.duplicateEndpoint(endpoint.id);
          });

          // Edit
          actions[3].addEventListener('click', (e) => {
            e.stopPropagation();
            this.openEndpointModal(endpoint.id);
          });

          // Delete
          actions[4].addEventListener('click', (e) => {
            e.stopPropagation();
            if (confirm(`Delete endpoint "${endpoint.name}"?`)) {
              appState.deleteEndpoint(endpoint.id);
              this.loadEndpointList();
              this.showNotification(`Deleted "${endpoint.name}"`, 'info');
            }
          });

          // Click on item to select
          item.addEventListener('click', () => {
            appState.setActiveEndpoint(endpoint.id);
            this.loadEndpointList();
          });

          endpointList.appendChild(item);
        });
      }

      detectEnvironment(url) {
        const lowerUrl = url.toLowerCase();
        if (lowerUrl.includes('localhost') || lowerUrl.includes('127.0.0.1')) return 'local';
        if (lowerUrl.includes('staging') || lowerUrl.includes('stg')) return 'staging';
        if (lowerUrl.includes('dev') || lowerUrl.includes('development')) return 'development';
        return 'production';
      }

      formatRelativeTime(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const diffMs = now - date;
        const diffMins = Math.floor(diffMs / 60000);
        const diffHours = Math.floor(diffMs / 3600000);
        const diffDays = Math.floor(diffMs / 86400000);

        if (diffMins < 1) return 'Just now';
        if (diffMins < 60) return `${diffMins}m ago`;
        if (diffHours < 24) return `${diffHours}h ago`;
        if (diffDays < 7) return `${diffDays}d ago`;
        return date.toLocaleDateString();
      }

      reorderEndpoints(draggedId, targetId) {
        const endpoints = Object.values(appState.endpoints);
        const draggedIndex = endpoints.findIndex(ep => ep.id === draggedId);
        const targetIndex = endpoints.findIndex(ep => ep.id === targetId);

        if (draggedIndex === -1 || targetIndex === -1) return;

        // Reorder
        const [dragged] = endpoints.splice(draggedIndex, 1);
        endpoints.splice(targetIndex, 0, dragged);

        // Update order values
        endpoints.forEach((ep, idx) => {
          appState.updateEndpoint(ep.id, { order: idx });
        });

        this.loadEndpointList();
      }

      initializeDragAndDrop() {
        const dropZone = document.getElementById("drop-zone");
        let dragCounter = 0;

        document.addEventListener("dragenter", (e) => {
          e.preventDefault();
          dragCounter++;
          dropZone.classList.add("active");
        });

        document.addEventListener("dragleave", (e) => {
          e.preventDefault();
          dragCounter--;
          if (dragCounter === 0) {
            dropZone.classList.remove("active");
          }
        });

        document.addEventListener("dragover", (e) => {
          e.preventDefault();
        });

        document.addEventListener("drop", (e) => {
          e.preventDefault();
          dragCounter = 0;
          dropZone.classList.remove("active");

          const files = Array.from(e.dataTransfer.files);
          files.forEach((file) => {
            if (file.type.startsWith("image/")) {
              this.handleImageUpload(file);
            } else if (file.type === "application/json") {
              this.handleJsonImport(file);
            }
          });
        });
      }

      checkExistingSession() {
        const lastUserId = localStorage.getItem("lastUserId");
        if (lastUserId && appState.users[lastUserId]) {
          appState.currentUser = appState.users[lastUserId];
          this.showApp();
        } else {
          this.showLogin();
        }
      }

      showLogin() {
        this.loginPage.classList.remove("hidden");
        this.appPage.classList.add("hidden");
        this.loadRecentUsers();
      }

      showApp() {
        this.loginPage.classList.add("hidden");
        this.appPage.classList.remove("hidden");

        document.getElementById("current-username").textContent =
          appState.currentUser.username;

        this.loadUserChats();
        this.applyTheme();
        this.applySettings();

        const activeChats = appState.getActiveChats(appState.currentUser.id);
        if (activeChats.length > 0) {
          this.loadChat(activeChats[0].id);
        } else {
          this.createNewChat();
        }
      }

      loadRecentUsers() {
        const recentUsersContainer = document.getElementById("recent-users");
        const userCountEl = document.getElementById("user-count");
        recentUsersContainer.innerHTML = "";

        const users = Object.values(appState.users)
          .sort((a, b) => new Date(b.lastActive) - new Date(a.lastActive))
          .slice(0, 5);

        // Update user count
        const totalUsers = Object.keys(appState.users).length;
        if (userCountEl) {
          userCountEl.textContent = totalUsers > 0 ? `${totalUsers} user${totalUsers !== 1 ? 's' : ''}` : '';
        }

        if (users.length === 0) {
          recentUsersContainer.innerHTML = `
            <div class="login-empty-state">
              <i class="fas fa-user-plus"></i>
              <p>No users yet. Enter a username to get started!</p>
            </div>
          `;
          return;
        }

        users.forEach((user) => {
          const userElement = document.createElement("div");
          userElement.className = "user-item";
          
          // Get user stats
          const userChats = appState.chats[user.id] || {};
          const chatCount = Object.keys(userChats).length;
          const initials = user.username.substring(0, 2).toUpperCase();
          
          userElement.innerHTML = `
            <div class="user-item-avatar">${initials}</div>
            <div class="user-item-info">
              <div class="user-item-name">${user.username}</div>
              <div class="user-item-meta">
                <span><i class="fas fa-clock"></i> ${this.formatDate(user.lastActive)}</span>
                <span><i class="fas fa-comments"></i> ${chatCount} chat${chatCount !== 1 ? 's' : ''}</span>
              </div>
            </div>
            <div class="user-item-actions">
              <button class="user-item-action delete" title="Delete user" data-user-id="${user.id}">
                <i class="fas fa-trash"></i>
              </button>
            </div>
            <i class="fas fa-chevron-right user-item-arrow"></i>
          `;

          // Click on user to login
          userElement.addEventListener("click", (e) => {
            if (e.target.closest('.user-item-action')) return;
            document.getElementById("username").value = user.username;
            this.handleLogin();
          });

          // Delete user button
          const deleteBtn = userElement.querySelector('.user-item-action.delete');
          deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            if (confirm(`Delete user "${user.username}" and all their data?`)) {
              this.deleteUser(user.id);
            }
          });

          recentUsersContainer.appendChild(userElement);
        });
      }

      deleteUser(userId) {
        // Delete user's chats
        if (appState.chats[userId]) {
          delete appState.chats[userId];
          appState.saveChats();
        }
        // Delete user
        if (appState.users[userId]) {
          delete appState.users[userId];
          appState.saveUsers();
        }
        // Refresh the list
        this.loadRecentUsers();
        this.showNotification('User deleted', 'info');
      }

      importRappidFromLogin(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);
            
            // Validate RAPPID format
            const isRappid = data.rappid === true || data.backupType === "RAPPID Settings Backup";
            if (!isRappid && !data.endpoints) {
              throw new Error("Invalid RAPPID file format");
            }

            // Store pending import data and show preview
            this.pendingRappidImport = data;
            this.showRappidPreview(data, file.name);
          } catch (error) {
            this.showNotification(`Import failed: ${error.message}`, 'error');
          }
        };
        reader.readAsText(file);
      }

      showRappidPreview(data, filename) {
        const overlay = document.getElementById('rappid-preview-overlay');
        const body = document.getElementById('rappid-preview-body');
        const filenameEl = document.getElementById('rappid-preview-filename');
        
        filenameEl.textContent = filename || 'RAPPID Backup';

        const endpoints = Object.values(data.endpoints || {});
        const endpointCount = endpoints.length;
        const activeEndpoint = endpoints.find(ep => ep.active);
        
        // Detect environment from URL
        const detectEnv = (url) => {
          const lower = url.toLowerCase();
          if (lower.includes('localhost') || lower.includes('127.0.0.1')) return 'local';
          return 'production';
        };

        // Mask sensitive data
        const maskKey = (key) => {
          if (!key) return '(not set)';
          if (key.length <= 8) return '';
          return key.substring(0, 4) + '' + key.substring(key.length - 4);
        };

        let html = '';

        // Endpoints section
        if (endpointCount > 0) {
          html += `
            <div class="rappid-preview-section">
              <div class="rappid-preview-section-header">
                <i class="fas fa-server"></i>
                <h3>API Endpoints</h3>
                <span>${endpointCount} endpoint${endpointCount !== 1 ? 's' : ''}</span>
              </div>
              ${endpoints.map(ep => {
                const env = detectEnv(ep.url);
                const initials = ep.name.substring(0, 2).toUpperCase();
                return `
                  <div class="rappid-endpoint-item ${ep.active ? 'active' : ''}">
                    <div class="rappid-endpoint-avatar ${env}">${initials}</div>
                    <div class="rappid-endpoint-info">
                      <div class="rappid-endpoint-name">
                        ${ep.name}
                        ${ep.active ? '<span class="active-badge">Active</span>' : ''}
                      </div>
                      <div class="rappid-endpoint-url">${ep.url}</div>
                    </div>
                  </div>
                `;
              }).join('')}
            </div>
          `;
        }

        // TTS Settings section
        const hasTTSSettings = data.azureTTSKey || data.ttsVoiceName;
        if (hasTTSSettings) {
          html += `
            <div class="rappid-preview-section">
              <div class="rappid-preview-section-header">
                <i class="fas fa-microphone"></i>
                <h3>Voice Settings</h3>
              </div>
              ${data.azureTTSKey ? `
                <div class="rappid-setting-item">
                  <label>Azure TTS Key</label>
                  <span class="masked">${maskKey(data.azureTTSKey)}</span>
                </div>
              ` : ''}
              ${data.azureRegion ? `
                <div class="rappid-setting-item">
                  <label>Region</label>
                  <span>${data.azureRegion}</span>
                </div>
              ` : ''}
              ${data.ttsVoiceName ? `
                <div class="rappid-setting-item">
                  <label>Voice</label>
                  <span>${data.ttsVoiceName}</span>
                </div>
              ` : ''}
            </div>
          `;
        }

        // Users section (if present)
        const users = Object.values(data.users || {});
        if (users.length > 0) {
          html += `
            <div class="rappid-preview-section">
              <div class="rappid-preview-section-header">
                <i class="fas fa-users"></i>
                <h3>Users</h3>
                <span>${users.length} user${users.length !== 1 ? 's' : ''}</span>
              </div>
              ${users.map(user => `
                <div class="rappid-setting-item">
                  <label>${user.username}</label>
                  <span>${user.lastActive ? 'Last active: ' + new Date(user.lastActive).toLocaleDateString() : ''}</span>
                </div>
              `).join('')}
            </div>
          `;
        }

        // Export info
        if (data.exportDate) {
          const exportDate = new Date(data.exportDate);
          html += `
            <div class="rappid-preview-meta">
              Exported on ${exportDate.toLocaleDateString()} at ${exportDate.toLocaleTimeString()}
              ${data.version ? `  Version ${data.version}` : ''}
            </div>
          `;
        }

        body.innerHTML = html;
        overlay.classList.add('active');
      }

      hideRappidPreview() {
        document.getElementById('rappid-preview-overlay').classList.remove('active');
        this.pendingRappidImport = null;
      }

      confirmRappidImport() {
        const data = this.pendingRappidImport;
        if (!data) return;

        // Import endpoints
        const importedCount = Object.keys(data.endpoints || {}).length;
        if (data.endpoints) {
          Object.entries(data.endpoints).forEach(([id, endpoint]) => {
            if (!appState.endpoints[id]) {
              appState.endpoints[id] = endpoint;
            } else {
              appState.endpoints[id] = { ...appState.endpoints[id], ...endpoint };
            }
          });
          appState.saveEndpoints();
        }

        // Import TTS settings
        if (data.azureTTSKey) {
          appState.settings.azureTTSKey = data.azureTTSKey;
        }
        if (data.azureRegion) {
          appState.settings.azureRegion = data.azureRegion;
        }
        if (data.ttsVoiceName) {
          appState.settings.ttsVoiceName = data.ttsVoiceName;
        }
        appState.saveSettings();

        // Import users if present
        let userToLogin = null;
        if (data.users && Object.keys(data.users).length > 0) {
          Object.entries(data.users).forEach(([id, user]) => {
            if (!appState.users[id]) {
              appState.users[id] = user;
            }
          });
          appState.saveUsers();
          
          // Find the most recently active user to auto-login
          const importedUsers = Object.values(data.users);
          userToLogin = importedUsers.sort((a, b) => 
            new Date(b.lastActive || 0) - new Date(a.lastActive || 0)
          )[0];
        }

        this.hideRappidPreview();
        
        // Show success notification
        this.showNotification(
          `RAPPID imported! ${importedCount} endpoint${importedCount !== 1 ? 's' : ''} loaded.`,
          'success'
        );

        // Auto-login the user
        if (userToLogin) {
          // Use the imported user
          appState.currentUser = appState.users[userToLogin.id] || userToLogin;
          localStorage.setItem("lastUserId", userToLogin.id);
          
          // Small delay to show the notification before transitioning
          setTimeout(() => {
            this.showApp();
            this.showNotification(`Welcome back, ${userToLogin.username}!`, 'success');
          }, 500);
        } else {
          // No users in import, create a default user and login
          const defaultUsername = 'User';
          let user = Object.values(appState.users).find(u => u.username === defaultUsername);
          if (!user) {
            user = appState.createUser(defaultUsername);
          }
          appState.currentUser = user;
          localStorage.setItem("lastUserId", user.id);
          
          setTimeout(() => {
            this.showApp();
            this.showNotification(`Settings loaded! Logged in as ${user.username}.`, 'success');
          }, 500);
        }
      }

      exportRappidFromLogin() {
        const data = {
          rappid: true,
          backupType: "RAPPID Settings Backup",
          version: "1.0",
          exportDate: new Date().toISOString(),
          endpoints: appState.endpoints,
          azureTTSKey: appState.settings.azureTTSKey || "",
          azureRegion: appState.settings.azureRegion || "eastus2",
          ttsVoiceName: appState.settings.ttsVoiceName || "en-US-JennyNeural",
          users: appState.users
        };

        const endpointCount = Object.keys(data.endpoints).length;
        const userCount = Object.keys(data.users).length;
        
        if (endpointCount === 0 && userCount === 0) {
          this.showNotification('Nothing to export yet. Add some endpoints or users first!', 'warning');
          return;
        }

        const filename = `rappid-backup-${new Date().toISOString().replace(/:/g, "-")}.json`;
        this.downloadJson(data, filename);
        this.showNotification(
          `RAPPID exported! ${endpointCount} endpoint${endpointCount !== 1 ? 's' : ''}, ${userCount} user${userCount !== 1 ? 's' : ''}.`,
          'success'
        );
      }

      handleLogin() {
        const username = document.getElementById("username").value.trim();
        if (!username) return;

        let user = Object.values(appState.users).find(
          (u) => u.username === username
        );
        if (!user) {
          user = appState.createUser(username);
        }

        appState.currentUser = user;
        localStorage.setItem("lastUserId", user.id);

        this.showApp();
      }

      logout() {
        appState.currentUser = null;
        localStorage.removeItem("lastUserId");
        this.showLogin();
      }

      toggleSidebar() {
        this.sidebar.classList.toggle("open");
        this.sidebarOverlay.classList.toggle("active");
      }

      switchSidebarTab(tab) {
        document.querySelectorAll(".sidebar-tab").forEach((t) => {
          const isActive = t.dataset.tab === tab;
          t.classList.toggle("active", isActive);
          // Cycle 27: aria-current for accessibility
          t.setAttribute("aria-current", isActive ? "page" : "false");
        });

        document
          .getElementById("chat-list-active")
          .classList.toggle("hidden", tab !== "active");
        document
          .getElementById("chat-list-archived")
          .classList.toggle("hidden", tab !== "archived");

        this.loadUserChats(tab);
      }

      loadUserChats(tab = "active") {
        const containerId =
          tab === "active" ? "chat-list-active" : "chat-list-archived";
        const chatList = document.getElementById(containerId);
        chatList.innerHTML = "";

        const chats =
          tab === "active"
            ? appState.getActiveChats(appState.currentUser.id)
            : appState.getArchivedChats(appState.currentUser.id);

        if (chats.length === 0) {
          chatList.innerHTML = `<div class="chat-list-empty">No ${tab} chats</div>`;
          return;
        }

        chats.forEach((chat) => {
          const chatElement = document.createElement("div");
          chatElement.className = "chat-item";
          if (chat.id === appState.currentChatId) {
            chatElement.classList.add("active");
          }

          const lastMessage = chat.messages[chat.messages.length - 1];
          const preview = lastMessage
            ? this.truncateText(lastMessage.content, 50)
            : "New conversation";

          chatElement.innerHTML = `
            <div class="chat-item-title">${chat.title}</div>
            <div class="chat-item-preview">${preview}</div>
            <div class="chat-item-date">${this.formatDate(
            chat.updatedAt
          )}</div>
            <div class="chat-item-actions">
              ${tab === "active"
              ? '<button class="chat-item-action" title="Archive"><i class="fas fa-archive"></i></button>'
              : '<button class="chat-item-action" title="Restore"><i class="fas fa-undo"></i></button>'
            }
              <button class="chat-item-action" title="Delete"><i class="fas fa-trash"></i></button>
            </div>
          `;

          chatElement.addEventListener("click", (e) => {
            if (!e.target.closest(".chat-item-action")) {
              this.loadChat(chat.id);
              this.toggleSidebar();
            }
          });

          const archiveBtn = chatElement.querySelector(
            ".chat-item-action:first-child"
          );
          archiveBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            if (tab === "active") {
              appState.archiveChat(appState.currentUser.id, chat.id);
              if (chat.id === appState.currentChatId) {
                this.createNewChat();
              }
            } else {
              appState.unarchiveChat(appState.currentUser.id, chat.id);
            }
            this.loadUserChats(tab);
          });

          const deleteBtn = chatElement.querySelector(
            ".chat-item-action:last-child"
          );
          deleteBtn.addEventListener("click", (e) => {
            e.stopPropagation();
            if (
              confirm(
                "Are you sure you want to permanently delete this chat?"
              )
            ) {
              appState.deleteChat(appState.currentUser.id, chat.id);
              if (chat.id === appState.currentChatId) {
                this.createNewChat();
              }
              this.loadUserChats(tab);
            }
          });

          chatList.appendChild(chatElement);
        });
      }

      createNewChat() {
        const chat = appState.createChat(appState.currentUser.id);
        appState.currentChatId = chat.id;
        this.currentEndpointId = null;
        this.loadUserChats("active");
        this.clearChatMessages();
      }

      loadChat(chatId) {
        const chat = appState.chats[appState.currentUser.id][chatId];
        if (!chat) return;

        appState.currentChatId = chatId;
        this.currentEndpointId = null;
        this.loadUserChats(chat.archived ? "archived" : "active");
        this.displayChatMessages(chat.messages);
      }

      clearCurrentChat() {
        if (!appState.currentChatId) return;

        const chat =
          appState.chats[appState.currentUser.id][appState.currentChatId];
        if (!chat || chat.messages.length === 0) {
          this.createNewChat();
          return;
        }

        if (chat.archived) {
          appState.unarchiveChat(
            appState.currentUser.id,
            appState.currentChatId
          );
        }

        this.createNewChat();
      }

      archiveCurrentChat() {
        if (!appState.currentChatId) return;

        const chat =
          appState.chats[appState.currentUser.id][appState.currentChatId];
        if (!chat || chat.messages.length === 0) return;

        if (
          confirm(
            "Archive this chat? You can restore it later from the archived tab."
          )
        ) {
          appState.archiveChat(
            appState.currentUser.id,
            appState.currentChatId
          );
          this.createNewChat();
        }
      }

      displayChatMessages(messages) {
        this.chatMessages.innerHTML = "";
        if (messages.length === 0) {
          this.showWelcomeState();
        } else {
          // Cycle 22: DocumentFragment batch rendering for performance
          const fragment = document.createDocumentFragment();
          let lastDate = null;

          // Cycle 23: Helper for timestamp formatting
          const formatDate = (dateStr) => {
            const date = new Date(dateStr);
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);

            if (date.toDateString() === today.toDateString()) return 'Today';
            if (date.toDateString() === yesterday.toDateString()) return 'Yesterday';
            return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
          };

          messages.forEach((message) => {
            // Cycle 23: Add timestamp dividers between different days
            if (message.timestamp) {
              const msgDate = new Date(message.timestamp).toDateString();
              if (lastDate !== msgDate) {
                const divider = document.createElement('div');
                divider.className = 'timestamp-divider';
                divider.innerHTML = `<span>${formatDate(message.timestamp)}</span>`;
                fragment.appendChild(divider);
                lastDate = msgDate;
              }
            }

            const wrapper = this.createMessageElement(message.role, message.content, message.endpointName);
            if (message.role === "assistant" && message.voiceResponse) {
              const voiceMessage = document.createElement("div");
              voiceMessage.className = "voice-message active";
              const cacheKeyAttr = message.audioCacheKey ? `data-cache-key="${message.audioCacheKey}"` : '';
              voiceMessage.innerHTML = `
                <i class="fas fa-volume-up"></i>
                <span>Voice: "${message.voiceResponse}"</span>
                <button class="replay-btn" ${cacheKeyAttr} data-voice-text="${encodeURIComponent(message.voiceResponse)}" onclick="window.replayVoice(this)">
                  <i class="fas fa-redo"></i> Replay
                </button>
              `;
              wrapper.appendChild(voiceMessage);
            }
            // Add replay button for user voice input messages (plays actual recording)
            if (message.role === "user" && message.voiceInputText) {
              const userVoiceMessage = document.createElement("div");
              userVoiceMessage.className = "user-voice-message active";
              const hasAudioCache = message.voiceAudioCacheKey ? true : false;
              userVoiceMessage.innerHTML = `
                <i class="fas fa-microphone"></i>
                <span>Voice input</span>
                ${hasAudioCache ? `
                  <button class="replay-btn" data-cache-key="${message.voiceAudioCacheKey}" onclick="window.replayUserVoice(this)">
                    <i class="fas fa-redo"></i> Replay
                  </button>
                ` : ''}
              `;
              wrapper.appendChild(userVoiceMessage);
            }
            fragment.appendChild(wrapper);
          });
          this.chatMessages.appendChild(fragment);

          // Lazy highlight all code blocks after single reflow
          this.chatMessages.querySelectorAll("pre code").forEach((block) => {
            if ('IntersectionObserver' in window) {
              const observer = new IntersectionObserver((entries, obs) => {
                entries.forEach(entry => {
                  if (entry.isIntersecting) {
                    hljs.highlightBlock(entry.target);
                    obs.unobserve(entry.target);
                  }
                });
              }, { rootMargin: '100px' });
              observer.observe(block);
            } else {
              hljs.highlightBlock(block);
            }
          });
          this.scrollToBottom();
        }
      }

      clearChatMessages() {
        this.chatMessages.innerHTML = "";
        this.showWelcomeState();
      }

      showWelcomeState() {
        const prompts = [
          {
            icon: "fa-envelope-open-text",
            label: "Email Triage",
            text: "I have 47 unread emails - summarize action items I missed, add them to my task list, and draft apology replies to anyone I left hanging."
          },
          {
            icon: "fa-brain",
            label: "Context Recovery",
            text: "Someone asked about the 'Henderson project' but I have no idea what they're talking about - search my emails, chats, and meetings and brief me."
          },
          {
            icon: "fa-heart",
            label: "Relationship Memory",
            text: "Remind me of personal details about my client Jessica before our call so I can build a real relationship instead of sounding like a robot."
          },
          {
            icon: "fa-layer-group",
            label: "Cross-System Synthesis",
            text: "Find the budget spreadsheet Sarah shared in Teams last month, pull the Q4 numbers, and draft an email comparing them to our projections."
          },
          {
            icon: "fa-balance-scale",
            label: "Work-Life Check",
            text: "Compare my calendar patterns from this quarter vs last and roast me (gently) about my work-life balance, then suggest time blocks to protect."
          },
          {
            icon: "fa-pen-fancy",
            label: "Write In My Voice",
            text: "Write the quarterly update email in my voice, but adjust the tone for each department head based on how they like to receive information."
          },
          {
            icon: "fa-users-cog",
            label: "Multi-Agent Analysis",
            text: "Analyze our top 20 customers by revenue, pull their support tickets and email sentiment, then draft executive briefings for each account manager."
          },
          {
            icon: "fa-calendar-check",
            label: "Meeting Optimizer",
            text: "Track how much time I spend in 'syncs' versus deep work, then auto-decline recurring meetings where I haven't spoken in 3+ sessions."
          },
          {
            icon: "fa-lightbulb",
            label: "Self-Awareness",
            text: "When I say I want to 'move fast,' compare that to how I've actually made decisions historically and tell me what I really mean."
          },
          {
            icon: "fa-magic",
            label: "Creative Voice",
            text: "Create a bedtime story for my daughter about a dragon who learns to code, then read it out loud in a soothing voice."
          }
        ];

        const welcomeHTML = `
          <div class="welcome-state">
            <div class="welcome-logo">
              <i class="fas fa-robot"></i>
            </div>
            <h1 class="welcome-title">What can I help you with?</h1>
            <p class="welcome-subtitle">I'm your AI assistant with persistent memory, multi-agent powers, and deep Microsoft 365 integration.</p>
            <div class="welcome-prompts-title">Try one of these</div>
            <div class="welcome-prompts">
              ${prompts.map((p, i) => `
                <div class="welcome-prompt" data-prompt-index="${i}" style="--prompt-index: ${i};">
                  <div class="welcome-prompt-icon">
                    <i class="fas ${p.icon}"></i>
                  </div>
                  <div class="welcome-prompt-content">
                    <div class="welcome-prompt-label">${p.label}</div>
                    <div class="welcome-prompt-text">${p.text}</div>
                  </div>
                </div>
              `).join('')}
            </div>
          </div>
        `;

        this.chatMessages.innerHTML = welcomeHTML;

        // Add click handlers for prompts
        this.chatMessages.querySelectorAll('.welcome-prompt').forEach((el) => {
          el.addEventListener('click', () => {
            const index = parseInt(el.dataset.promptIndex);
            this.userInput.value = prompts[index].text;
            this.userInput.focus();
            // Auto-resize textarea
            this.userInput.style.height = 'auto';
            this.userInput.style.height = Math.min(this.userInput.scrollHeight, 120) + 'px';
          });
        });
      }

      hideWelcomeState() {
        const welcomeState = this.chatMessages.querySelector('.welcome-state');
        if (welcomeState) {
          welcomeState.remove();
        }
      }

      createMessageElement(role, content, endpointName = null) {
        const messageWrapper = document.createElement("div");
        messageWrapper.className = `message-wrapper ${role}`;

        if (role === "system") {
          const systemMessage = document.createElement("div");
          systemMessage.className = "system-message";

          // Match the backend format: "Performed {agent_name} and got result: {result}"
          const agentMatch = content.match(/Performed (\w+) and got result:/);
          if (agentMatch) {
            const agentName = agentMatch[1];
            const uniqueId =
              "agent-output-" + Math.random().toString(36).substr(2, 9);

            // Create truncated preview for collapsed state
            const resultMatch = content.match(/got result: (.+)/s);
            let preview = "";
            if (resultMatch) {
              // Clean up the result text for preview - remove newlines and limit length
              const cleanResult = resultMatch[1].replace(/\n/g, ' ').substring(0, 60);
              preview = `${cleanResult}${resultMatch[1].length > 60 ? '...' : ''}`;
            }

            const agentWrapper = document.createElement("div");
            agentWrapper.className = "agent-output-wrapper";
            agentWrapper.id = uniqueId;

            agentWrapper.innerHTML = `
              <div class="agent-output-header" onclick="ui.toggleAgentOutput('${uniqueId}')">
                <div class="agent-output-icon">
                  <i class="fas fa-bolt"></i>
                </div>
                <div class="agent-output-info">
                  <div class="agent-output-title">
                    <span>Agent:</span>
                    <span class="agent-name">${agentName}</span>
                  </div>
                  <div class="agent-output-preview">${preview || 'Click to view result'}</div>
                </div>
                <button class="agent-output-toggle" aria-label="Expand agent output">
                  <i class="fas fa-chevron-down"></i>
                </button>
              </div>
              <div class="agent-output-content" id="${uniqueId}-content">
                <div class="agent-output-text">${content}</div>
              </div>
            `;

            messageWrapper.appendChild(agentWrapper);
          } else {
            systemMessage.textContent = content;
            messageWrapper.appendChild(systemMessage);
          }
        } else {
          const label = document.createElement("div");
          label.className = "message-label";
          // Cycle 24: Add avatars to message labels
          const userInitial = appState.currentUser?.username?.charAt(0)?.toUpperCase() || 'U';
          label.innerHTML = role === "user"
            ? `<span class="message-avatar">${userInitial}</span>You`
            : `<span class="message-avatar"><i class="fas fa-robot"></i></span>${appState.currentUser.username}'s Assistant${endpointName ? `<span class="endpoint-badge"><i class="fas fa-server"></i>${endpointName}</span>` : ''}`;

          const messageContent = document.createElement("div");
          messageContent.className = "message-content";

          if (role === "user" && content.startsWith("data:image")) {
            messageContent.innerHTML = `<img src="${content}" alt="Uploaded image" style="max-width: 100%; border-radius: 8px;">`;
          } else {
            messageContent.innerHTML = this.formatMessage(content);
          }

          messageWrapper.appendChild(label);
          messageWrapper.appendChild(messageContent);

          // Cycle 2 Feature: Add message copy button
          const messageActions = document.createElement("div");
          messageActions.className = "message-actions";

          const copyMsgBtn = document.createElement("button");
          copyMsgBtn.className = "message-action-btn";
          copyMsgBtn.innerHTML = '<i class="fas fa-copy"></i>';
          copyMsgBtn.title = "Copy message";
          copyMsgBtn.addEventListener("click", async (e) => {
            e.stopPropagation();
            // Get plain text content
            const textContent = messageContent.innerText || messageContent.textContent;
            try {
              await navigator.clipboard.writeText(textContent);
              copyMsgBtn.classList.add("copied");
              copyMsgBtn.innerHTML = '<i class="fas fa-check"></i>';
              // Cycle 16: Copy toast notification
              // Cycle 27: Enhanced copy celebration
              this.showNotification(" Copied to clipboard!", "success");
              setTimeout(() => {
                copyMsgBtn.classList.remove("copied");
                copyMsgBtn.innerHTML = '<i class="fas fa-copy"></i>';
              }, 2000);
            } catch (err) {
              console.error("Copy failed:", err);
              this.showNotification("Failed to copy", "error");
            }
          });

          messageActions.appendChild(copyMsgBtn);

          // Cycle 23: Add reaction buttons for assistant messages
          if (role === "assistant") {
            const likeBtn = document.createElement("button");
            likeBtn.className = "message-action-btn reaction";
            likeBtn.innerHTML = '';
            likeBtn.title = "Helpful";
            likeBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              likeBtn.classList.toggle("liked");
              dislikeBtn.classList.remove("disliked");
              if (likeBtn.classList.contains("liked")) {
                this.showNotification("Thanks for the feedback!", "success");
                if (navigator.vibrate) navigator.vibrate(30);
              }
            });

            const dislikeBtn = document.createElement("button");
            dislikeBtn.className = "message-action-btn reaction";
            dislikeBtn.innerHTML = '';
            dislikeBtn.title = "Not helpful";
            dislikeBtn.addEventListener("click", (e) => {
              e.stopPropagation();
              dislikeBtn.classList.toggle("disliked");
              likeBtn.classList.remove("liked");
              if (dislikeBtn.classList.contains("disliked")) {
                this.showNotification("Feedback noted", "info");
                if (navigator.vibrate) navigator.vibrate(30);
              }
            });

            messageActions.appendChild(likeBtn);
            messageActions.appendChild(dislikeBtn);
          }

          messageContent.appendChild(messageActions);
        }

        return messageWrapper;
      }

      toggleAgentOutput(id) {
        const wrapper = document.getElementById(id);
        const content = document.getElementById(id + "-content");

        if (content.classList.contains("expanded")) {
          content.classList.remove("expanded");
          wrapper.classList.remove("expanded");
        } else {
          content.classList.add("expanded");
          wrapper.classList.add("expanded");
        }
      }

      addMessageToUI(role, content, animate = true, voiceResponse = null, endpointName = null, audioCacheKey = null, userVoiceInputText = null, userVoiceAudioCacheKey = null) {
        // Hide welcome state when adding messages
        this.hideWelcomeState();

        const messageWrapper = this.createMessageElement(role, content, endpointName);

        if (role === "assistant" && voiceResponse) {
          const voiceMessage = document.createElement("div");
          voiceMessage.className = "voice-message active";
          const cacheKeyAttr = audioCacheKey ? `data-cache-key="${audioCacheKey}"` : '';
          voiceMessage.innerHTML = `
            <i class="fas fa-volume-up"></i>
            <span>Voice: "${voiceResponse}"</span>
            <button class="replay-btn" ${cacheKeyAttr} data-voice-text="${encodeURIComponent(voiceResponse)}" onclick="window.replayVoice(this)">
              <i class="fas fa-redo"></i> Replay
            </button>
          `;
          messageWrapper.appendChild(voiceMessage);
        }

        // Add replay button for user voice input messages (plays actual recording)
        if (role === "user" && userVoiceInputText) {
          const userVoiceMessage = document.createElement("div");
          userVoiceMessage.className = "user-voice-message active";
          const hasAudioCache = userVoiceAudioCacheKey ? true : false;
          userVoiceMessage.innerHTML = `
            <i class="fas fa-microphone"></i>
            <span>Voice input</span>
            ${hasAudioCache ? `
              <button class="replay-btn" data-cache-key="${userVoiceAudioCacheKey}" onclick="window.replayUserVoice(this)">
                <i class="fas fa-redo"></i> Replay
              </button>
            ` : ''}
          `;
          messageWrapper.appendChild(userVoiceMessage);
        }

        // Cycle 20: Add sending state for user messages
        if (role === "user") {
          messageWrapper.classList.add("sending");
        }

        this.chatMessages.appendChild(messageWrapper);

        if (role === "assistant" || role === "system") {
          // Cycle 21: Lazy syntax highlighting with IntersectionObserver
          const codeBlocks = messageWrapper.querySelectorAll("pre code");
          if (codeBlocks.length > 0 && 'IntersectionObserver' in window) {
            const highlightObserver = new IntersectionObserver((entries, observer) => {
              entries.forEach(entry => {
                if (entry.isIntersecting) {
                  hljs.highlightBlock(entry.target);
                  observer.unobserve(entry.target);
                }
              });
            }, { rootMargin: '100px' });
            codeBlocks.forEach(block => highlightObserver.observe(block));
          } else {
            // Fallback for browsers without IntersectionObserver
            codeBlocks.forEach(block => hljs.highlightBlock(block));
          }

          // Add copy buttons to code blocks (Cycle 1 Feature)
          messageWrapper.querySelectorAll("pre").forEach((pre) => {
            const copyBtn = document.createElement("button");
            copyBtn.className = "code-copy-btn";
            copyBtn.innerHTML = '<i class="fas fa-copy"></i>';
            copyBtn.title = "Copy code";
            copyBtn.addEventListener("click", async (e) => {
              e.stopPropagation();
              const code = pre.querySelector("code")?.textContent || pre.textContent;
              try {
                await navigator.clipboard.writeText(code);
                copyBtn.classList.add("copied");
                copyBtn.innerHTML = '<i class="fas fa-check"></i>';
                // Cycle 16: Copy toast notification
                // Cycle 27: Enhanced copy celebration with emoji
                this.showNotification(" Copied to clipboard!", "success");
                setTimeout(() => {
                  copyBtn.classList.remove("copied");
                  copyBtn.innerHTML = '<i class="fas fa-copy"></i>';
                }, 2000);
              } catch (err) {
                console.error("Copy failed:", err);
                this.showNotification("Failed to copy", "error");
              }
            });
            pre.appendChild(copyBtn);

            // Add code language label - Cycle 5 Feature
            const codeEl = pre.querySelector("code");
            if (codeEl && codeEl.className) {
              const langMatch = codeEl.className.match(/language-(\w+)|^(\w+)$/);
              const lang = langMatch ? (langMatch[1] || langMatch[2]) : null;
              if (lang && lang !== 'plaintext' && lang !== 'hljs') {
                const langLabel = document.createElement("span");
                langLabel.className = "code-language-label";
                langLabel.textContent = lang;
                pre.appendChild(langLabel);
              }
            }
          });
        }

        if (animate) {
          this.scrollToBottom();
        }

        return messageWrapper;
      }

      // Cycle 20: Update user message to sent state
      markUserMessageSent() {
        const sendingMessages = this.chatMessages.querySelectorAll('.message-wrapper.user.sending');
        sendingMessages.forEach(msg => {
          msg.classList.remove('sending');
          msg.classList.add('sent');
          setTimeout(() => msg.classList.remove('sent'), 2000);
        });
      }

      formatMessage(text) {
        let formattedText = text;

        // Handle @mentions
        formattedText = formattedText.replace(/@(\w+)/g, (match, name) => {
          return `<span class="mention-tag">@${name}</span>`;
        });

        formattedText = formattedText.replace(
          /```(\w+)?\n([\s\S]+?)```/g,
          (match, lang, code) => {
            const language = lang || "plaintext";
            const escapedCode = this.escapeHtml(code.trim());
            return `<pre><code class="${language}">${escapedCode}</code></pre>`;
          }
        );

        formattedText = formattedText.replace(/`([^`]+)`/g, (match, code) => {
          return `<code>${this.escapeHtml(code)}</code>`;
        });

        formattedText = formattedText.replace(/\*\*([^*]+)\*\*/g, "<strong>$1</strong>");
        formattedText = formattedText.replace(/\*([^*]+)\*/g, "<em>$1</em>");

        formattedText = formattedText.replace(
          /\[([^\]]+)\]\(([^)]+)\)/g,
          (match, linkText, url) => {
            return `<span class="link-wrapper"><a href="${url}" target="_blank" rel="noopener noreferrer"><i class="fas fa-external-link-alt"></i> ${linkText}</a></span>`;
          }
        );

        formattedText = formattedText.replace(
          /!\[([^\]]*)\]\(([^)]+)\)/g,
          (match, altText, url) => {
            const displayText = altText || "Image";
            const imageExtensions = ["jpg", "jpeg", "png", "gif", "svg", "webp", "bmp"];
            const urlLower = url.toLowerCase();
            const isImage = imageExtensions.some(
              (ext) =>
                urlLower.includes(`.${ext}`) ||
                urlLower.includes(`/${ext}?`) ||
                urlLower.includes("generated_images")
            );

            if (isImage) {
              return `
                <div style="margin: 10px 0;">
                  <div style="margin-bottom: 5px;">
                    <a href="${url}" target="_blank" rel="noopener noreferrer" style="color: var(--primary); text-decoration: none;">
                      <i class="fas fa-external-link-alt" style="font-size: 12px;"></i> ${displayText}
                    </a>
                  </div>
                  <img src="${url}"
                       alt="${displayText}"
                       style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: var(--shadow-small); cursor: pointer;"
                       onclick="window.open('${url.replace(/'/g, "\\'")}', '_blank')"
                       onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                  <div style="display: none; padding: 20px; background: var(--gray-20); border-radius: 8px; text-align: center;">
                    <i class="fas fa-exclamation-triangle" style="color: var(--warning); font-size: 24px;"></i>
                    <p style="margin: 10px 0 5px 0; color: var(--gray-80);">Unable to load image</p>
                    <a href="${url}" target="_blank" rel="noopener noreferrer" style="color: var(--primary);">
                      Click here to view image
                    </a>
                  </div>
                </div>
              `;
            } else {
              return `<span class="link-wrapper"><a href="${url}" target="_blank" rel="noopener noreferrer"><i class="fas fa-external-link-alt"></i> ${displayText}</a></span>`;
            }
          }
        );

        formattedText = formattedText.replace(
          /(https?:\/\/[^\s<]+)(?![^<]*>|[^<>]*<\/)/g,
          (match, url) => {
            const imageExtensions = ["jpg", "jpeg", "png", "gif", "svg", "webp", "bmp"];
            const urlLower = url.toLowerCase();
            const isImage = imageExtensions.some(
              (ext) =>
                urlLower.includes(`.${ext}`) ||
                urlLower.includes(`/${ext}?`) ||
                urlLower.includes("generated_images")
            );

            if (isImage) {
              return `
                <div style="margin: 10px 0;">
                  <div style="margin-bottom: 5px;">
                    <a href="${url}" target="_blank" rel="noopener noreferrer" style="color: var(--primary); text-decoration: none; font-size: 13px; word-break: break-all;">
                      <i class="fas fa-external-link-alt" style="font-size: 12px;"></i> ${url}
                    </a>
                  </div>
                  <img src="${url}"
                       alt="Image"
                       style="max-width: 100%; height: auto; border-radius: 8px; box-shadow: var(--shadow-small); cursor: pointer;"
                       onclick="window.open('${url.replace(/'/g, "\\'")}', '_blank')"
                       onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                  <div style="display: none; padding: 20px; background: var(--gray-20); border-radius: 8px; text-align: center;">
                    <i class="fas fa-exclamation-triangle" style="color: var(--warning); font-size: 24px;"></i>
                    <p style="margin: 10px 0 5px 0; color: var(--gray-80);">Unable to load image</p>
                    <a href="${url}" target="_blank" rel="noopener noreferrer" style="color: var(--primary);">
                      Click here to view image
                    </a>
                  </div>
                </div>
              `;
            } else {
              return `<span class="link-wrapper"><a href="${url}" target="_blank" rel="noopener noreferrer"><i class="fas fa-external-link-alt"></i> ${url}</a></span>`;
            }
          }
        );

        formattedText = formattedText.replace(/\n/g, "<br>");

        return formattedText;
      }

      escapeHtml(text) {
        const div = document.createElement("div");
        div.textContent = text;
        return div.innerHTML;
      }

      async sendMessage() {
        const message = this.userInput.value.trim();
        if (!message && !this.pendingImage) return;

        // Check for @mentions in message
        const mentionRegex = /@(\w+)/g;
        let targetEndpoint = null;
        const mentions = [];
        let match;

        while ((match = mentionRegex.exec(message)) !== null) {
          mentions.push(match[1]);
        }

        // Find endpoint by mention
        if (mentions.length > 0) {
          const endpoints = Object.values(appState.endpoints);
          targetEndpoint = endpoints.find(ep =>
            mentions.some(mention => ep.name.toLowerCase() === mention.toLowerCase())
          );
        }

        // Use mentioned endpoint, or current endpoint, or active endpoint
        const endpoint = targetEndpoint ||
          (this.currentEndpointId ? appState.getEndpointById(this.currentEndpointId) : null) ||
          appState.getActiveEndpoint();

        if (!endpoint || !endpoint.url) {
          this.openSettings();
          this.showNotification(
            "Please configure at least one endpoint",
            "warning"
          );
          return;
        }

        this.sendButton.disabled = true;

        const chat =
          appState.chats[appState.currentUser.id][appState.currentChatId];

        // Check if this message was from voice input
        const voiceInputText = window.pendingVoiceInput?.text || null;
        const voiceAudioCacheKey = window.pendingVoiceInput?.audioCacheKey || null;
        if (window.pendingVoiceInput) {
          window.pendingVoiceInput.clear();
        }

        const userMessage = {
          role: "user",
          content: this.pendingImage || message,
          timestamp: new Date().toISOString(),
          voiceInputText: voiceInputText,
          voiceAudioCacheKey: voiceAudioCacheKey,
        };

        chat.messages.push(userMessage);
        this.addMessageToUI("user", userMessage.content, true, null, null, null, voiceInputText, voiceAudioCacheKey);

        this.userInput.value = "";
        this.userInput.style.height = "auto";
        this.clearImagePreview();

        soundManager.playSendSound();

        // Haptic Feedback on Send - Cycle 11 Feature
        if (navigator.vibrate) {
          navigator.vibrate([50, 30, 80]);
        }

        // Send Button Celebration - Cycle 5 Feature
        this.sendButton.classList.add('celebrating');
        setTimeout(() => this.sendButton.classList.remove('celebrating'), 600);

        this.showLoadingIndicator();

        try {
          const response = await fetch(endpoint.url, {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              "x-functions-key": endpoint.key,
            },
            body: JSON.stringify({
              user_input: message || "Please analyze this image",
              conversation_history: chat.messages,
              user_guid: endpoint.guid,
            }),
          });

          if (!response.ok) {
            if (response.status === 401) {
              throw new Error(
                `Invalid function key for ${endpoint.name}. Please check your settings.`
              );
            }
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const data = await response.json();

          // Update endpoint's last used time
          appState.updateEndpoint(endpoint.id, { lastUsed: new Date().toISOString() });

          this.hideLoadingIndicator();
          this.markUserMessageSent(); // Cycle 20: Update send state

          const assistantMessage = {
            role: "assistant",
            content:
              data.assistant_response ||
              data.text ||
              "Sorry, I received an empty response.",
            voiceResponse: data.voice_response || null,
            endpointName: endpoint.name,
            timestamp: new Date().toISOString(),
            audioCacheKey: null,
          };

          // Generate cache key for voice response if available
          if (assistantMessage.voiceResponse && audioCache) {
            const cleanText = voiceManager.cleanTextForSpeech(assistantMessage.voiceResponse);
            assistantMessage.audioCacheKey = audioCache.generateCacheKey(cleanText, voiceManager.voiceName);
          }

          chat.messages.push(assistantMessage);
          this.addMessageToUI(
            "assistant",
            assistantMessage.content,
            true,
            assistantMessage.voiceResponse,
            assistantMessage.endpointName,
            assistantMessage.audioCacheKey
          );

          soundManager.playReceiveSound();

          // Auto-speak response if setting is enabled OR if PTT voice mode is active OR if continuous listening is enabled
          const shouldSpeak = (
            appState.settings.autoSpeak ||
            (typeof pttManager !== "undefined" && pttManager.isActive && pttManager.autoSpeakResponses) ||
            (typeof continuousListening !== "undefined" && continuousListening.isEnabled)
          );

          if (shouldSpeak && assistantMessage.voiceResponse) {
            // Notify continuous listening that we're about to speak
            if (typeof continuousListening !== "undefined" && continuousListening.isEnabled) {
              continuousListening.onSpeakingStart();
            }

            // Use speakAndCache to store audio for later replay
            const cacheKey = await voiceManager.speakAndCache(assistantMessage.voiceResponse);
            if (cacheKey && cacheKey !== assistantMessage.audioCacheKey) {
              assistantMessage.audioCacheKey = cacheKey;
              appState.saveChats(); // Save updated cache key
            }

            // Notify continuous listening that speaking is done, resume listening
            if (typeof continuousListening !== "undefined" && continuousListening.isEnabled) {
              continuousListening.onSpeakingEnd();
            }
          } else if (typeof continuousListening !== "undefined" && continuousListening.isEnabled) {
            // No voice response but continuous listening is enabled - resume listening
            continuousListening.resumeAfterResponse();
          }

          if (data.agent_logs) {
            const systemMessage = {
              role: "system",
              content: data.agent_logs,
              timestamp: new Date().toISOString(),
            };
            chat.messages.push(systemMessage);
            this.addMessageToUI("system", systemMessage.content);
          }

          chat.updatedAt = new Date().toISOString();
          if (chat.messages.length === 2) {
            chat.title = this.generateChatTitle(message || "Image analysis");
          }

          appState.saveChats();
          this.loadUserChats("active");
        } catch (error) {
          console.error("Error:", error);
          this.hideLoadingIndicator();

          // Cycle 3: Store failed message for retry
          this.lastFailedMessage = {
            message: message,
            pendingImage: this.pendingImage
          };

          // Create retry-capable error message
          const errorWrapper = document.createElement('div');
          errorWrapper.className = 'message-wrapper system';
          errorWrapper.innerHTML = `
            <div class="error-retry-state">
              <i class="fas fa-exclamation-triangle"></i>
              <p><strong>Message failed to send</strong></p>
              <p>${error.message}</p>
              <button class="error-retry-btn" id="retry-btn-${Date.now()}">
                <i class="fas fa-redo"></i> Retry
              </button>
            </div>
          `;

          this.chatMessages.appendChild(errorWrapper);
          this.scrollToBottom();

          // Attach retry handler
          errorWrapper.querySelector('.error-retry-btn').addEventListener('click', () => {
            errorWrapper.remove();
            this.retryLastMessage();
          });

          soundManager.playNotificationSound();
        } finally {
          this.sendButton.disabled = false;
          this.userInput.focus();
        }
      }

      showLoadingIndicator() {
        // Processing cursor - Cycle 9 Feature
        document.body.classList.add('processing');

        const existingLoading = document.getElementById("loading-indicator");
        if (existingLoading) {
          existingLoading.remove();
        }

        // Cycle 4: Personality typing phrases
        const thinkingPhrases = [
          "Thinking...",
          "Pondering the possibilities...",
          "Consulting my agents...",
          "Crafting the perfect response...",
          "Processing your request...",
          "Analyzing context...",
          "Summoning wisdom...",
          "Computing with style...",
          "Almost there...",
          "Brewing brilliance..."
        ];

        const loadingDiv = document.createElement("div");
        loadingDiv.className = "loading-personality";
        loadingDiv.id = "loading-indicator";
        loadingDiv.innerHTML = `
          <div class="typing-dots">
            <span></span>
            <span></span>
            <span></span>
          </div>
          <div class="typing-message" id="typing-message">${thinkingPhrases[0]}</div>
        `;
        this.chatMessages.appendChild(loadingDiv);
        this.scrollToBottom();

        // Rotate phrases every 2.5 seconds
        let phraseIndex = 0;
        this.loadingPhraseInterval = setInterval(() => {
          phraseIndex = (phraseIndex + 1) % thinkingPhrases.length;
          const msgEl = document.getElementById('typing-message');
          if (msgEl) {
            msgEl.style.opacity = '0';
            setTimeout(() => {
              msgEl.textContent = thinkingPhrases[phraseIndex];
              msgEl.style.opacity = '1';
            }, 150);
          }
        }, 2500);

        // Start ambient processing sound so user knows assistant is working
        if (typeof soundManager !== 'undefined') {
          soundManager.startAmbientSound();
        }
      }

      hideLoadingIndicator() {
        // Processing cursor - Cycle 9 Feature
        document.body.classList.remove('processing');

        // Stop ambient sound and play completion chime
        if (typeof soundManager !== 'undefined') {
          soundManager.stopAmbientSound();
          soundManager.playCompletionSound();
        }

        // Clear phrase rotation interval
        if (this.loadingPhraseInterval) {
          clearInterval(this.loadingPhraseInterval);
          this.loadingPhraseInterval = null;
        }

        // Cycle 19: Fade-through transition before removal
        const loadingIndicators = document.querySelectorAll(".loading, .loading-personality");
        loadingIndicators.forEach((indicator) => {
          indicator.classList.add('fade-out');
          setTimeout(() => indicator.remove(), 250);
        });
      }

      handleImageUpload(file) {
        if (!file || !file.type.startsWith("image/")) return;

        const reader = new FileReader();
        reader.onload = (e) => {
          this.pendingImage = e.target.result;
          this.showImagePreview(e.target.result);
        };
        reader.readAsDataURL(file);
      }

      showImagePreview(imageSrc) {
        this.imagePreviewContainer.innerHTML = `
          <div class="image-preview">
            <img src="${imageSrc}" alt="Preview">
            <button class="image-preview-remove" onclick="ui.clearImagePreview()">
              <i class="fas fa-times"></i>
            </button>
          </div>
        `;
        this.imagePreviewContainer.classList.add("active");
      }

      clearImagePreview() {
        this.pendingImage = null;
        this.imagePreviewContainer.innerHTML = "";
        this.imagePreviewContainer.classList.remove("active");
      }

      exportCurrentChat() {
        if (!appState.currentChatId) return;

        const chat =
          appState.chats[appState.currentUser.id][appState.currentChatId];

        const conversation = chat.messages.map((msg) => ({
          role: msg.role,
          content: msg.content,
        }));

        const endpoint = appState.getActiveEndpoint();

        const exportData = {
          conversation: conversation,
          guid: endpoint.guid,
          timestamp: new Date().toISOString(),
          appName: "_",
        };

        const filename = `conversation-${new Date()
          .toISOString()
          .replace(/:/g, "_")}.json`;
        this.downloadJson(exportData, filename);
      }

      exportAllData() {
        const exportData = appState.exportAllData();
        const filename = `rappid-full-backup-${new Date().toISOString().replace(/:/g, "-")}.json`;
        this.downloadJson(exportData, filename);
        this.showNotification("Full backup exported!", "success");
      }

      exportSettings() {
        const settingsData = appState.exportSettings();
        const endpointCount = Object.keys(settingsData.endpoints || {}).length;
        const activeEndpoint = Object.values(settingsData.endpoints || {}).find(e => e.active);
        const filename = `rappid-settings-${new Date().toISOString().replace(/:/g, "-")}.json`;
        this.downloadJson(settingsData, filename);
        this.showNotification(
          `RAPPID settings exported! ${endpointCount} endpoints${activeEndpoint ? ` (Active: ${activeEndpoint.name})` : ''}`,
          "success"
        );
      }

      importSettings(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const settingsData = JSON.parse(e.target.result);

            // Validate RAPPID or settings format
            const isRappid = settingsData.rappid === true || settingsData.backupType === "RAPPID Settings Backup";
            const isValidSettings = settingsData.version && (settingsData.endpoints || settingsData.azureTTSKey);

            if (!isRappid && !isValidSettings) {
              throw new Error("Invalid settings file format. Expected RAPPID backup or settings export.");
            }

            // Count endpoints before import
            const existingEndpoints = Object.keys(appState.endpoints).length;
            const importingEndpoints = Object.keys(settingsData.endpoints || {}).length;

            appState.importSettings(settingsData);

            this.applySettings();

            // Apply TTS settings to voice manager
            if (settingsData.azureTTSKey) {
              voiceManager.setAzureKey(settingsData.azureTTSKey);
            }
            if (settingsData.azureRegion) {
              voiceManager.azureRegion = settingsData.azureRegion;
            }
            if (settingsData.ttsVoiceName) {
              voiceManager.setVoiceName(settingsData.ttsVoiceName);
            }

            // Count endpoints after import
            const finalEndpoints = Object.keys(appState.endpoints).length;
            const newEndpoints = finalEndpoints - existingEndpoints;
            const activeEndpoint = appState.getActiveEndpoint();

            // Show detailed notification
            let message = isRappid ? "RAPPID settings imported! " : "Settings imported! ";
            message += `${finalEndpoints} endpoints`;
            if (newEndpoints > 0) message += ` (+${newEndpoints} new)`;
            if (activeEndpoint) message += `. Active: ${activeEndpoint.name}`;

            this.showNotification(message, "success");

            document.getElementById("settings-modal").classList.remove("active");

            this.openSettings();
          } catch (error) {
            this.showNotification(
              "Error importing settings: " + error.message,
              "error"
            );
          }
        };
        reader.readAsText(file);
      }

      downloadJson(data, filename) {
        const blob = new Blob([JSON.stringify(data, null, 2)], {
          type: "application/json",
        });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      importChat(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);

            if (data.conversation && Array.isArray(data.conversation)) {
              const newChat = appState.createChat(appState.currentUser.id,
                "Imported Chat"
              );

              newChat.messages = data.conversation.map((msg) => ({
                role: msg.role,
                content: msg.content,
                timestamp: new Date().toISOString(),
              }));

              newChat.updatedAt = data.timestamp || new Date().toISOString();

              if (newChat.messages.length > 0) {
                const firstUserMessage = newChat.messages.find(
                  (m) => m.role === "user"
                );
                if (firstUserMessage) {
                  newChat.title = this.generateChatTitle(
                    firstUserMessage.content
                  );
                }
              }

              appState.saveChats();
              this.loadChat(newChat.id);
              this.loadUserChats("active");
              this.showNotification("Chat imported successfully!", "success");
            } else if (data.chat && data.chat.messages) {
              const newChat = appState.createChat(
                appState.currentUser.id,
                data.chat.title || "Imported Chat"
              );
              newChat.messages = data.chat.messages;
              newChat.updatedAt = new Date().toISOString();

              appState.saveChats();
              this.loadChat(newChat.id);
              this.loadUserChats("active");
              this.showNotification("Chat imported successfully!", "success");
            } else {
              throw new Error("Invalid chat format");
            }
          } catch (error) {
            this.showNotification(
              "Error importing chat: " + error.message,
              "error"
            );
          }
        };
        reader.readAsText(file);
      }

      importAllData(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);

            // Check for RAPPID format or standard backup format
            const isRappid = data.rappid === true || data.backupType === "RAPPID Settings Backup";
            const isValidBackup = data.version && (data.users || data.chats || data.endpoints);

            if (!isRappid && !isValidBackup) {
              throw new Error("Invalid backup format. Expected RAPPID or app backup.");
            }

            // Build summary of what will be imported
            const summary = [];
            if (data.users) summary.push(`${Object.keys(data.users).length} users`);
            if (data.chats) {
              const chatCount = Object.values(data.chats).reduce((sum, uc) =>
                sum + Object.keys(uc || {}).length, 0);
              summary.push(`${chatCount} chats`);
            }
            if (data.endpoints) summary.push(`${Object.keys(data.endpoints).length} endpoints`);
            if (data.settings) summary.push("settings");
            if (data.azureTTSKey) summary.push("TTS config");

            const confirmMsg = isRappid
              ? `Import RAPPID backup? This will merge: ${summary.join(", ")}`
              : `Import backup? This will merge: ${summary.join(", ")}`;

            if (confirm(confirmMsg)) {
              // Store current user info
              const currentUserId = appState.currentUser?.id;

              appState.importAllData(data);

              // Apply TTS settings if present
              if (data.azureTTSKey) {
                voiceManager.setAzureKey(data.azureTTSKey);
              }
              if (data.azureRegion) {
                voiceManager.azureRegion = data.azureRegion;
              }
              if (data.ttsVoiceName) {
                voiceManager.setVoiceName(data.ttsVoiceName);
              }

              // Count what was imported
              const endpointCount = Object.keys(appState.endpoints).length;
              const userCount = Object.keys(appState.users).length;
              const activeEndpoint = appState.getActiveEndpoint();

              let successMsg = isRappid ? "RAPPID backup merged! " : "Backup merged! ";
              successMsg += `${endpointCount} endpoints, ${userCount} users`;
              if (activeEndpoint) successMsg += `. Active: ${activeEndpoint.name}`;

              this.showNotification(successMsg, "success");

              // Only logout if user data was imported
              if (data.users) {
                this.logout();
              } else {
                // Just refresh settings
                this.applySettings();
              }
            }
          } catch (error) {
            this.showNotification(
              "Error importing data: " + error.message,
              "error"
            );
          }
        };
        reader.readAsText(file);
      }

      handleJsonImport(file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const data = JSON.parse(e.target.result);

            // Check for RAPPID format first
            const isRappid = data.rappid === true || data.backupType === "RAPPID Settings Backup";

            if (data.conversation || (data.chat && data.user)) {
              // Chat export format
              this.importChat(file);
            } else if (isRappid && !data.users && !data.chats) {
              // RAPPID settings-only backup (no users/chats)
              this.importSettings(file);
            } else if (data.users || data.chats || (isRappid && (data.users || data.chats))) {
              // Full backup format (RAPPID or standard)
              this.importAllData(file);
            } else if (data.endpoints) {
              // Settings/endpoints only
              this.importSettings(file);
            } else {
              this.showNotification("Unknown file format", "error");
            }
          } catch (error) {
            this.showNotification(
              "Error reading file: " + error.message,
              "error"
            );
          }
        };
        reader.readAsText(file);
      }

      generateChatTitle(firstMessage) {
        const cleanMessage = firstMessage
          .replace(/[^\w\s]/g, "")
          .toLowerCase();
        const words = cleanMessage.split(" ").filter((w) => w.length > 3);

        if (words.length > 3) {
          return words.slice(0, 3).join(" ");
        } else if (firstMessage.length > 30) {
          return firstMessage.substring(0, 30) + "...";
        } else {
          return firstMessage;
        }
      }

      toggleTheme() {
        const isDark = document.body.classList.toggle("dark");
        appState.settings.theme = isDark ? "dark" : "light";
        appState.saveSettings();

        const themeIcon = document.querySelector("#theme-toggle i");
        themeIcon.className = isDark ? "fas fa-sun" : "fas fa-moon";

        const darkModeToggle = document.getElementById("dark-mode-toggle");
        if (darkModeToggle) {
          darkModeToggle.classList.toggle("active", isDark);
        }
      }

      applyTheme() {
        if (appState.settings.theme === "dark") {
          document.body.classList.add("dark");
          document.querySelector("#theme-toggle i").className = "fas fa-sun";
        }
      }

      saveAllSettings() {
        const isDarkMode = document
          .getElementById("dark-mode-toggle")
          .classList.contains("active");
        appState.settings.theme = isDarkMode ? "dark" : "light";

        if (isDarkMode && !document.body.classList.contains("dark")) {
          document.body.classList.add("dark");
          document.querySelector("#theme-toggle i").className = "fas fa-sun";
        } else if (!isDarkMode && document.body.classList.contains("dark")) {
          document.body.classList.remove("dark");
          document.querySelector("#theme-toggle i").className = "fas fa-moon";
        }

        appState.settings.soundEnabled = document
          .getElementById("sound-toggle")
          .classList.contains("active");
        soundManager.setEnabled(appState.settings.soundEnabled);

        appState.settings.voiceEnabled = document
          .getElementById("voice-enabled-toggle")
          .classList.contains("active");
        appState.settings.autoSpeak = document
          .getElementById("auto-speak-toggle")
          .classList.contains("active");

        voiceManager.setEnabled(appState.settings.voiceEnabled);
        voiceManager.setAutoSpeak(appState.settings.autoSpeak);

        const azureTTSKey = document
          .getElementById("azure-tts-key")
          .value.trim();
        appState.settings.azureTTSKey = azureTTSKey;
        voiceManager.setAzureKey(azureTTSKey);

        const ttsVoice = document.getElementById("tts-voice-select").value;
        appState.settings.ttsVoiceName = ttsVoice;
        voiceManager.setVoiceName(ttsVoice);

        appState.saveSettings();

        this.showNotification("Settings saved successfully!", "success");
        document.getElementById("settings-modal").classList.remove("active");
      }

      applySettings() {
        this.applyTheme();

        soundManager.setEnabled(appState.settings.soundEnabled);

        voiceManager.setEnabled(appState.settings.voiceEnabled);
        voiceManager.setAutoSpeak(appState.settings.autoSpeak);
        voiceManager.setAzureKey(appState.settings.azureTTSKey);
        voiceManager.setVoiceName(appState.settings.ttsVoiceName);

        // Cycle 28: Update aria-checked along with active class
        const darkModeToggle = document.getElementById("dark-mode-toggle");
        if (darkModeToggle) {
          const isDark = appState.settings.theme === "dark";
          darkModeToggle.classList.toggle("active", isDark);
          darkModeToggle.setAttribute("aria-checked", isDark.toString());
        }

        const soundToggle = document.getElementById("sound-toggle");
        if (soundToggle) {
          const isSound = appState.settings.soundEnabled;
          soundToggle.classList.toggle("active", isSound);
          soundToggle.setAttribute("aria-checked", isSound.toString());
        }

        const voiceEnabledToggle = document.getElementById(
          "voice-enabled-toggle"
        );
        if (voiceEnabledToggle) {
          const isVoice = appState.settings.voiceEnabled;
          voiceEnabledToggle.classList.toggle("active", isVoice);
          voiceEnabledToggle.setAttribute("aria-checked", isVoice.toString());
        }

        const autoSpeakToggle = document.getElementById("auto-speak-toggle");
        if (autoSpeakToggle) {
          const isAuto = appState.settings.autoSpeak;
          autoSpeakToggle.classList.toggle("active", isAuto);
          autoSpeakToggle.setAttribute("aria-checked", isAuto.toString());
        }

        const azureTTSKeyInput = document.getElementById("azure-tts-key");
        if (azureTTSKeyInput && appState.settings.azureTTSKey) {
          azureTTSKeyInput.value = appState.settings.azureTTSKey;
        }

        const ttsVoiceSelect = document.getElementById("tts-voice-select");
        if (ttsVoiceSelect) {
          ttsVoiceSelect.value = appState.settings.ttsVoiceName;
        }

        this.loadEndpointList();
      }

      openSettings() {
        this.applySettings();
        document.getElementById("settings-modal").classList.add("active");

        // Modal Auto-Focus - Cycle 6 Feature
        setTimeout(() => document.getElementById('export-settings')?.focus(), 50);
      }

      openTimeMachine() {
        const chat =
          appState.chats[appState.currentUser.id][appState.currentChatId];
        if (!chat || chat.messages.length === 0) {
          this.showNotification(
            "No messages to replay in the current chat.",
            "info"
          );
          return;
        }

        document.getElementById("time-machine-modal").classList.add("active");
        document
          .getElementById("time-machine-controls")
          .classList.add("hidden");

        // Modal Auto-Focus - Cycle 6 Feature
        setTimeout(() => document.getElementById('time-machine-close')?.focus(), 50);
      }

      closeMenu() {
        document.getElementById("menu-toggle").classList.remove("active");
        document.getElementById("menu-items").classList.remove("open");
      }

      scrollToBottom() {
        // Smooth scroll - Cycle 7 Feature
        this.chatMessages.scrollTo({
          top: this.chatMessages.scrollHeight,
          behavior: "smooth"
        });
      }

      // Cycle 3: Retry last failed message
      retryLastMessage() {
        if (!this.lastFailedMessage) return;

        const { message, pendingImage } = this.lastFailedMessage;
        this.lastFailedMessage = null;

        // Restore the message to input
        if (message) {
          this.userInput.value = message;
        }
        if (pendingImage) {
          this.pendingImage = pendingImage;
          this.showImagePreview(pendingImage);
        }

        // Trigger send
        this.sendMessage();
      }

      truncateText(text, maxLength) {
        if (text.length <= maxLength) return text;
        return text.substring(0, maxLength) + "...";
      }

      formatDate(dateString) {
        const date = new Date(dateString);
        const now = new Date();
        const diff = now - date;

        if (diff < 60000) return "Just now";
        if (diff < 3600000) return `${Math.floor(diff / 60000)}m ago`;
        if (diff < 86400000) return `${Math.floor(diff / 3600000)}h ago`;
        if (diff < 604800000) return `${Math.floor(diff / 86400000)}d ago`;

        return date.toLocaleDateString();
      }

      showNotification(message, type = "info") {
        const notification = document.createElement("div");
        notification.className = `notification notification-${type}`;
        notification.style.cssText = `
          position: fixed;
          top: 20px;
          right: 20px;
          background: ${type === "success"
            ? "var(--success)"
            : type === "error"
              ? "var(--error)"
              : type === "warning"
                ? "var(--warning)"
                : "var(--info)"
          };
          color: white;
          padding: 16px 24px;
          border-radius: var(--radius);
          box-shadow: var(--shadow-large);
          z-index: 2000;
          animation: slideUp 0.3s ease-out;
          max-width: 320px;
        `;
        notification.textContent = message;

        document.body.appendChild(notification);

        setTimeout(() => {
          notification.style.animation = "fadeOut 0.3s ease-out";
          setTimeout(() => {
            document.body.removeChild(notification);
          }, 300);
        }, 3000);
      }
    }

    // ========================================
    // PROMPT LIBRARY - Power Prompts System
    // ========================================
    class PromptLibrary {
      constructor() {
        this.modal = document.getElementById('prompt-library-modal');
        this.content = document.getElementById('prompt-library-content');
        this.currentFilter = 'all';

        this.prompts = [
          {
            id: 'broken-promise',
            title: 'The Broken Promise Detector',
            icon: 'fa-handshake-slash',
            category: 'email',
            gradient: { start: '#ef4444', end: '#dc2626' },
            tags: ['Email Analysis', 'Pattern Matching', 'Relationship Intelligence'],
            prompt: "Scan my Outlook for every 'I'll get back to you' and 'Let me follow up' I sent in the last 90 days, cross-reference with my Sent folder to find the ones I never followed through on, rank them by how important the recipient is, and draft personalized 'sorry I dropped the ball' messages for each.",
            uiTemplate: 'email-list'
          },
          {
            id: 'political-mapper',
            title: 'The Political Reality Mapper',
            icon: 'fa-sitemap',
            category: 'relationships',
            gradient: { start: '#8b5cf6', end: '#7c3aed' },
            tags: ['Social Graph', 'Organizational Intelligence', 'Power Dynamics'],
            prompt: "Analyze my email CC patterns, meeting invite hierarchies, and who responds to whom first to map the ACTUAL political power structure in my organization - not the org chart, the real one. Show me who really has influence and where I stand.",
            uiTemplate: 'relationship-graph'
          },
          {
            id: 'contradiction-finder',
            title: 'The Contradiction Finder',
            icon: 'fa-exclamation-triangle',
            category: 'analytics',
            gradient: { start: '#f59e0b', end: '#d97706' },
            tags: ['Cross-Document Analysis', 'Risk Detection', 'Semantic Comparison'],
            prompt: "Search my SharePoint documents and emails for times I told different stakeholders different things about the same project - conflicting timelines, budgets, or priorities. I need to find these landmines before someone else does.",
            uiTemplate: 'comparison'
          },
          {
            id: 'relationship-decay',
            title: 'The Relationship Decay Alert',
            icon: 'fa-heart-crack',
            category: 'relationships',
            gradient: { start: '#ec4899', end: '#db2777' },
            tags: ['Sentiment Analysis', 'Longitudinal Tracking', 'Relationship Health'],
            prompt: "Create a relationship health dashboard for my top 20 contacts - based on email sentiment trends, response time changes, and meeting frequency drops. Rate each as thriving, cooling, or at-risk, and tell me specifically what happened with the ones that are dying.",
            uiTemplate: 'relationship-graph'
          },
          {
            id: 'crisis-predictor',
            title: 'The Future Crisis Predictor',
            icon: 'fa-crystal-ball',
            category: 'analytics',
            gradient: { start: '#06b6d4', end: '#0891b2' },
            tags: ['Predictive Analytics', 'Pattern Recognition', 'Risk Assessment'],
            prompt: "Based on my current project trajectories, team response patterns, upcoming deadlines, and historical 'how things went wrong before' data - predict which initiative will blow up in the next 30 days and tell me exactly what I'd need to do TODAY to prevent it.",
            uiTemplate: 'dashboard'
          },
          {
            id: 'meeting-autopsy',
            title: 'The Meeting Autopsy Report',
            icon: 'fa-skull',
            category: 'calendar',
            gradient: { start: '#64748b', end: '#475569' },
            tags: ['Calendar Analysis', 'Productivity Intelligence', 'Time Audit'],
            prompt: "Analyze every meeting I attended last quarter. Which ones actually produced decisions? Which were pure performance theater? Which should have been emails? Give me the brutal truth with specific examples - I want to see how much of my life I'm wasting.",
            uiTemplate: 'timeline'
          },
          {
            id: 'ghost-machine',
            title: 'The Ghost In The Machine',
            icon: 'fa-ghost',
            category: 'self',
            gradient: { start: '#a855f7', end: '#9333ea' },
            tags: ['Writing Analysis', 'Personal Coaching', 'Communication Style'],
            prompt: "You've read every email I've ever written. Show me my verbal tics, weak phrases, and unconscious patterns. Then take my 5 worst recent emails and rewrite them as the communicator I wish I was - same message, but actually effective.",
            uiTemplate: 'comparison'
          },
          {
            id: 'calendar-reality',
            title: 'The Calendar vs. Reality Audit',
            icon: 'fa-masks-theater',
            category: 'self',
            gradient: { start: '#14b8a6', end: '#0d9488' },
            tags: ['Intent vs Action', 'Self-Awareness', 'Behavioral Patterns'],
            prompt: "Compare what I SAID my priorities were in planning emails versus where my calendar time actually went. Show me the gap between who I claim to be and who my schedule says I am. I need to see how I'm lying to myself.",
            uiTemplate: 'comparison'
          },
          {
            id: 'burnout-warning',
            title: 'The Burnout Early Warning System',
            icon: 'fa-fire-flame-curved',
            category: 'analytics',
            gradient: { start: '#f97316', end: '#ea580c' },
            tags: ['Team Wellness', 'Predictive HR', 'Proactive Management'],
            prompt: "Monitor my team's digital body language across Teams and Outlook - late night messages, response time changes, sentiment shifts, calendar overload. Build me a dashboard that predicts who's heading toward burnout before they even know it themselves.",
            uiTemplate: 'dashboard'
          },
          {
            id: 'career-narrative',
            title: 'The Career Narrative Generator',
            icon: 'fa-trophy',
            category: 'self',
            gradient: { start: '#eab308', end: '#ca8a04' },
            tags: ['Narrative Synthesis', 'Achievement Extraction', 'Self-Advocacy'],
            prompt: "Turn my entire year of work into a compelling story for my performance review - every project, win, challenge, and growth moment synthesized from my emails, documents, and calendar. Make me sound like the hero I actually was, with real evidence to back every claim.",
            uiTemplate: 'narrative'
          }
        ];

        this.init();
      }

      init() {
        // Open button (FAB in float-buttons)
        document.getElementById('prompt-library-btn-fab').addEventListener('click', () => {
          this.open();
        });

        // Close button
        document.getElementById('prompt-library-close').addEventListener('click', () => {
          this.close();
        });

        // Close on backdrop click
        this.modal.addEventListener('click', (e) => {
          if (e.target === this.modal) {
            this.close();
          }
        });

        // Filter buttons
        document.querySelectorAll('.prompt-filter-btn').forEach(btn => {
          btn.addEventListener('click', (e) => {
            this.setFilter(e.target.dataset.filter);
          });
        });

        // Render initial prompts
        this.render();
      }

      open() {
        this.modal.classList.add('active');
        document.body.style.overflow = 'hidden';
      }

      close() {
        this.modal.classList.remove('active');
        document.body.style.overflow = '';
      }

      setFilter(filter) {
        this.currentFilter = filter;

        // Update active button
        // Cycle 27: aria-current for accessibility
        document.querySelectorAll('.prompt-filter-btn').forEach(btn => {
          const isActive = btn.dataset.filter === filter;
          btn.classList.toggle('active', isActive);
          btn.setAttribute('aria-current', isActive ? 'true' : 'false');
        });

        this.render();
      }

      getFilteredPrompts() {
        if (this.currentFilter === 'all') {
          return this.prompts;
        }
        return this.prompts.filter(p => p.category === this.currentFilter);
      }

      render() {
        const prompts = this.getFilteredPrompts();

        this.content.innerHTML = prompts.map(p => `
          <div class="prompt-card" data-prompt-id="${p.id}" style="--card-gradient-start: ${p.gradient.start}; --card-gradient-end: ${p.gradient.end};">
            <div class="prompt-card-header">
              <div class="prompt-card-icon">
                <i class="fas ${p.icon}"></i>
              </div>
              <div>
                <div class="prompt-card-title">${p.title}</div>
                <div class="prompt-card-category">${this.getCategoryLabel(p.category)}</div>
              </div>
            </div>
            <div class="prompt-card-text">${p.prompt}</div>
            <div class="prompt-card-tags">
              ${p.tags.map(tag => `<span class="prompt-tag">${tag}</span>`).join('')}
            </div>
            <div class="prompt-card-action">
              <i class="fas fa-arrow-right"></i>
            </div>
          </div>
        `).join('');

        // Add click handlers
        this.content.querySelectorAll('.prompt-card').forEach(card => {
          card.addEventListener('click', () => {
            const promptId = card.dataset.promptId;
            this.selectPrompt(promptId);
          });
        });
      }

      getCategoryLabel(category) {
        const labels = {
          email: 'Email Intelligence',
          relationships: 'Relationship Analysis',
          calendar: 'Calendar & Time',
          analytics: 'Predictive Analytics',
          self: 'Self-Awareness'
        };
        return labels[category] || category;
      }

      selectPrompt(promptId) {
        const prompt = this.prompts.find(p => p.id === promptId);
        if (!prompt) return;

        // Close the modal
        this.close();

        // Set the prompt in the input field
        const userInput = document.getElementById('user-input');
        userInput.value = prompt.prompt;
        userInput.focus();

        // Auto-resize textarea
        userInput.style.height = 'auto';
        userInput.style.height = Math.min(userInput.scrollHeight, 120) + 'px';

        // Store the selected prompt for generative UI
        window.selectedPromptTemplate = prompt.uiTemplate;
        window.selectedPromptData = prompt;

        // Show notification
        ui.showNotification(`Loaded: ${prompt.title}`, 'success');
      }
    }

    // ========================================
    // GENERATIVE UI - Dynamic Response Templates
    // ========================================
    class GenerativeUI {
      constructor() {
        this.templates = {
          'email-list': this.renderEmailList,
          'relationship-graph': this.renderRelationshipGraph,
          'dashboard': this.renderDashboard,
          'timeline': this.renderTimeline,
          'narrative': this.renderNarrative,
          'comparison': this.renderComparison
        };
      }

      // Generate sample data based on template type
      generateSampleData(template) {
        switch(template) {
          case 'email-list':
            return {
              title: 'Unfollowed Promises Detected',
              items: [
                { initials: 'JD', name: 'John Davis', subject: 'Re: Q4 Budget Review', preview: "You said 'I'll send the updated figures by EOD'", priority: 'high', daysAgo: 12 },
                { initials: 'SM', name: 'Sarah Miller', subject: 'Project Timeline', preview: "You promised to 'circle back with the team'", priority: 'high', daysAgo: 8 },
                { initials: 'RK', name: 'Robert Kim', subject: 'Partnership Discussion', preview: "You mentioned 'Let me follow up next week'", priority: 'medium', daysAgo: 23 },
                { initials: 'AL', name: 'Amy Liu', subject: 'Design Feedback', preview: "You said 'I'll review and get back to you'", priority: 'medium', daysAgo: 15 },
                { initials: 'TC', name: 'Tom Chen', subject: 'Vendor Contracts', preview: "You promised to 'send over the comparison'", priority: 'low', daysAgo: 31 }
              ]
            };

          case 'relationship-graph':
            return {
              title: 'Relationship Health Dashboard',
              contacts: [
                { initials: 'EM', name: 'Emily Martinez', role: 'VP of Sales', status: 'thriving', trend: '+15% engagement' },
                { initials: 'JW', name: 'James Wilson', role: 'Product Lead', status: 'thriving', trend: 'Strong collaboration' },
                { initials: 'LT', name: 'Lisa Thompson', role: 'CFO', status: 'cooling', trend: '-30% response rate' },
                { initials: 'MR', name: 'Michael Ross', role: 'Engineering Dir', status: 'cooling', trend: 'Fewer meetings' },
                { initials: 'NK', name: 'Nina Kumar', role: 'HR Director', status: 'at-risk', trend: 'No contact 45 days' },
                { initials: 'DL', name: 'David Lee', role: 'Marketing VP', status: 'at-risk', trend: 'Declined 3 invites' }
              ]
            };

          case 'dashboard':
            return {
              cards: [
                { label: 'At-Risk Projects', value: '3', trend: 'up', trendText: '+2 from last month', color: '#ef4444' },
                { label: 'Predicted Issues', value: '7', trend: 'up', trendText: 'Next 30 days', color: '#f59e0b' },
                { label: 'Team Burnout Risk', value: '23%', trend: 'down', trendText: '-5% from last week', color: '#10b981' },
                { label: 'Meetings Needing Action', value: '12', trend: 'up', trendText: 'No follow-up yet', color: '#8b5cf6' }
              ]
            };

          case 'timeline':
            return {
              title: 'Meeting Analysis Timeline',
              items: [
                { icon: 'fa-check-circle', title: 'Q4 Planning Session', desc: 'Produced 5 actionable decisions', time: '2 weeks ago', status: 'productive' },
                { icon: 'fa-theater-masks', title: 'Weekly Status Sync', desc: 'No decisions - could be async update', time: '1 week ago', status: 'theater' },
                { icon: 'fa-envelope', title: 'Budget Review Call', desc: 'All info was already in the email thread', time: '5 days ago', status: 'email' },
                { icon: 'fa-check-circle', title: 'Product Roadmap Review', desc: 'Key prioritization decisions made', time: '3 days ago', status: 'productive' },
                { icon: 'fa-theater-masks', title: 'Cross-Team Alignment', desc: 'Repeated previous meeting content', time: 'Yesterday', status: 'theater' }
              ]
            };

          case 'narrative':
            return {
              text: "This year, you emerged as the quiet force behind three major initiatives that shaped the company's direction. When the Anderson account threatened to collapse in March, you orchestrated a recovery that not only saved the relationship but expanded it by 40%. Your documentation overhaul, initially met with skepticism, became the template adopted company-wide. Perhaps most notably, you mentored two junior team members who are now leading their own projectsa legacy that speaks louder than any metric.",
              author: { initials: 'AI', name: 'Your AI Advocate', role: 'Based on 847 emails, 156 documents, and 312 meetings' }
            };

          case 'comparison':
            return {
              leftTitle: 'What You Said',
              rightTitle: 'What You Did',
              leftItems: [
                '"Strategic planning is my top priority"',
                '"I need more focus time for deep work"',
                '"Team development is crucial this quarter"',
                '"I\'ll reduce meeting load by 20%"'
              ],
              rightItems: [
                '4 hours/week on strategy (8% of time)',
                '2.3 hours average focus blocks',
                '1 skip-level per month (down from 4)',
                'Meeting time increased 12%'
              ]
            };

          default:
            return null;
        }
      }

      render(template, customData = null) {
        const data = customData || this.generateSampleData(template);
        const renderFn = this.templates[template];

        if (!renderFn || !data) {
          return '';
        }

        return `<div class="gen-ui-container">${renderFn.call(this, data)}</div>`;
      }

      renderEmailList(data) {
        return `
          <div class="gen-ui-email-list">
            <div class="gen-ui-email-header">
              <i class="fas fa-envelope-open-text"></i>
              ${data.title}
            </div>
            ${data.items.map(item => `
              <div class="gen-ui-email-item">
                <div class="gen-ui-email-avatar">${item.initials}</div>
                <div class="gen-ui-email-content">
                  <div class="gen-ui-email-subject">${item.name} - ${item.subject}</div>
                  <div class="gen-ui-email-preview">${item.preview} (${item.daysAgo} days ago)</div>
                </div>
                <span class="gen-ui-email-priority ${item.priority}">${item.priority}</span>
              </div>
            `).join('')}
          </div>
        `;
      }

      renderRelationshipGraph(data) {
        return `
          <div class="gen-ui-relationship-graph">
            <div class="gen-ui-graph-header">
              <i class="fas fa-project-diagram"></i>
              ${data.title}
            </div>
            <div class="gen-ui-relationship-grid">
              ${data.contacts.map(contact => `
                <div class="gen-ui-relationship-node ${contact.status}">
                  <div class="gen-ui-node-avatar">${contact.initials}</div>
                  <div class="gen-ui-node-name">${contact.name}</div>
                  <div class="gen-ui-node-role">${contact.role}</div>
                  <span class="gen-ui-node-status ${contact.status}">${contact.status}</span>
                  <div style="font-size: 11px; color: var(--gray-60); margin-top: 8px;">${contact.trend}</div>
                </div>
              `).join('')}
            </div>
          </div>
        `;
      }

      renderDashboard(data) {
        return `
          <div class="gen-ui-dashboard">
            ${data.cards.map(card => `
              <div class="gen-ui-dashboard-card" style="border-left-color: ${card.color}">
                <div class="gen-ui-dashboard-label">${card.label}</div>
                <div class="gen-ui-dashboard-value">${card.value}</div>
                <div class="gen-ui-dashboard-trend ${card.trend}">
                  <i class="fas fa-arrow-${card.trend}"></i>
                  ${card.trendText}
                </div>
              </div>
            `).join('')}
          </div>
        `;
      }

      renderTimeline(data) {
        return `
          <div class="gen-ui-timeline">
            <div class="gen-ui-timeline-header">
              <i class="fas fa-clock"></i>
              ${data.title}
            </div>
            ${data.items.map(item => `
              <div class="gen-ui-timeline-item">
                <div class="gen-ui-timeline-dot" style="background: ${item.status === 'productive' ? '#10b981' : item.status === 'theater' ? '#f59e0b' : '#64748b'}">
                  <i class="fas ${item.icon}"></i>
                </div>
                <div class="gen-ui-timeline-content">
                  <div class="gen-ui-timeline-title">${item.title}</div>
                  <div class="gen-ui-timeline-desc">${item.desc}</div>
                  <div class="gen-ui-timeline-time">${item.time}</div>
                </div>
              </div>
            `).join('')}
          </div>
        `;
      }

      renderNarrative(data) {
        return `
          <div class="gen-ui-narrative">
            <div class="gen-ui-narrative-text">${data.text}</div>
            <div class="gen-ui-narrative-author">
              <div class="gen-ui-narrative-avatar"><i class="fas fa-robot"></i></div>
              <div>
                <div class="gen-ui-narrative-name">${data.author.name}</div>
                <div class="gen-ui-narrative-role">${data.author.role}</div>
              </div>
            </div>
          </div>
        `;
      }

      renderComparison(data) {
        return `
          <div class="gen-ui-comparison">
            <div class="gen-ui-comparison-side left">
              <div class="gen-ui-comparison-title">
                <i class="fas fa-comment" style="color: #ef4444"></i>
                ${data.leftTitle}
              </div>
              ${data.leftItems.map(item => `<div class="gen-ui-comparison-item">${item}</div>`).join('')}
            </div>
            <div class="gen-ui-comparison-vs">VS</div>
            <div class="gen-ui-comparison-side right">
              <div class="gen-ui-comparison-title">
                <i class="fas fa-chart-line" style="color: #10b981"></i>
                ${data.rightTitle}
              </div>
              ${data.rightItems.map(item => `<div class="gen-ui-comparison-item">${item}</div>`).join('')}
            </div>
          </div>
        `;
      }
    }

    // Initialize Prompt Library and Generative UI
    const promptLibrary = new PromptLibrary();
    const generativeUI = new GenerativeUI();

    // Make globally accessible
    window.promptLibrary = promptLibrary;
    window.generativeUI = generativeUI;

    // Initialize UI Controller
    const ui = new UIController();

    // Make UI instance globally accessible for inline event handlers
    window.ui = ui;

    // Initialize sound manager with saved settings
    soundManager.setEnabled(appState.settings.soundEnabled);

    // Initialize voice manager with saved settings
    voiceManager.setEnabled(appState.settings.voiceEnabled);
    voiceManager.setAutoSpeak(appState.settings.autoSpeak);
    voiceManager.setAzureKey(appState.settings.azureTTSKey);
    voiceManager.setVoiceName(appState.settings.ttsVoiceName);

    // Enhanced keyboard shortcuts (Cycle 1 Feature)
    document.addEventListener("keydown", (e) => {
      const isInputFocused = document.activeElement.tagName === "INPUT" ||
                             document.activeElement.tagName === "TEXTAREA";

      // Escape - close everything
      if (e.key === "Escape") {
        // Cycle 21: Animated modal close
        const modals = document.querySelectorAll(".modal.active");
        modals.forEach((modal) => {
          modal.classList.add("closing");
          modal.classList.remove("active");
          setTimeout(() => modal.classList.remove("closing"), 200);
        });

        const promptLibraryModal = document.getElementById("prompt-library-modal");
        if (promptLibraryModal.classList.contains("active")) {
          promptLibrary.close();
        }

        // Close shortcuts modal (Cycle 2) - with animation
        const shortcutsModal = document.getElementById("shortcuts-modal");
        if (shortcutsModal.classList.contains("active")) {
          shortcutsModal.classList.add("closing");
          shortcutsModal.classList.remove("active");
          setTimeout(() => shortcutsModal.classList.remove("closing"), 200);
        }

        if (document.getElementById("menu-items").classList.contains("open")) {
          ui.closeMenu();
        }

        if (document.getElementById("sidebar").classList.contains("open")) {
          ui.toggleSidebar();
        }

        // Blur input if focused
        if (isInputFocused) {
          document.activeElement.blur();
        }
      }

      // Cmd/Ctrl + K - Focus input
      if ((e.metaKey || e.ctrlKey) && e.key === "k") {
        e.preventDefault();
        document.getElementById("user-input").focus();
      }

      // Cmd/Ctrl + N - New chat
      if ((e.metaKey || e.ctrlKey) && e.key === "n") {
        e.preventDefault();
        ui.createNewChat();
      }

      // Cmd/Ctrl + , - Open settings
      if ((e.metaKey || e.ctrlKey) && e.key === ",") {
        e.preventDefault();
        document.getElementById("settings-modal").classList.add("active");
      }

      // Cmd/Ctrl + P - Open prompt library
      if ((e.metaKey || e.ctrlKey) && e.key === "p") {
        e.preventDefault();
        promptLibrary.open();
      }

      // Cmd/Ctrl + B - Toggle sidebar
      if ((e.metaKey || e.ctrlKey) && e.key === "b") {
        e.preventDefault();
        ui.toggleSidebar();
      }

      // Cmd/Ctrl + D - Toggle dark mode
      if ((e.metaKey || e.ctrlKey) && e.key === "d") {
        e.preventDefault();
        ui.toggleTheme();
      }

      // / - Focus input (when not typing)
      if (e.key === "/" && !isInputFocused) {
        e.preventDefault();
        document.getElementById("user-input").focus();
      }

      // ? - Show keyboard shortcuts modal (Cycle 2 Feature)
      if (e.key === "?" && !isInputFocused) {
        e.preventDefault();
        document.getElementById("shortcuts-modal").classList.add("active");
      }
    });

    // Cycle 2 Feature: Shortcuts modal close handlers
    document.getElementById("shortcuts-close").addEventListener("click", () => {
      document.getElementById("shortcuts-modal").classList.remove("active");
    });

    document.getElementById("shortcuts-modal").addEventListener("click", (e) => {
      if (e.target.id === "shortcuts-modal") {
        document.getElementById("shortcuts-modal").classList.remove("active");
      }
    });

    // Backdrop Click to Close - Cycle 10 Feature
    document.getElementById("settings-modal").addEventListener("click", (e) => {
      if (e.target.id === "settings-modal") {
        document.getElementById("settings-modal").classList.remove("active");
      }
    });

    document.getElementById("endpoint-modal").addEventListener("click", (e) => {
      if (e.target.id === "endpoint-modal") {
        document.getElementById("endpoint-modal").classList.remove("active");
      }
    });

    document.getElementById("time-machine-modal").addEventListener("click", (e) => {
      if (e.target.id === "time-machine-modal") {
        document.getElementById("time-machine-modal").classList.remove("active");
      }
    });

    // Cycle 28: Toggle switch accessibility - click and keyboard support
    document.querySelectorAll('.toggle-switch[role="switch"]').forEach(toggle => {
      toggle.addEventListener('click', () => {
        const isActive = toggle.classList.toggle('active');
        toggle.setAttribute('aria-checked', isActive.toString());
      });
      toggle.addEventListener('keydown', (e) => {
        if (e.key === ' ' || e.key === 'Enter') {
          e.preventDefault();
          const isActive = toggle.classList.toggle('active');
          toggle.setAttribute('aria-checked', isActive.toString());
        }
      });
    });

    // Cycle 2 Feature: Scroll-to-bottom button
    const scrollToBottomBtn = document.getElementById("scroll-to-bottom");
    const chatMessagesContainer = document.getElementById("chat-messages");
    let unreadCount = 0;

    // Check scroll position to show/hide button - Throttled with rAF (Cycle 11)
    let scrollTicking = false;
    chatMessagesContainer.addEventListener("scroll", () => {
      if (!scrollTicking) {
        requestAnimationFrame(() => {
          const isScrolledUp = chatMessagesContainer.scrollHeight - chatMessagesContainer.scrollTop - chatMessagesContainer.clientHeight > 100;

          if (isScrolledUp) {
            scrollToBottomBtn.classList.add("visible");
          } else {
            scrollToBottomBtn.classList.remove("visible");
            unreadCount = 0;
            const badge = scrollToBottomBtn.querySelector(".unread-badge");
            if (badge) badge.remove();
          }
          scrollTicking = false;
        });
        scrollTicking = true;
      }
    });

    // Click to scroll to bottom
    scrollToBottomBtn.addEventListener("click", () => {
      chatMessagesContainer.scrollTo({
        top: chatMessagesContainer.scrollHeight,
        behavior: "smooth"
      });
    });

    // Track new messages when scrolled up (for unread badge)
    const originalAddMessageToUI = ui.addMessageToUI.bind(ui);
    ui.addMessageToUI = function(...args) {
      const result = originalAddMessageToUI(...args);

      // Check if scrolled up when new message arrives
      const isScrolledUp = chatMessagesContainer.scrollHeight - chatMessagesContainer.scrollTop - chatMessagesContainer.clientHeight > 100;
      if (isScrolledUp && args[1] === "assistant") {
        unreadCount++;
        let badge = scrollToBottomBtn.querySelector(".unread-badge");
        if (!badge) {
          badge = document.createElement("span");
          badge.className = "unread-badge";
          scrollToBottomBtn.appendChild(badge);
        }
        badge.textContent = unreadCount > 9 ? "9+" : unreadCount;
      }

      return result;
    };

    // Add fade out animation
    const style = document.createElement("style");
    style.textContent = `
      @keyframes fadeOut {
        to {
          opacity: 0;
          transform: translateY(-20px);
        }
      }
    `;
    document.head.appendChild(style);

    // Force load voices for speech synthesis
    if ("speechSynthesis" in window) {
      speechSynthesis.getVoices();
      window.speechSynthesis.onvoiceschanged = () => {
        speechSynthesis.getVoices();
      };
    }

    // Cycle 3 Feature: Rich tooltip system with keyboard shortcuts
    (function initRichTooltips() {
      // Create tooltip element
      const tooltip = document.createElement('div');
      tooltip.className = 'rich-tooltip';
      tooltip.id = 'rich-tooltip';
      document.body.appendChild(tooltip);

      let tooltipTimeout = null;
      const DELAY = 500;

      const tooltipData = [
        { selector: '#menu-toggle', text: 'Quick Actions Menu', shortcut: null },
        { selector: '#prompt-library-btn-fab', text: 'Power Prompts', shortcut: 'P' },
        { selector: '#clear-chat', text: 'Clear Chat', shortcut: null },
        { selector: '#sidebar-toggle', text: 'Toggle Sidebar', shortcut: 'B' },
        { selector: '#theme-toggle', text: 'Toggle Theme', shortcut: 'D' },
        { selector: '#scroll-to-bottom', text: 'Scroll to Bottom', shortcut: null },
        { selector: '.voice-button', text: 'Voice Input', shortcut: null },
        { selector: '#send-button', text: 'Send Message', shortcut: 'Enter' },
        { selector: '#archive-chat', text: 'Archive Chat', shortcut: null }
      ];

      function showTooltip(event, text, shortcut) {
        clearTimeout(tooltipTimeout);

        tooltipTimeout = setTimeout(() => {
          const content = shortcut
            ? `<div class="rich-tooltip-content">${text}<span class="rich-tooltip-shortcut">${shortcut}</span></div>`
            : text;

          tooltip.innerHTML = content;

          const rect = event.target.getBoundingClientRect();

          // Position above the element
          let top = rect.top - tooltip.offsetHeight - 8;
          let left = rect.left + (rect.width / 2) - (tooltip.offsetWidth / 2);

          // Flip below if not enough space
          if (top < 10) {
            top = rect.bottom + 8;
          }

          // Keep within viewport
          if (left < 10) left = 10;
          if (left + tooltip.offsetWidth > window.innerWidth - 10) {
            left = window.innerWidth - tooltip.offsetWidth - 10;
          }

          tooltip.style.top = `${top}px`;
          tooltip.style.left = `${left}px`;
          tooltip.classList.add('visible');
        }, DELAY);
      }

      function hideTooltip() {
        clearTimeout(tooltipTimeout);
        tooltip.classList.remove('visible');
      }

      // Attach to elements
      tooltipData.forEach(({ selector, text, shortcut }) => {
        const elements = document.querySelectorAll(selector);
        elements.forEach(el => {
          // Remove default title if present
          if (el.hasAttribute('title')) {
            el.removeAttribute('title');
          }

          el.addEventListener('mouseenter', (e) => showTooltip(e, text, shortcut));
          el.addEventListener('mouseleave', hideTooltip);
          el.addEventListener('click', hideTooltip);
        });
      });
    })();
  </script>
</body>

</html>
